/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 155);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(21);
var hide = __webpack_require__(14);
var redefine = __webpack_require__(15);
var ctx = __webpack_require__(22);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(58)('wks');
var uid = __webpack_require__(39);
var Symbol = __webpack_require__(2).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(3)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var IE8_DOM_DEFINE = __webpack_require__(104);
var toPrimitive = __webpack_require__(25);
var dP = Object.defineProperty;

exports.f = __webpack_require__(6) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(27);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(26);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _vertexShader = __webpack_require__(141);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * WebGL2 class
 */
var WebGL2 = function () {
  function WebGL2() {
    _classCallCheck(this, WebGL2);

    this.supportWebGL2 = false;
    this._vertexShader = null;

    this.toDelete = {
      textures: [],
      buffers: [],
      shaders: [],
      programs: [],
      framebuffers: []
    };

    this.canvas = document.createElement('canvas');
    this.context = this.canvas.getContext('webgl2');
    var gl = this.context;
    if (gl) {
      this.supportWebGL2 = true;

      // gl.R32F sized format become color-renderable
      gl.getExtension('EXT_color_buffer_float');

      this.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      this.MAX_TEXTURE_IMAGE_UNITS = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this._loadVertexShader();
    } else {
      console.log('[WebGL2] Do not support WebGL2.');
    }
  }

  /**
  * Load vertex shader.
  */


  _createClass(WebGL2, [{
    key: '_loadVertexShader',
    value: function _loadVertexShader() {
      var gl = this.context;

      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
      if (vertexShader == null) {
        this.deleteAll();
        throw new Error('[WebGL2] Unable to create vertex shader');
      }
      this.toDelete.shaders.push(vertexShader);

      gl.shaderSource(vertexShader, _vertexShader.vertexShaderSource);
      gl.compileShader(vertexShader);

      var compiled = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);
      if (!compiled) {
        var errorMsg = '[WebGL2] Failed to compile vertex shader: ' + gl.getShaderInfoLog(vertexShader);
        this.deleteAll();
        throw new Error(errorMsg);
      }

      this._vertexShader = vertexShader;
    }

    /**
     * initialize Vertex Buffers
     *
     * @param {WebGLProgram} program
     */

  }, {
    key: '_initVertexBuffers',
    value: function _initVertexBuffers(program) {
      var gl = this.context;

      var position = gl.getAttribLocation(program, 'position');
      if (position < 0) {
        this.deleteAll();
        throw new Error('[WebGL2] Failed to get position in vertexShaderSource');
      }

      var vertexPositionBuffer = gl.createBuffer();
      if (!vertexPositionBuffer) {
        this.deleteAll();
        throw new Error('[WebGL2] Failed to create the buffer object');
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
      this.toDelete.buffers.push(vertexPositionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 0.0, 1.0, -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 1.0, 0.0]), gl.STATIC_DRAW);
      gl.vertexAttribPointer(position, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(position);

      var texcoord = gl.getAttribLocation(program, 'texcoord');
      if (texcoord < 0) {
        this.deleteAll();
        throw new Error('[WebGL2] Failed to get texcoord in vertexShaderSource');
      }

      var vertexTexcoordBuffer = gl.createBuffer();
      if (!vertexTexcoordBuffer) {
        this.deleteAll();
        throw new Error('[WebGL2] Failed to create the buffer object');
      }

      gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexcoordBuffer);
      this.toDelete.buffers.push(vertexTexcoordBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]), gl.STATIC_DRAW);
      gl.vertexAttribPointer(texcoord, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(texcoord);
    }

    /**
     * Load fragment shader, creates program and initialize Vertex Buffers
     *
     * @param {string} fragmentShaderSource
     * @returns {WebGLProgram} program
     */

  }, {
    key: 'createProgram',
    value: function createProgram(fragmentShaderSource) {
      var gl = this.context;

      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      if (fragmentShader == null) {
        this.deleteAll();
        throw new Error('[WebGL2] Unable to create fragment shader');
      }
      this.toDelete.shaders.push(fragmentShader);

      gl.shaderSource(fragmentShader, fragmentShaderSource);
      gl.compileShader(fragmentShader);

      var compiled = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);
      if (!compiled) {
        var errorMsg = '[WebGL2] Failed to compile fragment shader: ' + gl.getShaderInfoLog(fragmentShader);
        this.deleteAll();
        throw new Error(errorMsg);
      }

      var program = gl.createProgram();
      if (!program) {
        this.deleteAll();
        throw new Error('[WebGL2] Unable to create program');
      }
      this.toDelete.programs.push(program);

      gl.attachShader(program, this._vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!linked) {
        var _errorMsg = '[WebGL2] Failed to link program: ' + gl.getProgramInfoLog(program);
        this.deleteAll();
        throw new Error(_errorMsg);
      }

      this._initVertexBuffers(program);
      return program;
    }

    /**
     * Runs program
     *
     * @param {WebGLProgram} options.program
     * @param {Tensor} options.output
     * @param {Object[]} options.inputs For example: [x, indexMap, kernel, bias]
     * @param {Object[]} options.uniforms
     * @param {Boolean} supportSliceTexture
     */

  }, {
    key: 'runProgram',
    value: function runProgram(_ref) {
      var program = _ref.program,
          output = _ref.output,
          inputs = _ref.inputs,
          uniforms = _ref.uniforms,
          _ref$supportSliceText = _ref.supportSliceTexture,
          supportSliceTexture = _ref$supportSliceText === undefined ? false : _ref$supportSliceText;

      if (!program) throw new Error('[WebGL2] No program in WebGL2 runProgram');
      if (!output) throw new Error('[WebGL2] No output in WebGL2 runProgram');
      if (!inputs) throw new Error('[WebGL2] No inputs in WebGL2 runProgram');

      var gl = this.context;

      gl.useProgram(program);
      if (uniforms && Array.isArray(uniforms)) {
        this._bindUniforms(program, uniforms);
      }

      if (output.textureSlices) {
        if (!supportSliceTexture) {
          throw new Error('[WebGL2] Program does not support texture fragments');
        }

        // Get inputs with slices such as indexMap, but not x(colStackTexture) or kernel/bias(no slices)
        var inputsWithSlices = inputs.filter(function (obj) {
          return obj.input.textureSlices && !obj.input.colStackTexture;
        });
        var numSlices = output.textureSlices.length;
        if (inputsWithSlices.some(function (obj) {
          return obj.input.textureSlices.length !== numSlices;
        })) {
          throw new Error('[WebGL2] Number of texture slices in inputs and output do not match');
        }

        // For each k, run 1 slice
        for (var k = 0; k < numSlices; k++) {
          this.bindOutputTexture(output.textureSlices[k], output.textureSliceShape);
          this._bindInputTextures(program, inputs, k);
          gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
        }
      } else {
        this.bindOutputTexture(output.texture, output.textureShape);
        this._bindInputTextures(program, inputs);
        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
      }
    }

    /**
    * Bind uniforms
    *
    * @param {WebGLProgram} program
    * @param {Object[]} uniforms
    */

  }, {
    key: '_bindUniforms',
    value: function _bindUniforms(program, uniforms) {
      var gl = this.context;

      uniforms.forEach(function (_ref2) {
        var value = _ref2.value,
            type = _ref2.type,
            name = _ref2.name;

        var uniformLocation = gl.getUniformLocation(program, name);
        if (type === 'float') {
          gl.uniform1f(uniformLocation, value);
        } else if (type === 'int' || type === 'bool') {
          gl.uniform1i(uniformLocation, value);
        }
      });
    }

    /**
     * Bind input textures
     *
     * @param {WebGLProgram} program
     * @param {Object[]} inputs
     * @param {number} [k]
     */

  }, {
    key: '_bindInputTextures',
    value: function _bindInputTextures(program, inputs, k) {
      var _this = this;

      var gl = this.context;

      inputs.forEach(function (_ref3, i) {
        var input = _ref3.input,
            name = _ref3.name;

        gl.activeTexture(gl.TEXTURE0 + i);
        if (input.textureSlices) {
          if (input.colStackTexture) {
            var _getTextureOptions = _this.getTextureOptions(input.textureType, input.textureFormat),
                textureTarget = _getTextureOptions.textureTarget;

            gl.bindTexture(textureTarget, input.colStackTexture);
          } else {
            var _getTextureOptions2 = _this.getTextureOptions(input.textureType, input.textureFormat),
                _textureTarget = _getTextureOptions2.textureTarget;

            gl.bindTexture(_textureTarget, input.textureSlices[k]);
          }
        } else {
          var _getTextureOptions3 = _this.getTextureOptions(input.textureType, input.textureFormat),
              _textureTarget2 = _getTextureOptions3.textureTarget;

          gl.bindTexture(_textureTarget2, input.texture);
        }
        gl.uniform1i(gl.getUniformLocation(program, name), i);
      });
    }

    /**
     * Bind output texture
     *
     * @param {WebGLTexture} outputTexture
     * @param {number[]} shape
     */

  }, {
    key: 'bindOutputTexture',
    value: function bindOutputTexture(outputTexture, shape) {
      var gl = this.context;

      gl.viewport(0, 0, shape[1], shape[0]);
      if (!this.framebuffer) {
        this.framebuffer = gl.createFramebuffer();
        this.toDelete.framebuffers.push(this.framebuffer);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outputTexture, 0);
    }

    /**
     * Reads pixel data from framebuffer
     *
     * @param {number[]} shape
     * @returns {Float32Array}
     */

  }, {
    key: 'readData',
    value: function readData(shape) {
      var gl = this.context;

      var buf = new ArrayBuffer(shape[0] * shape[1] * 4 * 4);
      var view = new Float32Array(buf);
      gl.readPixels(0, 0, shape[1], shape[0], gl.RGBA, gl.FLOAT, view);
      var out = [];
      for (var i = 0; i < view.length; i += 4) {
        out.push(view[i]);
      }
      return new Float32Array(out);
    }

    /**
     * Gets WebGLTexture options constants
     */

  }, {
    key: 'getTextureOptions',
    value: function getTextureOptions(type, format) {
      var gl = this.context;

      var targetMap = {
        '2d': gl.TEXTURE_2D
      };

      var internalFormatMap = {
        float: gl.R32F,
        int: gl.R32I
      };

      var formatMap = {
        float: gl.RED,
        int: gl.RED_INTEGER
      };

      var typeMap = {
        float: gl.FLOAT,
        int: gl.INT
      };

      var textureTarget = targetMap[type];
      var textureInternalFormat = internalFormatMap[format];
      var textureFormat = formatMap[format];
      var textureType = typeMap[format];

      return { textureTarget: textureTarget, textureInternalFormat: textureInternalFormat, textureFormat: textureFormat, textureType: textureType };
    }

    /**
     * Deletes all stored references to WebGL textures, buffers, shaders, programs and framebuffers
     */

  }, {
    key: 'deleteAll',
    value: function deleteAll() {
      var gl = this.context;

      this.toDelete.textures.forEach(function (texture) {
        return gl.deleteTexture(texture);
      });
      this.toDelete.buffers.forEach(function (buffer) {
        return gl.deleteBuffer(buffer);
      });
      this.toDelete.shaders.forEach(function (shader) {
        return gl.deleteShader(shader);
      });
      this.toDelete.programs.forEach(function (program) {
        return gl.deleteProgram(program);
      });
      this.toDelete.framebuffers.forEach(function (Framebuffer) {
        return gl.deleteFramebuffer(Framebuffer);
      });
      this.framebuffer = null;
      this.readFramebuffer = null;
      this.concateFramebuffer = null;

      this.toDelete = {
        textures: [],
        buffers: [],
        shaders: [],
        programs: [],
        framebuffers: []
      };
    }
  }]);

  return WebGL2;
}();

var webgl2 = new WebGL2();
// webgl2.MAX_TEXTURE_SIZE = 4096;
// webgl2.MAX_TEXTURE_IMAGE_UNITS = 16;
// console.log(`[WebGL2] MAX_TEXTURE_SIZE: ${webgl2.MAX_TEXTURE_SIZE}`)
// console.log(`[WebGL2] MAX_TEXTURE_IMAGE_UNITS: ${webgl2.MAX_TEXTURE_IMAGE_UNITS}`)

exports.default = webgl2;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Layer = function () {
  /**
   * Creates a layer
   *
   * @param {Object} [attrs] - layer attributes
   */
  function Layer() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Layer);

    this.name = 'Layer';
    this.weights = {};
    this.inputs = attrs.inputs;
    this.outputs = attrs.outputs;
  }

  /**
   * Throws Error, adding layer context info to message
   *
   * @param {string} message
   */


  _createClass(Layer, [{
    key: 'throwError',
    value: function throwError(message) {
      throw new Error('[Layer: ' + (this.name || '') + '] ' + message);
    }

    /**
     * Set layer weights
     *
     * @param {Tensor[]} weightsArr - array of weights which are instances of Tensor
     * @param {boolean} createGLTexture
     */

  }, {
    key: 'setWeights',
    value: function setWeights(params, weightsArr) {
      var _this = this;

      var createGLTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      params.forEach(function (p, i) {
        _this.weights[p] = weightsArr[i];
        if (createGLTexture) {
          _this.weights[p].createGLTexture({ type: '2d', format: 'float' });
        }
      });
    }

    /**
     * Layer computational logic
     *
     * @param {Tensor} x
     * @returns {Tensor}
     */

  }, {
    key: 'call',
    value: function call(x) {
      this.output = x;
      return this.output;
    }
  }]);

  return Layer;
}();

exports.default = Layer;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _tensorUtils = __webpack_require__(35);

var tensorUtils = _interopRequireWildcard(_tensorUtils);

var _ndarray = __webpack_require__(73);

var _ndarray2 = _interopRequireDefault(_ndarray);

var _ndarrayOps = __webpack_require__(36);

var _ndarrayOps2 = _interopRequireDefault(_ndarrayOps);

var _ndarraySqueeze = __webpack_require__(142);

var _ndarraySqueeze2 = _interopRequireDefault(_ndarraySqueeze);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Tensor class
 */
var Tensor = function () {
  /**
   * Creates a tensor
   *
   * @param {(TypedArray|Array)} data
   * @param {number[]} shape
   * @param {Object} type
   */
  function Tensor(data, shape, type) {
    _classCallCheck(this, Tensor);

    this.is1D = false;
    this.arrayType = type || Float32Array;
    if (data && data.length && (data instanceof this.arrayType || Array.isArray(data))) {
      if (data.length && shape.length && data.length !== shape.reduce(function (a, b) {
        return a * b;
      })) {
        throw new Error('[Tensor] Tensor shape does not match the length of data.');
      }
      if (data instanceof this.arrayType) {
        this.tensor = (0, _ndarray2.default)(data, shape);
      } else if (data instanceof Array) {
        this.tensor = (0, _ndarray2.default)(new this.arrayType(data), shape);
      }
    } else if (!data.length && shape.length) {
      // Initialize tensor data with 0 when data is not given
      this.tensor = (0, _ndarray2.default)(new this.arrayType(shape.reduce(function (a, b) {
        return a * b;
      })), shape);
    } else {
      this.tensor = (0, _ndarray2.default)(new this.arrayType([]), []);
    }
  }

  /**
   * Creates WebGL2 texture
   *
   * Without args, defaults to gl.TEXTURE_2D and gl.R32F
   *
   * @param {string} [opts.type]
   * @param {string} [opts.format]
   * @param {boolean} [opts.supportSliceTexture]
   */


  _createClass(Tensor, [{
    key: 'createGLTexture',
    value: function createGLTexture(_ref) {
      var _ref$type = _ref.type,
          type = _ref$type === undefined ? '2d' : _ref$type,
          _ref$format = _ref.format,
          format = _ref$format === undefined ? 'float' : _ref$format,
          _ref$supportSliceText = _ref.supportSliceTexture,
          supportSliceTexture = _ref$supportSliceText === undefined ? false : _ref$supportSliceText;

      var shape = [];
      if (this.tensor.shape.length === 1) {
        shape = [1, this.tensor.shape[0]];
        this.is1D = true;
      } else if (this.tensor.shape.length === 2) {
        shape = this.tensor.shape;
      } else {
        throw new Error('[Tensor] Can not create WebGL2 texture for shape length > 2.');
      }

      this.textureShape = shape;
      this.textureType = type;
      this.textureFormat = format;

      if (type === '2d') {
        if (this.textureShape[1] > _WebGL2.default.MAX_TEXTURE_SIZE) {
          throw new Error('[Tensor] Tensor shape[1] ' + this.textureShape[1] + ' > MAX_TEXTURE_SIZE ' + _WebGL2.default.MAX_TEXTURE_SIZE);
        }
        if (this.textureShape[0] > _WebGL2.default.MAX_TEXTURE_SIZE) {
          if (supportSliceTexture) {
            this._createTextureSlices();
          } else {
            throw new Error('[Tensor] Tensor shape[0] ' + this.textureShape[0] + ' > MAX_TEXTURE_SIZE ' + _WebGL2.default.MAX_TEXTURE_SIZE);
          }
        } else {
          this._create2DGLTexture();
        }
      } else {
        throw new Error('[Tensor] Invalid type: ' + type);
      }
    }

    /**
     * Create 2D WebGL2 texture
     * 
     * WebGL1 can only use non power of 2 textures with filtering set to NEAREST or LINEAR and
     * it can not generate a mipmap for them.
     */

  }, {
    key: '_create2DGLTexture',
    value: function _create2DGLTexture() {
      var gl = _WebGL2.default.context;
      var textureOptions = _WebGL2.default.getTextureOptions(this.textureType, this.textureFormat);
      var textureTarget = textureOptions.textureTarget,
          textureInternalFormat = textureOptions.textureInternalFormat,
          textureFormat = textureOptions.textureFormat,
          textureType = textureOptions.textureType;


      this.texture = gl.createTexture();
      _WebGL2.default.toDelete.textures.push(this.texture);
      gl.bindTexture(textureTarget, this.texture);

      var shape = this.textureShape;
      var data = this.tensor.data;
      gl.texImage2D(textureTarget, 0, textureInternalFormat, shape[1], shape[0], 0, textureFormat, textureType, data);

      // clamp to edge
      gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      // no interpolation
      gl.texParameteri(textureTarget, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(textureTarget, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    }

    /**
     * For 2D WebGL2 texture with first dimension exceeding webgl2.MAX_TEXTURE_SIZE, slice it and create an array of 2D textures
     */

  }, {
    key: '_createTextureSlices',
    value: function _createTextureSlices() {
      var gl = _WebGL2.default.context;
      var textureOptions = _WebGL2.default.getTextureOptions(this.textureType, this.textureFormat);
      var textureTarget = textureOptions.textureTarget,
          textureInternalFormat = textureOptions.textureInternalFormat,
          textureFormat = textureOptions.textureFormat,
          textureType = textureOptions.textureType;


      this.textureSlices = [];
      this.textureSliceShape = [_WebGL2.default.MAX_TEXTURE_SIZE, this.textureShape[1]];

      var shape = this.textureSliceShape;
      var numSlices = Math.ceil(this.textureShape[0] / _WebGL2.default.MAX_TEXTURE_SIZE);
      var offset = 0;

      for (var k = 0; k < numSlices; k++) {
        var texture = gl.createTexture();
        _WebGL2.default.toDelete.textures.push(texture);
        gl.bindTexture(textureTarget, texture);

        // append 0s to last slice
        var data = void 0;
        if (k === numSlices - 1) {
          data = new this.arrayType(shape[0] * shape[1]);
          data.set(this.tensor.data.slice(offset, offset + shape[0] * shape[1]), 0);
        } else {
          data = this.tensor.data.slice(offset, offset + shape[0] * shape[1]);
        }
        gl.texImage2D(textureTarget, 0, textureInternalFormat, shape[1], shape[0], 0, textureFormat, textureType, data);

        // clamp to edge
        gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // no interpolation
        gl.texParameteri(textureTarget, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(textureTarget, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

        this.textureSlices.push(texture);
        offset += shape[0] * shape[1];
      }
      // console.log(`Create slices: ${numSlices}`);
    }

    /**
     * Converts an array of horizontal-slice textureSlices into a single column-stacked texture
     */

  }, {
    key: 'convertTextureSlicesToColStackTexture',
    value: function convertTextureSlicesToColStackTexture() {
      var _this = this;

      if (!this.textureSlices || !this.textureSliceShape) {
        throw new Error('[Tensor] No textureSlices available in convertTextureSlicesToColStackTexture method.');
      }
      // console.log('[Tensor] convertTextureSlicesToColStackTexture');
      var gl = _WebGL2.default.context;
      var textureOptions = _WebGL2.default.getTextureOptions(this.textureType, this.textureFormat);
      var textureTarget = textureOptions.textureTarget,
          textureInternalFormat = textureOptions.textureInternalFormat,
          textureFormat = textureOptions.textureFormat,
          textureType = textureOptions.textureType;


      if (!this.colStackTexture) {
        this.colStackTexture = gl.createTexture();
        _WebGL2.default.toDelete.textures.push(this.colStackTexture);
        gl.bindTexture(textureTarget, this.colStackTexture);

        var numSlices = this.textureSlices.length;
        this.colStackTextureShape = [this.textureSliceShape[0], this.textureSliceShape[1] * numSlices];
        if (this.colStackTextureShape[1] > _WebGL2.default.MAX_TEXTURE_SIZE) {
          throw new Error('[Tensor] colStackTextureShape[1] ' + this.colStackTextureShape[1] + ' > MAX_TEXTURE_SIZE ' + _WebGL2.default.MAX_TEXTURE_SIZE);
        }

        var shape = this.colStackTextureShape;
        var data = new this.arrayType(shape[0] * shape[1]);
        gl.texImage2D(textureTarget, 0, textureInternalFormat, shape[1], shape[0], 0, textureFormat, textureType, data);

        // clamp to edge
        gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(textureTarget, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // no interpolation
        gl.texParameteri(textureTarget, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(textureTarget, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      } else {
        gl.bindTexture(textureTarget, this.colStackTexture);
      }

      if (!_WebGL2.default.readFramebuffer) {
        _WebGL2.default.readFramebuffer = gl.createFramebuffer();
        _WebGL2.default.toDelete.framebuffers.push(_WebGL2.default.readFramebuffer);
      }
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, _WebGL2.default.readFramebuffer);
      this.textureSlices.forEach(function (texture, k) {
        gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.copyTexSubImage2D(textureTarget, 0, k * _this.textureSliceShape[1], 0, 0, 0, _this.textureSliceShape[1], _this.textureSliceShape[0]);
      });
    }

    /**
     * Delete colStackTexture
     */

  }, {
    key: 'deleteColStackTexture',
    value: function deleteColStackTexture() {
      if (this.colStackTexture) {
        var _gl = _WebGL2.default.context;
        _gl.deleteTexture(this.colStackTexture);
        delete this.colStackTexture;
        delete this.colStackTextureShape;
      }
    }

    /**
     * Delete WebGLTexture
     */

  }, {
    key: 'deleteGLTexture',
    value: function deleteGLTexture() {
      _WebGL2.default.toDelete.textures.forEach(function (texture) {
        return gl.deleteTexture(texture);
      });
      _WebGL2.default.toDelete.textures = [];
    }

    /**
     * Replaces data in the underlying ndarray, and the corresponding WebGLTexture if texture is present
     *
     * @param {number[]} data
     */

  }, {
    key: 'replaceTensorData',
    value: function replaceTensorData(data) {
      var _this2 = this;

      if (data && data.length && data instanceof this.arrayType) {
        this.tensor.data.set(data);
      } else if (data && data.length && data instanceof Array) {
        this.tensor.data.set(new this.arrayType(data));
      } else {
        throw new Error('[Tensor] Invalid input for replaceTensorData method.');
      }

      if (this.texture) {
        var _gl2 = _WebGL2.default.context;
        var shape = this.textureShape;
        var textureOptions = _WebGL2.default.getTextureOptions(this.textureType, this.textureFormat);
        var textureTarget = textureOptions.textureTarget,
            textureFormat = textureOptions.textureFormat,
            textureType = textureOptions.textureType;


        _gl2.bindTexture(textureTarget, this.texture);
        _gl2.texSubImage2D(textureTarget, 0, 0, 0, shape[1], shape[0], textureFormat, textureType, data, 0);
      } else if (this.textureSlices) {
        var _gl3 = _WebGL2.default.context;
        var _textureOptions = _WebGL2.default.getTextureOptions(this.textureType, this.textureFormat);
        var _textureTarget = _textureOptions.textureTarget,
            _textureFormat = _textureOptions.textureFormat,
            _textureType = _textureOptions.textureType;

        var _shape = this.textureSliceShape;
        var length = _shape[0] * _shape[1];
        var slices = Math.ceil(data.length / length);

        if (this.textureSlices.length !== slices) {
          throw new Error('[Tensor] Invalid data length in replaceTensorData method.');
        }
        this.textureSlices.forEach(function (texture, i) {
          var oneSlice = void 0;
          if (i === slices - 1) {
            var remainder = data.length % length;
            oneSlice = new _this2.arrayType(length);
            oneSlice.set(new _this2.arrayType(data.buffer, data.byteOffset + i * length * data.BYTES_PER_ELEMENT, remainder === 0 ? length : remainder), 0);
          } else {
            oneSlice = new _this2.arrayType(data.buffer, data.byteOffset + i * length * data.BYTES_PER_ELEMENT, length);
          }
          _gl3.bindTexture(_textureTarget, texture);
          _gl3.texSubImage2D(_textureTarget, 0, 0, 0, _shape[1], _shape[0], _textureFormat, _textureType, oneSlice, 0);
        });
      }
    }

    /**
     * Transfer data from webgl texture on GPU to ndarray on CPU
     */

  }, {
    key: 'transferFromGLTexture',
    value: function transferFromGLTexture() {
      if (this.textureSlices) {
        this.tensor = (0, _ndarray2.default)(new this.arrayType(this.textureShape[0] * this.textureShape[1]), this.textureShape);
        var offset = 0;
        for (var k = 0; k < this.textureSlices.length; k++) {
          // Transfer from textureSlices
          _WebGL2.default.bindOutputTexture(this.textureSlices[k], this.textureSliceShape);
          var sliceData = _WebGL2.default.readData(this.textureSliceShape);
          // Last slice needs to be truncated
          if (k === this.textureSlices.length - 1) {
            var truncate = this.tensor.data.length - offset;
            this.tensor.data.set(sliceData.subarray(0, truncate), offset);
          } else {
            this.tensor.data.set(sliceData, offset);
          }
          offset += sliceData.length;
        }
      } else {
        // Transfer from texture
        _WebGL2.default.bindOutputTexture(this.texture, this.textureShape);
        this.tensor = (0, _ndarray2.default)(new this.arrayType([]), this.textureShape);
        this.tensor.data = _WebGL2.default.readData(this.textureShape);
      }

      if (this.is1D && this.textureShape[0] === 1) {
        // collapse to 1D
        this.tensor = (0, _ndarraySqueeze2.default)(this.tensor, [0]);
      }
    }

    /**
     * Reshapes data into 2D representation preserving last axis (typically channel axis)
     */

  }, {
    key: 'reshapeTo2D',
    value: function reshapeTo2D() {
      var axis = this.tensor.shape.length - 1;
      var axisSize = this.tensor.shape[axis];
      var otherAxes = this.tensor.shape.slice(0, axis);
      var otherAxesSize = otherAxes.reduce(function (a, b) {
        return a * b;
      }, 1);

      var reshaped = (0, _ndarray2.default)(new this.arrayType(otherAxesSize * axisSize), [otherAxesSize, axisSize]);

      var otherAxesData = (0, _ndarray2.default)(new this.arrayType(otherAxesSize), otherAxes);
      var otherAxesDataRaveled = (0, _ndarray2.default)(new this.arrayType(otherAxesSize), [otherAxesSize]);
      var axisSlices = Array(this.tensor.shape.length).fill(null);
      for (var n = 0; n < axisSize; n++) {
        var _tensor;

        axisSlices[axis] = n;
        _ndarrayOps2.default.assign(otherAxesData, (_tensor = this.tensor).pick.apply(_tensor, _toConsumableArray(axisSlices)));
        otherAxesDataRaveled.data = otherAxesData.data;
        _ndarrayOps2.default.assign(reshaped.pick(null, n), otherAxesDataRaveled);
      }

      this.originalShape = this.tensor.shape;
      this.indicesForReshaped = tensorUtils.createIndicesFor2DReshaped(this.tensor.shape, false, axis);
      this.tensor = reshaped;
      this.is2DReshaped = true;
    }

    /**
     * Reshapes tensor in 2D representation back to original
     *
     * Typically called at the end when data is read back from GPU
     *
     * @param {number} axis
     */

  }, {
    key: 'reshapeFrom2D',
    value: function reshapeFrom2D() {
      var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;

      if (!this.is2DReshaped) {
        throw new Error('[Tensor] Not in reshaped 2D representation.');
      }
      if (!this.originalShape) {
        throw new Error('[Tensor] Does not contain originalShape.');
      }

      if (axis < 0) {
        axis = this.originalShape.length + axis;
      }

      // second axis is the channel, or common, axis
      var channelDataSize = this.tensor.shape[0];
      var channels = this.tensor.shape[1];

      var reshaped = (0, _ndarray2.default)(new this.arrayType(this.originalShape.reduce(function (a, b) {
        return a * b;
      }, 1)), this.originalShape);
      var channelDataRaveled = (0, _ndarray2.default)(new this.arrayType(channelDataSize), [channelDataSize]);
      var unraveledChannelShape = [].concat(_toConsumableArray(this.originalShape.slice(0, axis)), _toConsumableArray(this.originalShape.slice(axis + 1)));
      var unraveledChannel = (0, _ndarray2.default)(new this.arrayType(unraveledChannelShape.reduce(function (a, b) {
        return a * b;
      }, 1)), unraveledChannelShape);
      var axisSlices = Array(this.originalShape.length).fill(null);
      for (var n = 0; n < channels; n++) {
        _ndarrayOps2.default.assign(channelDataRaveled, this.tensor.pick(null, n));
        unraveledChannel.data = channelDataRaveled.data;
        axisSlices[axis] = n;
        _ndarrayOps2.default.assign(reshaped.pick.apply(reshaped, _toConsumableArray(axisSlices)), unraveledChannel);
      }

      this.tensor = reshaped;
    }
  }]);

  return Tensor;
}();

exports.default = Tensor;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(7);
var createDesc = __webpack_require__(38);
module.exports = __webpack_require__(6) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(14);
var has = __webpack_require__(17);
var SRC = __webpack_require__(39)('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(21).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var fails = __webpack_require__(3);
var defined = __webpack_require__(26);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(52);
var defined = __webpack_require__(26);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(53);
var createDesc = __webpack_require__(38);
var toIObject = __webpack_require__(18);
var toPrimitive = __webpack_require__(25);
var has = __webpack_require__(17);
var IE8_DOM_DEFINE = __webpack_require__(104);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(6) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(17);
var toObject = __webpack_require__(9);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 21 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.5.7' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(10);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 23 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(3);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(4);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 26 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 27 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0);
var core = __webpack_require__(21);
var fails = __webpack_require__(3);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(22);
var IObject = __webpack_require__(52);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(8);
var asc = __webpack_require__(94);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(6)) {
  var LIBRARY = __webpack_require__(33);
  var global = __webpack_require__(2);
  var fails = __webpack_require__(3);
  var $export = __webpack_require__(0);
  var $typed = __webpack_require__(69);
  var $buffer = __webpack_require__(100);
  var ctx = __webpack_require__(22);
  var anInstance = __webpack_require__(45);
  var propertyDesc = __webpack_require__(38);
  var hide = __webpack_require__(14);
  var redefineAll = __webpack_require__(47);
  var toInteger = __webpack_require__(27);
  var toLength = __webpack_require__(8);
  var toIndex = __webpack_require__(130);
  var toAbsoluteIndex = __webpack_require__(41);
  var toPrimitive = __webpack_require__(25);
  var has = __webpack_require__(17);
  var classof = __webpack_require__(54);
  var isObject = __webpack_require__(4);
  var toObject = __webpack_require__(9);
  var isArrayIter = __webpack_require__(91);
  var create = __webpack_require__(42);
  var getPrototypeOf = __webpack_require__(20);
  var gOPN = __webpack_require__(43).f;
  var getIterFn = __webpack_require__(93);
  var uid = __webpack_require__(39);
  var wks = __webpack_require__(5);
  var createArrayMethod = __webpack_require__(29);
  var createArrayIncludes = __webpack_require__(59);
  var speciesConstructor = __webpack_require__(66);
  var ArrayIterators = __webpack_require__(96);
  var Iterators = __webpack_require__(50);
  var $iterDetect = __webpack_require__(63);
  var setSpecies = __webpack_require__(44);
  var arrayFill = __webpack_require__(95);
  var arrayCopyWithin = __webpack_require__(120);
  var $DP = __webpack_require__(7);
  var $GOPD = __webpack_require__(19);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

var Map = __webpack_require__(125);
var $export = __webpack_require__(0);
var shared = __webpack_require__(58)('metadata');
var store = shared.store || (shared.store = new (__webpack_require__(128))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(39)('meta');
var isObject = __webpack_require__(4);
var has = __webpack_require__(17);
var setDesc = __webpack_require__(7).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(3)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 33 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(5)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(14)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIndicesFor2DReshaped = createIndicesFor2DReshaped;

var _ndarray = __webpack_require__(73);

var _ndarray2 = _interopRequireDefault(_ndarray);

var _ndarrayOps = __webpack_require__(36);

var _ndarrayOps2 = _interopRequireDefault(_ndarrayOps);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * Create indicesForReshaped for 2D reshaped tensor
 *
 * @param {number[]} shape
 * @param {boolean} square
 * @param {number} axis
 */
function createIndicesFor2DReshaped(shape) {
  var square = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var axis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = shape.reduce(function (a, b) {
    return a * b;
  }, 1);
  var indicesArr = (0, _ndarray2.default)(new Int32Array(size), shape);

  if (square) {
    // called by Tensor.reshapeTo2DSquare
    var squareDim = Math.ceil(Math.sqrt(size));
    var indicesRowArrReshaped = (0, _ndarray2.default)(new Int32Array(Math.pow(squareDim, 2)), [squareDim, squareDim]);
    var indicesColArrReshaped = (0, _ndarray2.default)(new Int32Array(Math.pow(squareDim, 2)), [squareDim, squareDim]);
    var indicesArrReshaped = (0, _ndarray2.default)(new Int32Array(Math.pow(squareDim, 2)), [squareDim, squareDim]);
    for (var i = 0; i < squareDim; i++) {
      _ndarrayOps2.default.assigns(indicesRowArrReshaped.pick(i, null), i);
    }
    for (var j = 0; j < squareDim; j++) {
      _ndarrayOps2.default.assigns(indicesColArrReshaped.pick(null, j), j);
    }
    // i * cols + j
    _ndarrayOps2.default.muls(indicesArrReshaped, indicesRowArrReshaped, squareDim);
    _ndarrayOps2.default.addeq(indicesArrReshaped, indicesColArrReshaped);
    indicesArr.data.set(indicesArrReshaped.data.subarray(0, indicesArr.size));
  } else {
    // called by Tensor.reshapeTo2D
    if (axis < 0) {
      axis = shape.length + axis;
    }
    var axisSize = shape[axis];
    var indicesRowArr = (0, _ndarray2.default)(new Int32Array(size), shape);
    var indicesColArr = (0, _ndarray2.default)(new Int32Array(size), shape);
    var otherAxes = [].concat(_toConsumableArray(shape.slice(0, axis)), _toConsumableArray(shape.slice(axis + 1)));
    var otherAxesSize = otherAxes.reduce(function (a, b) {
      return a * b;
    }, 1);
    var tmp = [];
    for (var _i = 0; _i < otherAxesSize; ++_i) {
      tmp.push(_i);
    }
    var indicesRowArrSlice = (0, _ndarray2.default)(new Int32Array(tmp), otherAxes);
    var axisSlices = Array(shape.length).fill(null);
    for (var n = 0; n < axisSize; n++) {
      axisSlices[axis] = n;
      _ndarrayOps2.default.assign(indicesRowArr.pick.apply(indicesRowArr, _toConsumableArray(axisSlices)), indicesRowArrSlice);
      _ndarrayOps2.default.assigns(indicesColArr.pick.apply(indicesColArr, _toConsumableArray(axisSlices)), n);
    }
    // i * cols + j
    _ndarrayOps2.default.muls(indicesArr, indicesRowArr, axisSize);
    _ndarrayOps2.default.addeq(indicesArr, indicesColArr);
  }

  return indicesArr;
}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var compile = __webpack_require__(377)

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
}

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i]
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
    }
  }
  if(!x.thisVars) {
    x.thisVars = []
  }
  if(!x.localVars) {
    x.localVars = []
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = []
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i)
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""))
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    })
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    })
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id]
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    })
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    })
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    })
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    })
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i]
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  })
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    })
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i]
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                })
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  })
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  })
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  })
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i]
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                })
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  })
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  })
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  })
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
})

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
})

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
})

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
})

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
})
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
})
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
})

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
})

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
})

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" })

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" })


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
})




/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// This file is derived from NeuralNetworks.h of  https://android.googlesource.com/platform/frameworks/ml
// The license header of NeuralNetworks.h is:
/*
 * Copyright (C) 2017 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var FuseCode = exports.FuseCode = {
  /** NO fused activation function. */
  NONE: 0,
  /** Fused ReLU activation function. */
  RELU: 1,
  /** Fused ReLU1 activation function. */
  RELU1: 2,
  /** Fused ReLU6 activation function. */
  RELU6: 3
};

var OperandCode = exports.OperandCode = {
  /** The following entries are used to declare scalars. */

  /** A 32 bit floating point scalar value. */
  FLOAT32: 0,
  /** A signed 32 bit integer scalar value. */
  INT32: 1,
  /** An unsigned 32 bit integer scalar value. */
  UINT32: 2,

  /** The following entries are used to declare tensors. */

  /** A tensor of 32 bit floating point values. */
  TENSOR_FLOAT32: 3,
  /** A tensor of 32 bit integer values. */
  TENSOR_INT32: 4,
  /** A tensor of 8 bit integers that represent real numbers.
   *
   * Attached to this tensor are two numbers that can be used to convert
   * the 8 bit integer to the real value and vice versa.  These two numbers are:
   * - scale: a 32 bit non-negative floating point value.
   * - zeroPoint: an 32 bit integer, in range [0, 255].
   *
   * The formula is:
   * real_value = (integer_value - zeroPoint) * scale.
   */
  TENSOR_QUANT8_ASYMM: 5
};

var PaddingCode = exports.PaddingCode = {
  /**
   * SAME padding.
   * Padding on both ends are the "same":
   *     padding_to_beginning =  total_padding / 2
   *     padding_to_end       = (total_padding + 1)/2.
   * i.e., for even number of padding, padding to both ends are exactly
   * the same; for odd number of padding, padding to the ending is bigger
   * than the padding to the beginning by 1.
   *
   * total_padding is a function of input, stride and filter size.
   * It could be computed as follows:
   *    out_size = (input + stride - 1) / stride;
   *    needed_input = (out_size - 1) * stride + filter_size
   *    total_padding = max(0, needed_input - output_size)
   *  The computation is the same for the horizontal and vertical directions.
   */
  SAME: 1,

  /**
   * VALID padding.
   * No padding. When the input size is not evenly divisible by
   * the filter size, the input at the end that could not fill
   * the whole filter tile will simply be ignored.
   */
  VALID: 2
};

var PreferenceCode = exports.PreferenceCode = {
  /**
   * Prefer executing in a way that minimizes battery drain.
   * This is desirable for compilations that will be executed often.
   */
  LOW_POWER: 0,
  /**
   * Prefer returning a single answer as fast as possible, even if this causes
   * more power consumption.
   */
  FAST_SINGLE_ANSWER: 1,
  /**
   * Prefer maximizing the throughput of successive frames, for example when
   * processing successive frames coming from the camera.
   */
  SUSTAINED_SPEED: 2
};

var OperationCode = exports.OperationCode = {
  /** Adds two tensors, element-wise.
   *
   * Takes two input tensors of identical type and compatible dimensions. The output
   * is the sum of both input tensors, optionally modified by an activation function.
   *
   * Two dimensions are compatible when:
   *     1. they are equal, or
   *     2. one of them is 1
   *
   * The size of the output is the maximum size along each dimension of the input operands.
   * It starts with the trailing dimensions, and works its way forward.
   *
   * Example:
   *
   *     input1.dimension = {4, 1, 2}
   *     input2.dimension = {5, 4, 3, 1}
   *     output.dimension = {5, 4, 3, 2}
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4
   *
   * Inputs:
   * * 0: A tensor.
   * * 1: A tensor of the same type, and compatible dimensions as input0.
   * * 2: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Outputs:
   * * 0: The sum, a tensor of the same type as input0.
   */
  ADD: 0,

  /** Performs a 2-D average pooling operation.
   *
   * The output dimensions are functions of the filter dimensions, stride, and padding.
   *
   * The values in the output tensor are computed as:
   *
   *     output[batch, row, col, channel] =
   *         sum_{i, j}(input[batch, row + i, col + j, channel]) / sum(1)
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: 4, with "NHWC" (i.e., Num_samples, Height, Width, and Channels)
   * data layout.
   *
   * Both explicit padding and implicit padding are supported.
   *
   * Inputs (explicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth], specifying the input.
   * * 1: An INT32 value, specifying the padding on the left, in the width dimension.
   * * 2: An INT32 value, specifying the padding on the right,in the width dimension.
   * * 3: An INT32 value, specifying the padding on the top, in the height dimension.
   * * 4: An INT32 value, specifying the padding on the bottom, in the height dimension.
   * * 5: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 6: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 7: An INT32 value, specifying the filter width.
   * * 8: An INT32 value, specifying the filter height.
   * * 9: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Inputs (implicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth], specifying the input.
   * * 1: An INT32 value, specifying the implicit padding scheme, has to be one of the
   *      {@link PaddingCode} values.
   * * 2: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 3: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 4: An INT32 value, specifying the filter width.
   * * 5: An INT32 value, specifying the filter height.
   * * 6: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Outputs:
   * * 0: The output 4-D tensor, of shape [batches, out_height, out_width, depth].
   */
  AVERAGE_POOL_2D: 1,

  /** Concatenates the input tensors along the given dimension.
   *
   * The input tensors must have identical type and the same dimensions except the
   * dimension along the concatenation axis.
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4
   *
   * Inputs:
   * * 0 ~ n-1: The list of n input tensors, of shape [D0, D1, ..., Daxis(i), ..., Dm].
   *            For inputs of {@link TENSOR_QUANT8_ASYMM} type, all
   *            input tensors must have the same scale and zeroPoint.
   * * n: An INT32 value, specifying the concatenation axis.
   *
   * Outputs:
   * * 0: The output, a tensor of the same type as the input tensors.
   *      The output shape is [D0, D1, ..., sum(Daxis(i)), ..., Dm].
   */
  CONCATENATION: 2,

  /** Performs an 2-D convolution operation.
   *
   * The CONV_2D op sweeps a 2-D filter that can mix channels together over a batch of
   * images, applying the filter to each window of each image of the appropriate size.
   *
   * The output dimensions are functions of the filter dimensions, stride, and padding.
   *
   * The values in the output tensor are computed as:
   *
   *     output[batch, row, col, channel] =
   *         sum_{i, j} (
   *             input[batch, row + i, col + j, k] *
   *             filter[channel, row + i, col + j, k] +
   *             bias[channel]
   *         )
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: 4, with "NHWC" data layout.
   *
   * Both explicit padding and implicit padding are supported.
   *
   * Inputs (explicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth_in], specifying the input.
   * * 1: A 4-D tensor, of shape [depth_out, filter_height, filter_width, depth_in],
   *      specifying the filter.
   * * 2: A 1-D tensor, of shape [depth_out], specifying the bias.
   *      For input tensor of {@link TENSOR_FLOAT32} type, the bias should
   *      also be of {@link TENSOR_FLOAT32}.
   *      For input tensor of {@link TENSOR_QUANT8_ASYMM} type, the bias
   *      should be of {@link TENSOR_INT32}, with zeroPoint of 0 and
   *      bias_scale == input_scale * filter_scale.
   * * 3: An INT32 value, specifying the padding on the left, in the width dimension.
   * * 4: An INT32 value, specifying the padding on the right,in the width dimension.
   * * 5: An INT32 value, specifying the padding on the top, in the height dimension.
   * * 6: An INT32 value, specifying the padding on the bottom, in the height dimension.
   * * 7: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 8: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 9: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Inputs (implicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth_in], specifying the input.
   * * 1: A 4-D tensor, of shape [depth_out, filter_height, filter_width, depth_in],
   *      specifying the filter.
   * * 2: A 1-D tensor, of shape [depth_out], specifying the bias.
   *      For input tensor of {@link TENSOR_FLOAT32} type, the bias should
   *      also be of {@link TENSOR_FLOAT32}.
   *      For input tensor of {@link TENSOR_QUANT8_ASYMM} type, the bias
   *      should be of {@link TENSOR_INT32}, with zeroPoint of 0 and
   *      bias_scale == input_scale * filter_scale.
   * * 3: An INT32 value, specifying the implicit padding scheme, has to be one of the
   *      {@link PaddingCode} values.
   * * 4: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 5: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 6: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Outputs:
   * * 0: The output 4-D tensor, of shape [batches, out_height, out_width, depth_out].
   *      For output tensor of {@link TENSOR_QUANT8_ASYMM} type, the following
   *      condition must be satisfied: output_scale > input_scale * filter_scale.
   */
  CONV_2D: 3,

  /** Performs a depthwise 2-D convolution operation.
   *
   * Given an input tensor of shape [batches, height, width, depth_in] and a filter
   * tensor of shape [1, filter_height, filter_width, depth_out] containing
   * depth_out convolutional filters of depth 1, DEPTHWISE_CONV applies a different
   * filter to each input channel (expanding from 1 channel to channel_multiplier channels
   * for each), then concatenates the results together.
   *
   * The output has depth_out = depth_in * depth_multiplier channels.
   * The output dimensions are functions of the filter dimensions, stride, and padding.
   *
   * The values in the output tensor are computed as:
   *
   *     output[b, i, j, k * channel_multiplier + q] =
   *         sum_{di, dj} (
   *             input[b, strides[1] * i + di, strides[2] * j + dj, k] *
   *             filter[1, di, dj, k * channel_multiplier + q]
   *         )
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: 4, with "NHWC" data layout.
   *
   * Both explicit padding and implicit padding are supported.
   *
   * Inputs (explicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth_in], specifying the input.
   * * 1: A 4-D tensor, of shape [1, filter_height, filter_width, depth_out],
   *      specifying the filter.
   * * 2: A 1-D tensor, of shape [depth_out], specifying the bias.
   *      For input tensor of {@link TENSOR_FLOAT32} type, the bias should
   *      also be of {@link TENSOR_FLOAT32}.
   *      For input tensor of {@link TENSOR_QUANT8_ASYMM} type, the bias
   *      should be of {@link TENSOR_INT32}, with zeroPoint of 0 and
   *      bias_scale == input_scale * filter_scale.
   * * 3: An INT32 value, specifying the padding on the left, in the width dimension.
   * * 4: An INT32 value, specifying the padding on the right,in the width dimension.
   * * 5: An INT32 value, specifying the padding on the top, in the height dimension.
   * * 6: An INT32 value, specifying the padding on the bottom, in the height dimension.
   * * 7: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 8: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 9: An INT32 value, specifying the depthwise multiplier.
   * * 10: An INT32 value, and has to be one of the {@link FuseCode} values.
   *       Specifies the activation to invoke on the result of each addition.
   *
   * Inputs (implicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth_in], specifying the input.
   * * 1: A 4-D tensor, of shape [1, filter_height, filter_width, depth_out],
   *      specifying the filter.
   * * 2: A 1-D tensor, of shape [depth_out], specifying the bias.
   *      For input tensor of {@link TENSOR_FLOAT32} type, the bias should
   *      also be of {@link TENSOR_FLOAT32}.
   *      For input tensor of {@link TENSOR_QUANT8_ASYMM} type, the bias
   *      should be of {@link TENSOR_INT32}, with zeroPoint of 0 and
   *      bias_scale == input_scale * filter_scale.
   * * 3: An INT32 value, specifying the implicit padding scheme, has to be one of the
   *      {@link PaddingCode} values.
   * * 4: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 5: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 6: An INT32 value, specifying the depthwise multiplier.
   * * 7: An INT32 value, and has to be one of the {@link FuseCode} values.
   *       Specifies the activation to invoke on the result of each addition.
   *
   * Outputs:
   * * 0: The output 4-D tensor, of shape [batches, out_height, out_width, depth_out].
   *      For output tensor of {@link TENSOR_QUANT8_ASYMM} type, the following
   *      condition must be satisfied: output_scale > input_scale * filter_scale.
   */
  DEPTHWISE_CONV_2D: 4,

  /** Rearranges data from depth into blocks of spatial data.
   *
   * More specifically, this op outputs a copy of the input tensor where values from
   * the depth dimension are moved in spatial blocks to the height and width dimensions.
   * The value block_size indicates the input block size and how the data is moved.
   *
   * Chunks of data of size block_size * block_size from depth are rearranged into
   * non-overlapping blocks of size block_size x block_size.
   *
   * The width of the output tensor is input_depth * block_size, whereas the height is
   * input_height * block_size.
   * The depth of the input tensor must be divisible by block_size * block_size
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: 4, with "NHWC" data layout.
   *
   * Inputs:
   * * 0: A 4-D tensor, of shape [batches, height, width, depth_in], specifying the input.
   * * 1: An INT32 value, specifying the block_size. block_size must be >=1 and
   *      block_size * block_size must be a divisor of the input depth.
   *
   * Outputs:
   * * 0: The output 4-D tensor, of shape [batch, height*block_size, width*block_size,
   *      depth/(block_size*block_size)].
   */
  DEPTH_TO_SPACE: 5,

  /** Dequantizes the input tensor.
   *
   * The formula is:
   *
   *     output = (input - zeroPoint) * scale.
   *
   * Supported tensor types:
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4
   *
   * Inputs:
   * * 0: A tensor of type {@link TENSOR_QUANT8_ASYMM}.
   *
   * Outputs:
   * * 0: The output tensor of same shape as input0, but with type
   *      {@link TENSOR_FLOAT32}.
   */
  DEQUANTIZE: 6,

  /** Looks up sub-tensors in the input tensor.
   *
   * This operator takes for input a tensor of values (Values) and
   * a one-dimensional tensor of selection indices (Lookups).
   * The output tensor is the concatenation of sub-tensors of Values as
   * selected by Lookups.
   *
   * Think of Values as being sliced along its first dimension:
   * The entries in Lookups select which slices are concatenated together
   * to create the output tensor.
   *
   * For example, if Values has shape of [40, 200, 300] and
   * Lookups has shape of [3], we would expect all three values
   * found in Lookups to be  between 0 and 39. The resulting tensor will
   * have shape of [3, 200, 300].
   *
   * If a value in Lookups is out of bounds, the operation will fail
   * and an error will be reported.
   *
   * Inputs:
   * * 0: Lookups. A 1-D tensor of {@link TENSOR_INT32} type.
   *      The values are indices into the first dimension of Values.
   * * 1: Values. An n-D tensor, where n >= 2, from which sub-tensors are
   *      extracted.
   *
   * Output:
   * * 0: A n-D tensor with the same rank and shape as the Values
   *      tensor, except for the first dimension which has the same size
   *      as Lookups' only dimension.
   */
  EMBEDDING_LOOKUP: 7,

  /** Computes element-wise floor() on the input tensor.
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   *
   * Supported tensor rank: up to 4
   *
   * Inputs:
   * * 0: A tensor.
   *
   * Outputs:
   * * 0: The output tensor, of the same type and dimensions as the input tensor.
   */
  FLOOR: 8,

  /** Denotes a fully (densely) connected layer, which connects all elements in the input
   * tensor with each element in the output tensor.
   *
   * This layer implements the operation:
   *
   *     outputs = activation(inputs * weights + bias)
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4.
   *
   * Inputs:
   * * 0: A tensor, specifying the input. If rank is greater than 2, then it gets flattened to
   *      a 2-D Tensor. The 2-D Tensor is handled as if dimensions corresponded to shape
   *      [batch_size, input_size], where batch_size corresponds to the batching dimension,
   *      and input_size is the size of the input.
   * * 1: A 2-D tensor, specifying the weights, of shape [num_units, input_size], where
   *      "num_units" corresponds to the number of output nodes.
   * * 2: A 1-D tensor, of shape [num_units], specifying the bias.
   *      For input tensor of {@link TENSOR_FLOAT32} type, the bias should
   *      also be of {@link TENSOR_FLOAT32}.
   *      For input tensor of {@link TENSOR_QUANT8_ASYMM} type, the bias
   *      should be of {@link TENSOR_INT32}, with zeroPoint of 0 and
   *      bias_scale == input_scale * filter_scale.
   * * 3: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Outputs:
   * * 0: The output tensor, of shape [batch_size, num_units].
   *      For output tensor of {@link TENSOR_QUANT8_ASYMM} type, the following
   *      condition must be satisfied: output_scale > input_scale * filter_scale.
   */
  FULLY_CONNECTED: 9,

  /** Looks up sub-tensors in the input tensor using a key-value map.
   *
   * This operator takes for input a tensor of values (Values),
   * a one-dimensional tensor of selection values (Lookups) and
   * a one-dimensional tensor that maps these values to Values
   * indexes. The output tensor is the concatenation of sub-tensors of
   * Values as selected by Lookups via Keys.
   *
   * Think of Values as being sliced along its outer-most dimension.
   * The output is a concatenation of selected slices, with one slice
   * for each entry of Lookups. The slice selected is the one at the
   * same index as the Maps entry that matches the value in Lookups.
   *
   * For a hit, the corresponding sub-tensor of Values is included
   * in the Output tensor.  For a miss, the corresponding sub-tensor in
   * Output will have zero values.
   *
   * For example, if Values has shape of [40, 200, 300],
   * Keys should have a shape of [40]. If Lookups tensor has shape
   * of [3], we're concatenating three slices, so the resulting tensor
   * will have the shape of [3, 200, 300]. If the first entry in
   * Lookups has the value 123456, we'll look for that value in Keys tensor.
   * If the sixth entry of Keys contains 123456, we'll select the sixth
   * slice of Values. If no entry in Keys has 123456, a slice of zeroes
   * will be concatenated.
   *
   * Inputs:
   * * 0: Lookups. A 1-D {@link TENSOR_INT32} tensor with shape [ k ].
   * * 1: Keys. A 1-D {@link TENSOR_INT32} tensor with shape [ n ];
   *      Keys and Values pair represent a map, i.e., the ith element
   *      in Keys (Keys[i]) is the key to select the ith sub-tensor
   *      in Values (Values[i]), where 0 <= i <= n-1.
   *      Keys tensor *MUST* be sorted in ascending order.
   * * 2: Values. A tensor with shape of [ n,  ]; i.e., the first dimension must be n.
   *
   * Outputs:
   * * 0: Output. A tensor with shape [ k ].
   * * 1: Hits. A boolean tensor with shape [ k ] indicates whether the lookup
   *      hits (True) or not (False).
   *      Stored as {@link TENSOR_QUANT8_ASYMM} with offset 0 and scale 1.0f.
   *      A non-zero byte represents True, a hit. A zero indicates otherwise.
   */
  HASHTABLE_LOOKUP: 10,

  /** Applies L2 normalization along the depth dimension.
   *
   * The values in the output tensor are computed as:
   *
   *     output[batch, row, col, channel] =
   *         input[batch, row, col, channel] /
   *         sqrt(sum_{c} pow(input[batch, row, col, c], 2))
   *
   * For input tensor with more dimensions, independently normalizes each 1-D slice along dimension dim.
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   *
   * Supported tensor rank: 4, with "NHWC" data layout (i.e., Num_samples, Height, Width, and Channels).
   *
   * Inputs:
   * * 0: A 4-D tensor, of shape [batches, height, width, depth].
   *
   * Outputs:
   * * 0: The output 4-D tensor, of shape [batches, out_height, out_width, depth].
   */
  L2_NORMALIZATION: 11,

  /** Performs an 2-D L2 pooling operation.
   *
   * The output dimensions are functions of the filter dimensions, stride, and padding.
   *
   * The values in the output tensor are computed as:
   *
   *     output[batch, row, col, channel] =
   *         sqrt(sum_{i, j} pow(input[batch, row + i, col + j, channel], 2) / sum(1))
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   *
   * Supported tensor rank: 4, with "NHWC" data layout.
   *
   * Both explicit padding and implicit padding are supported.
   *
   * Inputs (explicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth], specifying the input.
   * * 1: An INT32 value, specifying the padding on the left, in the width dimension.
   * * 2: An INT32 value, specifying the padding on the right,in the width dimension.
   * * 3: An INT32 value, specifying the padding on the top, in the height dimension.
   * * 4: An INT32 value, specifying the padding on the bottom, in the height dimension.
   * * 5: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 6: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 7: An INT32 value, specifying the filter width.
   * * 8: An INT32 value, specifying the filter height.
   * * 9: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Inputs (implicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth], specifying the input.
   * * 1: An INT32 value, specifying the implicit padding scheme, has to be one of the
   *      {@link PaddingCode} values.
   * * 2: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 3: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 4: An INT32 value, specifying the filter width.
   * * 5: An INT32 value, specifying the filter height.
   * * 6: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Outputs:
   * * 0: The output 4-D tensor, of shape [batches, out_height, out_width, depth].
   */
  L2_POOL_2D: 12,

  /** Applies Local Response Normalization along the depth dimension.
   *
   * The 4-D input tensor is treated as a 3-D array of 1-D vectors (along the last
   * dimension), and each vector is normalized independently. Within a given vector,
   * each component is divided by the weighted, squared sum of inputs within depth_radius.
   *
   * The output is calculated using this formula:
   *
   *     sqr_sum[a, b, c, d] =
   *         sum(pow(input[a, b, c, d - depth_radius : d + depth_radius + 1], 2)
   *     output = input / pow((bias + alpha * sqr_sum), beta)
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   *
   * Supported tensor rank: 4, with "NHWC" data layout.
   *
   * Inputs:
   * * 0: A 4-D tensor, of shape [batches, height, width, depth], specifying the input.
   * * 1: An INT32 value, specifying the radius of the normalization window.
   * * 2: A FLOAT32 value, specifying the bias, must not be zero.
   * * 3: A FLOAT32 value, specifying the scale factor, alpha.
   * * 4: A FLOAT32 value, specifying the exponent, beta.
   *
   * Outputs:
   * * 0: The output tensor of same shape as input0.
   */
  LOCAL_RESPONSE_NORMALIZATION: 13,

  /** Computes sigmoid activation on the input tensor element-wise.
   *
   * The output is calculated using this formula:
   *
   *     output = 1 / (1 + exp(-input))
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4.
   *
   * Inputs:
   * * 0: A tensor, specifying the input.
   *
   * Outputs:
   * * 0: The output tensor of same shape as input0.
   *      For {@link TENSOR_QUANT8_ASYMM} type,
   *      the scale must be 1.f / 256 and the zeroPoint must be 0.
   */
  LOGISTIC: 14,

  /**
   * Projects an input to a bit vector via locality senstive hashing.
   *
   * Inputs:
   * * 0: Hash functions. Dim.size == 2, DataType: Float.
   *            Tensor[0].Dim[0]: Number of hash functions.
   *            Tensor[0].Dim[1]: Number of seeds per hash functions.
   *            Tensor[0].Dim[1] <= 32 in sparse case.
   *
   * * 1: Input. Dim.size >= 1, no restriction on DataType.
   * * 2: Weight. Optional. Dim.size == 1, DataType: Float.
   *     If not set, each input element is considered to have the same weight of
   *     1.0.
   *     Tensor[1].Dim[0] == Tensor[2].Dim[0]
   * * 3: Type:
   *        Sparse: Value LSHProjectionType_SPARSE(=1).
   *          Computed bit vector is considered to be sparse.
   *          Each output element is an int32 made up of multiple bits computed from
   *          hash functions.
   *
   *        Dense: Value LSHProjectionType_DENSE(=2).
   *          Computed bit vector is considered to be dense. Each output element
   *          represents a bit and can take the value of either 0 or 1.
   *
   * Outputs:
   * * 0: If the projection type is sparse:
   *        Output.Dim == { Tensor[0].Dim[0] }
   *        A tensor of int32 that represents hash signatures.
   *      If the projection type is Dense:
   *        Output.Dim == { Tensor[0].Dim[0] * Tensor[0].Dim[1] }
   *        A flattened tensor that represents projected bit vectors.
   */
  LSH_PROJECTION: 15,

  /**
   * Long short-term memory unit (LSTM) recurrent network layer.
   *
   * The default non-peephole implementation is based on:
   * http://deeplearning.cs.cmu.edu/pdfs/Hochreiter97_lstm.pdf
   * S. Hochreiter and J. Schmidhuber. "Long Short-Term Memory". Neural
   * Computation, 9(8):1735-1780, 1997.
   *
   * The peephole implementation is based on:
   * https://research.google.com/pubs/archive/43905.pdf
   * Hasim Sak, Andrew Senior, and Francoise Beaufays. "Long short-term memory
   * recurrent neural network architectures for large scale acoustic modeling."
   * INTERSPEECH, 2014.
   *
   * The coupling of input and forget gate (CIFG) is based on:
   * http://arxiv.org/pdf/1503.04069.pdf
   * Greff et al. "LSTM: A Search Space Odyssey"
   *
   * The class has the following independently optional inputs:
   * * If input gate (if CIFG): input_to_forget_weights,
   *   recurrent_to_input_weights, cell_to_input_weights, input_gate_bias.
   * * If no peephole connections: cell_to_input_weights,
   *   cell_to_forget_weights, cell_to_output_weights.
   * * If no projection layer: projection_weights and projection_bias.
   * * If no projection bias: projection_bias.
   *
   * Supported tensor types (type T):
   * * {@link TENSOR_FLOAT32}
   *
   * Inputs:
   * * 0: Input.
   *      A 2-D tensor of type T, of shape [batch_size, input_size], where
   *      batch_size corresponds to the batching dimension, and input_size
   *      is the size of the input.
   * * 1: input_to_input_weights.
   *      A 2-D tensor of type T, of shape [num_units, input_size], where
   *      num_units corresponds to the number of cell units.
   * * 2: input_to_forget_weights.
   *      A 2-D tensor of type T, of shape [num_units, input_size].
   * * 3: input_to_cell_weights.
   *      A 2-D tensor of type T, of shape [num_units, input_size].
   * * 4: input_to_output_weights.
   *      A 2-D tensor of type T, of shape [num_units, input_size].
   * * 5: recurrent_to_input_weights.
   *      A 2-D tensor of type T, of shape [num_units, output_size], where
   *      output_size corresponds to either the number of cell units (i.e.,
   *      num_units), or the second dimension of the projection_weights, if
   *      defined.
   * * 6: recurrent_to_forget_weights.
   *      A 2-D tensor of type T, of shape [num_units, output_size].
   * * 7: recurrent_to_cell_weights.
   *      A 2-D tensor of type T, of shape [num_units, output_size].
   * * 8: recurrent_to_output_weights.
   *      A 2-D tensor of type T, of shape [num_units, output_size].
   * * 9: cell_to_input_weights.
   *      A 1-D tensor of type T, of shape [num_units].
   * * 10:cell_to_forget_weights.
   *      A 1-D tensor of type T, of shape [num_units].
   * * 11:cell_to_output_weights.
   *      A 1-D tensor of type T, of shape [num_units].
   * * 12:input_gate_bias.
   *      A 1-D tensor of type T, of shape [num_units].
   * * 13:forget_gate_bias.
   *      A 1-D tensor of type T, of shape [num_units].
   * * 14:cell_bias.
   *      A 1-D tensor of type T, of shape [num_units].
   * * 15:output_gate_bias.
   *      A 1-D tensor of type T, of shape [num_units].
   * * 16:projection_weights.
   *      A 2-D tensor of type T, of shape [output_size, num_units].
   * * 17:projection_bias.
   *      A 1-D tensor of type T, of shape [output_size].
   * * 18: output_state (in).
   *      A 2-D tensor of type T, of shape [batch_size, output_size].
   * * 19: cell_state (in).
   *      A 2-D tensor of type T, of shape [batch_size, num_units].
   * * 20:fused_activation_function.
   *      An optional {@link FuseCode} value indicating the activation
   *      function.
   *      If NONE is specified then it results in a linear activation.
   * * 21:cell_clip.
   *      A clipping threshold for the cell state, such that values are bound
   *      within [-cell_clip, cell_clip]. If set to 0.0 then clipping is
   *      disabled.
   * * 22:proj_clip.
   *      A clipping threshold for the output from the projection layer, such
   *      that values are bound within [-proj_clip, proj_clip]. If set to 0.0
   *      then clipping is disabled.
   *
   * Outputs:
   * * 0: scratch_buffer.
   *      A 3-D tensor of type T, of shape [batch_size, num_cell, 4].
   * * 1: output_state (out).
   *      A 2-D tensor of type T, of shape [batch_size, output_size].
   * * 2: cell_state (out).
   *      A 2-D tensor of type T, of shape [batch_size, num_units].
   * * 3: output.
   *      A 2-D tensor of type T, of shape [batch_size, output_size]. This is
   *      effectively the same as the current output_state value.
   */
  LSTM: 16,

  /** Performs an 2-D max pooling operation.
   *
   * The output dimensions are functions of the filter dimensions, stride, and padding.
   *
   * The values in the output tensor are computed as:
   *
   *     output[batch, row, col, channel] =
   *         max_{i, j} (input[batch, row + i, col + j, channel])
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: 4, with "NHWC" data layout.
   *
   * Both explicit padding and implicit padding are supported.
   *
   * Inputs (explicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth], specifying the input.
   * * 1: An INT32 value, specifying the padding on the left, in the width dimension.
   * * 2: An INT32 value, specifying the padding on the right,in the width dimension.
   * * 3: An INT32 value, specifying the padding on the top, in the height dimension.
   * * 4: An INT32 value, specifying the padding on the bottom, in the height dimension.
   * * 5: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 6: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 7: An INT32 value, specifying the filter width.
   * * 8: An INT32 value, specifying the filter height.
   * * 9: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Inputs (implicit padding):
   * * 0: A 4-D tensor, of shape [batches, height, width, depth], specifying the input.
   * * 1: An INT32 value, specifying the implicit padding scheme, has to be one of the
   *      {@link PaddingCode} values.
   * * 2: An INT32 value, specifying the stride when walking through input
   *      in the width dimension.
   * * 3: An INT32 value, specifying the stride when walking through input
   *      in the height dimension.
   * * 4: An INT32 value, specifying the filter width.
   * * 5: An INT32 value, specifying the filter height.
   * * 6: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Outputs:
   * * 0: The output 4-D tensor, of shape [batches, out_height, out_width, depth].
   */
  MAX_POOL_2D: 17,

  /** Multiplies two tensors, element-wise.
   *
   * Takes two input tensors of identical type and compatible dimensions. The output
   * is the product of both input tensors, optionally modified by an activation function.
   *
   * Two dimensions are compatible when:
   *     1. they are equal, or
   *     2. one of them is 1
   *
   * The size of the resulting output is the maximum size along each dimension of the
   * input operands. It starts with the trailing dimensions, and works its way forward.
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4
   *
   * Inputs:
   * * 0: A tensor.
   * * 1: A tensor of the same type, and compatible dimensions as input0.
   * * 2: An INT32 value, and has to be one of the {@link FuseCode} values.
   *      Specifies the activation to invoke on the result of each addition.
   *
   * Outputs:
   * * 0: The product, a tensor of the same type as input0.
   *      For output tensor of {@link TENSOR_QUANT8_ASYMM} type, the following
   *      condition must be satisfied: output_scale > input1_scale * input2_scale.
   */
  MUL: 18,

  /** Computes rectified linear activation on the input tensor element-wise.
   *
   * The output is calculated using this formula:
   *
   *     output = max(0, input)
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4.
   *
   * Inputs:
   * * 0: A tensor, specifying the input.
   *
   * Outputs:
   * * 0: The output tensor of same shape as input0.
   */
  RELU: 19,

  /** Computes rectified linear 1 activation on the input tensor element-wise.
   *
   * The output is calculated using this formula:
   *
   *     output = min(1.f, max(-1.f, input))
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4.
   *
   * Inputs:
   * * 0: A tensor, specifying the input.
   *
   * Outputs:
   * * 0: The output tensor of same shape as input0.
   */
  RELU1: 20,

  /** Computes rectified linear 6 activation on the input tensor element-wise.
   *
   * The output is calculated using this formula:
   *
   *     output = min(6, max(0, input))
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4.
   *
   * Inputs:
   * * 0: A tensor, specifying the input.
   *
   * Outputs:
   * * 0: The output tensor of same shape as input0.
   */
  RELU6: 21,

  /** Reshapes a tensor.
   *
   * Given tensor, this operation returns a tensor that has the same values as tensor,
   * but with a newly specified shape.
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: up to 4.
   *
   * Inputs:
   * * 0: A tensor, specifying the tensor to be reshaped.
   * * 1: A 1-D tensor of type {@link TENSOR_INT32}, defining the shape
   *      of the output tensor. The number of elements implied by shape must be the same
   *      as the number of elements in the input tensor.
   *
   * Outputs:
   * * 0: The output tensor, of shape specified by the input shape.
   */
  RESHAPE: 22,

  /** Resizes images to given size using the bilinear interpretation.
   *
   * Resized images will be distorted if their output aspect ratio is not the same as
   * input aspect ratio.
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   *
   * Supported tensor rank: 4, with "NHWC" data layout.
   *
   * Inputs:
   * * 0: A 4-D tensor, of shape [batches, height, width, depth], specifying the input.
   * * 1: An INT32 value, specifying the output height of the output tensor.
   * * 2: An INT32 value, specifying the output width of the output tensor.
   *
   * Outputs:
   * * 0: The output 4-D tensor, of shape [batches, new_height, new_width, depth].
   */
  RESIZE_BILINEAR: 23,

  /**
   * A basic recurrent neural network layer.
   *
   * This layer implements the operation:
   * outputs = state = activation(inputs * input_weights + state * recurrent_weights + bias)
   *
   * Where:
   * * input_weights is a weight matrix that multiplies the inputs;
   * * recurrent_weights is a weight matrix that multiplies the current
   *    state which itself is the output from the previous time step
   *    computation;
   * * bias is a bias vector (added to each output vector in the batch);
   * * activation is the function passed as the fused_activation_function
   *   argument (if not NONE).
   *
   * Supported tensor types (Type T):
   * * {@link TENSOR_FLOAT32}
   *
   * Inputs:
   * * 0: input.
   *      A 2-D tensor of type T, of shape [batch_size, input_size], where
   *      batch_size corresponds to the batching dimension, and input_size is
   *      the size of the input.
   * * 1: weights.
   *      A 2-D tensor of type T, of shape [num_units, input_size], where
   *      num_units corresponds to the number of units.
   * * 2: recurrent_weights.
   *      A 2-D tensor of type T, of shape [num_units, num_units], with columns
   *      corresponding to the weights from each unit.
   * * 3: bias.
   *      A 1-D tensor of type T, of shape [num_units].
   * * 4: hidden state (in).
   *      A 2-D tensor of type T, of shape [batch_size, num_units].
   * * 5: fused_activation_function.
   *      An optional {@link FuseCode} value indicating the activation
   *      function. If NONE is specified then it results in a linear
   *      activation.
   *
   * Outputs:
   * * 0: hidden state (out).
   *      A 2-D tensor of type T, of shape [batch_size, num_units].
   *
   * * 1: output.
   *      A 2-D tensor of type T, of shape [batch_size, num_units]. This is
   *      effectively the same as the current state value.
   */
  RNN: 24,

  /** Computes the softmax activation on the input tensor element-wise, per batch, by
   * normalizing the input vector so the maximum coefficient is zero.
   *
   * The output is calculated using this formula:
   *
   *     output[batch, i] =
   *         exp((input[batch, i] - max(input[batch, :])) * beta) /
   *         sum_{k}{exp((input[batch, k] - max(input[batch, :])) * beta)}
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: 2 or 4.
   *
   * Inputs:
   * * 0: A 2-D or 4-D tensor, specifying the tensor to be reshaped.
   * * 1: A FLOAT32 value, specifying the positive scaling factor for the exponent, beta.
   *
   * Outputs:
   * * 0: The output tensor of same shape as input0.
   *      For {@link TENSOR_QUANT8_ASYMM} type,
   *      the scale must be 1.f / 256 and the zeroPoint must be 0.
   */
  SOFTMAX: 25,

  /** Rearranges blocks of spatial data, into depth.
   *
   * More specifically, this op outputs a copy of the input tensor where values from
   * the height and width dimensions are moved to the depth dimension.
   * The value block_size indicates the input block size and how the data is moved.
   *
   * Chunks of data of size block_size * block_size from depth are rearranged into
   * non-overlapping blocks of size block_size x block_size.
   *
   * The depth of the output tensor is input_depth * block_size * block_size.
   * The input tensor's height and width must be divisible by block_size.
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   * * {@link TENSOR_QUANT8_ASYMM}
   *
   * Supported tensor rank: 4, with "NHWC" data layout.
   *
   * Inputs:
   * * 0: A 4-D tensor, of shape [batches, height, width, depth_in], specifying the input.
   * * 1: An INT32 value, specifying the block_size. block_size must be >=1 and
   *      block_size must be a divisor of both the input height and width.
   *
   * Outputs:
   * * 0: The output 4-D tensor, of shape [batch, height/block_size, width/block_size,
   *      depth*block_size*block_size].
   */
  SPACE_TO_DEPTH: 26,

  /**
   * SVDF op is a kind of stateful layer derived from the notion that a
   * densely connected layer that's processing a sequence of input frames can
   * be approximated by using a singular value decomposition of each of its
   * nodes. The implementation is based on:
   *
   * https://research.google.com/pubs/archive/43813.pdf
   *
   * P. Nakkiran, R. Alvarez, R. Prabhavalkar, C. Parada.
   * Compressing Deep Neural Networks using a Rank-Constrained Topology.
   * INTERSPEECH, 2015.
   *
   * It processes the incoming input using a 2-stage filtering mechanism:
   * * stage 1 performs filtering on the "features" dimension, whose outputs get
   *   pushed into a memory of fixed-size memory_size.
   * * stage 2 performs filtering on the "time" dimension of the memory_size
   *   memoized outputs of stage 1.
   *
   * Specifically, for rank 1, this layer implements the operation:
   *
   *    memory = push(conv1d(inputs, weights_feature, feature_dim,
   *                  "PADDING_VALID"));
   *    outputs = activation(memory * weights_time + bias);
   *
   * Where:
   * * weights_feature is a weights matrix that processes the inputs (by
   *   convolving the input with every feature filter), and whose outputs get
   *   pushed, stacked in order, into the fixed-size memory (the oldest entry
   *   gets dropped);
   * * weights_time is a weights matrix that processes the memory (by a
   *   batched matrix multiplication on the num_units);
   * * bias is an optional bias vector (added to each output vector in the
   *   batch); and
   * * activation is the function passed as the fused_activation_function
   *   argument (if not NONE).
   *
   * Each rank adds a dimension to the weights matrices by means of stacking
   * the filters.
   *
   * Supported tensor types (type T):
   * * {@link TENSOR_FLOAT32}
   *
   * Inputs:
   * * 0: input.
   *      A 2-D tensor of type T, of shape [batch_size, input_size], where
   *      batch_size corresponds to the batching dimension, and input_size is
   *      the size of the input.
   * * 1: weights_feature.
   *      A 2-D tensor of type T, of shape [num_units, input_size], where
   *      num_units corresponds to the number of units.
   * * 2: weights_time.
   *      A 2-D tensor of type T, of shape [num_units, memory_size], where
   *      memory_size corresponds to the fixed-size of the memory.
   * * 3: bias.
   *      An optional 1-D tensor of type T, of shape [num_units].
   * * 4: state (in).
   *      A 2-D tensor of type T, of shape [batch_size, (memory_size - 1) * num_units * rank].
   * * 5: rank.
   *      The rank of the SVD approximation.
   * * 6: fused_activation_function.
   *      An optional {@link FuseCode} value indicating the activation function.
   *      If NONE is specified then it results in a linear activation.
   *
   * Outputs:
   * * 0: state (out).
   *      A 2-D tensor of type T, of shape [batch_size, (memory_size - 1) * num_units * rank].
   * * 1: output.
   *      A 2-D tensor of type T, of shape [batch_size, num_units].
   */
  SVDF: 27,

  /** Computes hyperbolic tangent of input tensor element-wise.
   *
   * The output is calculated using this formula:
   *
   *     output = tanh(input)
   *
   * Supported tensor types:
   * * {@link TENSOR_FLOAT32}
   *
   * Supported tensor rank: up to 4.
   *
   * Inputs:
   * * 0: A tensor, specifying the input.
   *
   * Outputs:
   * * 0: The output tensor of same shape as input0.
   */
  TANH: 28
};

var ResultCode = exports.ResultCode = {
  NO_ERROR: 0,
  OUT_OF_MEMORY: 1,
  INCOMPLETE: 2,
  UNEXPECTED_NULL: 3,
  BAD_DATA: 4,
  OP_FAILED: 5,
  UNMAPPABLE: 5,
  BAD_STATE: 6
};

var OperandLifetime = exports.OperandLifetime = {
  TEMPORARY_VARIABLE: 0,
  MODEL_INPUT: 1,
  MODEL_OUTPUT: 2,
  CONSTANT_COPY: 3,
  CONSTANT_REFERENCE: 4,
  NO_VALUE: 5
};

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(106);
var enumBugKeys = __webpack_require__(78);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(27);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(1);
var dPs = __webpack_require__(107);
var enumBugKeys = __webpack_require__(78);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(75)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(79).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(106);
var hiddenKeys = __webpack_require__(78).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var dP = __webpack_require__(7);
var DESCRIPTORS = __webpack_require__(6);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(22);
var call = __webpack_require__(118);
var isArrayIter = __webpack_require__(91);
var anObject = __webpack_require__(1);
var toLength = __webpack_require__(8);
var getIterFn = __webpack_require__(93);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(15);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(7).f;
var has = __webpack_require__(17);
var TAG = __webpack_require__(5)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var defined = __webpack_require__(26);
var fails = __webpack_require__(3);
var spaces = __webpack_require__(81);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(23);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 53 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(23);
var TAG = __webpack_require__(5)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.softmax = exports.fuse = exports.RELU6 = exports.RELU1 = exports.RELU = undefined;

var _RELU = __webpack_require__(381);

var _RELU2 = __webpack_require__(382);

var _RELU3 = __webpack_require__(383);

var _fuse = __webpack_require__(56);

var _softmax = __webpack_require__(384);

var _softmax2 = _interopRequireDefault(_softmax);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.RELU = _RELU.RELU;
exports.RELU1 = _RELU2.RELU1;
exports.RELU6 = _RELU3.RELU6;
exports.fuse = _fuse.fuse;
exports.softmax = _softmax2.default;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var fuseShaderSource = exports.fuseShaderSource = {
    "RELU": 'sum = max(sum, 0.0);',
    "RELU1": 'sum = min(max(sum, -1.0), 1.0);',
    "RELU6": 'sum = min(max(sum, 0.0), 6.0);',
    "NONE": ''
};

/***/ }),
/* 57 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(21);
var global = __webpack_require__(2);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(33) ? 'pure' : 'global',
  copyright: ' 2018 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(18);
var toLength = __webpack_require__(8);
var toAbsoluteIndex = __webpack_require__(41);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 60 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(23);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(4);
var cof = __webpack_require__(23);
var MATCH = __webpack_require__(5)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(5)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(1);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(14);
var redefine = __webpack_require__(15);
var fails = __webpack_require__(3);
var defined = __webpack_require__(26);
var wks = __webpack_require__(5);

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(10);
var SPECIES = __webpack_require__(5)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(15);
var redefineAll = __webpack_require__(47);
var meta = __webpack_require__(32);
var forOf = __webpack_require__(46);
var anInstance = __webpack_require__(45);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var $iterDetect = __webpack_require__(63);
var setToStringTag = __webpack_require__(48);
var inheritIfRequired = __webpack_require__(82);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var hide = __webpack_require__(14);
var uid = __webpack_require__(39);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// Forced replacement prototype accessors methods
module.exports = __webpack_require__(33) || !__webpack_require__(3)(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete __webpack_require__(2)[K];
});


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var ctx = __webpack_require__(22);
var forOf = __webpack_require__(46);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var iota = __webpack_require__(375)
var isBuffer = __webpack_require__(376)

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor


/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operandCodeToTypedArrayMap = undefined;
exports.isTensor = isTensor;
exports.sizeOfTensorData = sizeOfTensorData;
exports.sizeOfScalarData = sizeOfScalarData;
exports.product = product;
exports.validateEnum = validateEnum;

var _Enums = __webpack_require__(37);

var operandCodeToTypedArrayMap = exports.operandCodeToTypedArrayMap = new Map([[_Enums.OperandCode.FLOAT32, Float32Array], [_Enums.OperandCode.INT32, Int32Array], [_Enums.OperandCode.UINT32, Uint32Array], [_Enums.OperandCode.TENSOR_FLOAT32, Float32Array], [_Enums.OperandCode.TENSOR_INT32, Int32Array], [_Enums.OperandCode.TENSOR_QUANT8_ASYMM, Int8Array]]);

function isTensor(type) {
  if (type === _Enums.OperandCode.TENSOR_FLOAT32 || type === _Enums.OperandCode.TENSOR_INT32 || type === _Enums.OperandCode.TENSOR_QUANT8_ASYMM) {
    return true;
  } else {
    return false;
  }
}

function sizeOfTensorData(type, dims) {
  return operandCodeToTypedArrayMap.get(type).BYTES_PER_ELEMENT * product(dims);
}

function sizeOfScalarData(type) {
  return operandCodeToTypedArrayMap.get(type).BYTES_PER_ELEMENT * 1;
}

function product(array) {
  return array.reduce(function (accumulator, currentValue) {
    return accumulator * currentValue;
  });
}

function validateEnum(enumValue, enumType) {
  for (var k in enumType) {
    if (enumValue === enumType[k]) {
      return true;
    }
  }
  return false;
}

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var document = __webpack_require__(2).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var core = __webpack_require__(21);
var LIBRARY = __webpack_require__(33);
var wksExt = __webpack_require__(105);
var defineProperty = __webpack_require__(7).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(58)('keys');
var uid = __webpack_require__(39);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 78 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(2).document;
module.exports = document && document.documentElement;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(22)(Function.call, __webpack_require__(19).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 81 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var setPrototypeOf = __webpack_require__(80).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(27);
var defined = __webpack_require__(26);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 84 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 85 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(27);
var defined = __webpack_require__(26);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(33);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(15);
var hide = __webpack_require__(14);
var Iterators = __webpack_require__(50);
var $iterCreate = __webpack_require__(88);
var setToStringTag = __webpack_require__(48);
var getPrototypeOf = __webpack_require__(20);
var ITERATOR = __webpack_require__(5)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(42);
var descriptor = __webpack_require__(38);
var setToStringTag = __webpack_require__(48);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(14)(IteratorPrototype, __webpack_require__(5)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(62);
var defined = __webpack_require__(26);

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(5)('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(50);
var ITERATOR = __webpack_require__(5)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(7);
var createDesc = __webpack_require__(38);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(54);
var ITERATOR = __webpack_require__(5)('iterator');
var Iterators = __webpack_require__(50);
module.exports = __webpack_require__(21).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(262);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(9);
var toAbsoluteIndex = __webpack_require__(41);
var toLength = __webpack_require__(8);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(34);
var step = __webpack_require__(121);
var Iterators = __webpack_require__(50);
var toIObject = __webpack_require__(18);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(87)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(22);
var invoke = __webpack_require__(111);
var html = __webpack_require__(79);
var cel = __webpack_require__(75);
var global = __webpack_require__(2);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(23)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var macrotask = __webpack_require__(97).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(23)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(10);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var DESCRIPTORS = __webpack_require__(6);
var LIBRARY = __webpack_require__(33);
var $typed = __webpack_require__(69);
var hide = __webpack_require__(14);
var redefineAll = __webpack_require__(47);
var fails = __webpack_require__(3);
var anInstance = __webpack_require__(45);
var toInteger = __webpack_require__(27);
var toLength = __webpack_require__(8);
var toIndex = __webpack_require__(130);
var gOPN = __webpack_require__(43).f;
var dP = __webpack_require__(7).f;
var arrayFill = __webpack_require__(95);
var setToStringTag = __webpack_require__(48);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Enums = __webpack_require__(37);

var _Device = __webpack_require__(160);

var _Device2 = _interopRequireDefault(_Device);

var _utils = __webpack_require__(74);

var utils = _interopRequireWildcard(_utils);

var _Execution = __webpack_require__(138);

var _Execution2 = _interopRequireDefault(_Execution);

var _Model = __webpack_require__(139);

var _Model2 = _interopRequireDefault(_Model);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Compilation = function () {
  /**
   * Create a Compilation to compile the given model.
   * 
   * @param {Model} model - The model to be compiled.
   */
  function Compilation(model) {
    _classCallCheck(this, Compilation);

    this._model = model;
    this._finished = false;
    this._preference = _Enums.PreferenceCode.fast_single_answer;
    this._device = new _Device2.default();
    this._preparedModel = null;
    this._useWebGL2 = model._useWebGL2;
  }

  /**
   * Create a executino from compilation.
   * 
   * @returns {Execution} - the execution object.
   */


  _createClass(Compilation, [{
    key: 'createExecution',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._finished) {
                  _context.next = 2;
                  break;
                }

                throw new Error('Compilation is not finished');

              case 2:
                return _context.abrupt('return', new _Execution2.default(this));

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createExecution() {
        return _ref.apply(this, arguments);
      }

      return createExecution;
    }()

    /**
     * Sets the execution preference.
     * 
     * @param {number} preference - The execution preference, e.g. PreferenceCode.LOW_POWER.
     */

  }, {
    key: 'setPreference',
    value: function setPreference(preference) {
      if (this._finished) {
        throw new Error('setPreference cant modify after compilation finished');
      }
      if (!utils.validateEnum(preference, _Enums.PreferenceCode)) {
        throw new Error('Invalid preference value ' + preference);
      }
      this._preference = preference;
      return _Enums.ResultCode.NO_ERROR;
    }

    /**
     * Indicate that we have finished modifying a compilation.
     */

  }, {
    key: 'finish',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._useWebGL2) {
                  _context2.next = 6;
                  break;
                }

                this._preparedModel = new _Model2.default(this._model);
                _context2.next = 4;
                return this._preparedModel.prepareModel();

              case 4:
                _context2.next = 9;
                break;

              case 6:
                _context2.next = 8;
                return this._device.prepareModel(this._model);

              case 8:
                this._preparedModel = _context2.sent;

              case 9:
                this._finished = true;
                return _context2.abrupt('return', _Enums.ResultCode.NO_ERROR);

              case 11:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function finish() {
        return _ref2.apply(this, arguments);
      }

      return finish;
    }()
  }]);

  return Compilation;
}();

exports.default = Compilation;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NNOps = __webpack_require__(161);

var _NNOps2 = _interopRequireDefault(_NNOps);

var _Enums = __webpack_require__(37);

var _utils = __webpack_require__(74);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PreparedModel = function () {
  function PreparedModel() {
    _classCallCheck(this, PreparedModel);

    this._operations = [];
    this._operands = [];
    this._prepared = false;
    this._nn_ops = null;
    this._model;
  }

  /**
   * Prepare for model execution.
   * 
   * @param {Object} model - A model object built by user.
   */


  _createClass(PreparedModel, [{
    key: 'prepare',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(model) {
        var i, operand, runtimeOperand;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._model = model;
                _context.next = 3;
                return (0, _NNOps2.default)();

              case 3:
                this._nn_ops = _context.sent;

                this._operations = model._operations;
                for (i = 0; i < model._operands.length; ++i) {
                  operand = model._operands[i];
                  runtimeOperand = {};

                  runtimeOperand.type = operand.type;
                  if (utils.isTensor(operand.type)) {
                    runtimeOperand.value = this._allocateTensor(operand);
                    runtimeOperand.shape = this._allocateShape(operand);
                  } else {
                    runtimeOperand.value = operand.value;
                  }
                  this._operands.push(runtimeOperand);
                }
                this._prepared = true;

              case 7:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function prepare(_x) {
        return _ref.apply(this, arguments);
      }

      return prepare;
    }()

    /**
     * Launches an asynchronous execution on a prepared model.
     * 
     * @param {Array} inputs - Inputs provided by user.
     * @param {Array} outputs - Outputs will receive results.
     */

  }, {
    key: 'execute',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(inputs, outputs) {
        var _this = this;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (this._prepared) {
                  _context2.next = 2;
                  break;
                }

                throw new Error('Model is not prepared');

              case 2:

                inputs.forEach(function (input) {
                  var operand = _this._operands[input.index];
                  var buffer = input.buffer;
                  _this._setTensorData(operand.type, operand.value, buffer);
                });

                this._operations.forEach(function (operation) {
                  _this._executeOperation(operation);
                });

                outputs.forEach(function (output) {
                  var operand = _this._operands[output.index];
                  var buffer = output.buffer;
                  _this._getTensorData(operand.type, operand.value, buffer);
                });

              case 5:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function execute(_x2, _x3) {
        return _ref2.apply(this, arguments);
      }

      return execute;
    }()
  }, {
    key: '_executeOperation',
    value: function _executeOperation(operation) {
      var nn_ops = this._nn_ops;
      var op = operation.type;
      var inputs = operation.inputs;
      var outputs = operation.outputs;
      var operands = this._operands;
      var success = void 0;

      function allParametersPresent(requiredIns, requiredOuts) {
        function verify(requiredCount, indexes, type) {
          var actualCount = indexes.length;
          if (requiredCount !== actualCount) {
            throw new Error('Operation ' + op + ' requires ' + requiredCount + ' ' + type + ' operands, but got ' + actualCount + '.');
          }
          indexes.forEach(function (index) {
            if (operands[index].value === null || operands[index].lifetime === _Enums.OperandLifetime.NO_VALUE) {
              throw new Error('Operation ' + op + ' ' + type + ' operand ' + index + ' is required but missing.');
            }
          });
        }
        verify(requiredIns, inputs, 'in');
        verify(requiredOuts, outputs, 'out');
      }

      var FuseCodeMap = new Map([[_Enums.FuseCode.NONE, nn_ops.NONE], [_Enums.FuseCode.RELU, nn_ops.RELU], [_Enums.FuseCode.RELU1, nn_ops.RELU1], [_Enums.FuseCode.RELU6, nn_ops.RELU6]]);

      function calculateExplicitPadding(inSize, stride, filterSize, paddingCode) {
        var paddingHead = 0;
        var paddingTail = 0;

        if (paddingCode == _Enums.PaddingCode.SAME) {
          var outSize = Math.floor((inSize + stride - 1) / stride);
          var tmp = Math.floor((outSize - 1) * stride + filterSize);
          if (tmp > inSize) {
            paddingHead = Math.floor((tmp - inSize) / 2);
            paddingTail = Math.floor(tmp - inSize - paddingHead);
          }
        }

        return [paddingHead, paddingTail];
      }

      switch (op) {
        case _Enums.OperationCode.ADD:
          {
            allParametersPresent(3, 1);
            var in1 = operands[inputs[0]];
            var in2 = operands[inputs[1]];
            var activation = FuseCodeMap.get(operands[inputs[2]].value[0]);
            var out = operands[outputs[0]];
            success = nn_ops.addMulPrepare(in1.shape, in2.shape, out.shape);
            if (!success) {
              throw new Error('addMulPrepare fails');
            }
            success = nn_ops.addFloat32(in1.value, in1.shape, in2.value, in2.shape, activation, out.value, out.shape);
            if (!success) {
              throw new Error('addFloat32 fails');
            }
          }break;
        case _Enums.OperationCode.MUL:
          {
            allParametersPresent(3, 1);
            var _in = operands[inputs[0]];
            var _in2 = operands[inputs[1]];
            var _activation = FuseCodeMap.get(operands[inputs[2]].value[0]);
            var _out = operands[outputs[0]];
            success = nn_ops.addMulPrepare(_in.shape, _in2.shape, _out.shape);
            if (!success) {
              throw new Error('addMulPrepare fails');
            }
            success = nn_ops.mulFloat32(_in.value, _in.shape, _in2.value, _in2.shape, _activation, _out.value, _out.shape);
            if (!success) {
              throw new Error('mulFloat32 fails');
            }
          }break;
        case _Enums.OperationCode.CONV_2D:
          {
            var inCount = inputs.length;
            if (inCount !== 7 && inCount !== 10) {
              throw new Error('Invalid parameters number of CONV_2D');
            }
            allParametersPresent(inCount, 1);
            var i = 0;
            var input = operands[inputs[i++]];
            var filter = operands[inputs[i++]];
            var bias = operands[inputs[i++]];
            var paddingLeft = void 0,
                paddingRight = void 0;
            var paddingTop = void 0,
                paddingBottom = void 0;
            var strideWidth = void 0,
                strideHeight = void 0;
            var _activation2 = void 0;
            if (inCount === 10) {
              paddingLeft = operands[inputs[i++]].value[0];
              paddingRight = operands[inputs[i++]].value[0];
              paddingTop = operands[inputs[i++]].value[0];
              paddingBottom = operands[inputs[i++]].value[0];
              strideWidth = operands[inputs[i++]].value[0];
              strideHeight = operands[inputs[i++]].value[0];
              _activation2 = FuseCodeMap.get(operands[inputs[i++]].value[0]);
            } else {
              var paddingCode = operands[inputs[i++]].value[0];
              strideWidth = operands[inputs[i++]].value[0];
              strideHeight = operands[inputs[i++]].value[0];
              _activation2 = FuseCodeMap.get(operands[inputs[i++]].value[0]);

              var inputWidth = input.shape.dimensions[2];
              var inputHeight = input.shape.dimensions[1];
              var filterWidth = filter.shape.dimensions[2];
              var filterHeight = filter.shape.dimensions[1];

              var _calculateExplicitPad = calculateExplicitPadding(inputWidth, strideWidth, filterWidth, paddingCode);

              var _calculateExplicitPad2 = _slicedToArray(_calculateExplicitPad, 2);

              paddingLeft = _calculateExplicitPad2[0];
              paddingRight = _calculateExplicitPad2[1];

              var _calculateExplicitPad3 = calculateExplicitPadding(inputHeight, strideHeight, filterHeight, paddingCode);

              var _calculateExplicitPad4 = _slicedToArray(_calculateExplicitPad3, 2);

              paddingTop = _calculateExplicitPad4[0];
              paddingBottom = _calculateExplicitPad4[1];
            }
            var output = operands[outputs[0]];
            success = nn_ops.convPrepare(input.shape, filter.shape, bias.shape, paddingLeft, paddingRight, paddingTop, paddingBottom, strideWidth, strideHeight, output.shape);
            if (!success) {
              throw new Error('convPrepare fails');
            }
            success = nn_ops.convFloat32(input.value, input.shape, filter.value, filter.shape, bias.value, bias.shape, paddingLeft, paddingRight, paddingTop, paddingBottom, strideWidth, strideHeight, _activation2, output.value, output.shape);
            if (!success) {
              throw new Error('convFloat32 fails');
            }
          }break;
        case _Enums.OperationCode.DEPTHWISE_CONV_2D:
          {
            var _inCount = inputs.length;
            if (_inCount !== 8 && _inCount !== 11) {
              throw new Error('Invalid parameters number of DEPTHWISE_CONV_2D');
            }
            allParametersPresent(_inCount, 1);
            var _i = 0;
            var _input = operands[inputs[_i++]];
            var _filter = operands[inputs[_i++]];
            var _bias = operands[inputs[_i++]];
            var _paddingLeft = void 0,
                _paddingRight = void 0;
            var _paddingTop = void 0,
                _paddingBottom = void 0;
            var _strideWidth = void 0,
                _strideHeight = void 0;
            var depthMultipler = void 0;
            var _activation3 = void 0;
            if (_inCount === 11) {
              _paddingLeft = operands[inputs[_i++]].value[0];
              _paddingRight = operands[inputs[_i++]].value[0];
              _paddingTop = operands[inputs[_i++]].value[0];
              _paddingBottom = operands[inputs[_i++]].value[0];
              _strideWidth = operands[inputs[_i++]].value[0];
              _strideHeight = operands[inputs[_i++]].value[0];
              depthMultipler = operands[inputs[_i++]].value[0];
              _activation3 = FuseCodeMap.get(operands[inputs[_i++]].value[0]);
            } else {
              var _paddingCode = operands[inputs[_i++]].value[0];
              _strideWidth = operands[inputs[_i++]].value[0];
              _strideHeight = operands[inputs[_i++]].value[0];
              depthMultipler = operands[inputs[_i++]].value[0];
              _activation3 = FuseCodeMap.get(operands[inputs[_i++]].value[0]);

              var _inputWidth = _input.shape.dimensions[2];
              var _inputHeight = _input.shape.dimensions[1];
              var _filterWidth = _filter.shape.dimensions[2];
              var _filterHeight = _filter.shape.dimensions[1];

              var _calculateExplicitPad5 = calculateExplicitPadding(_inputWidth, _strideWidth, _filterWidth, _paddingCode);

              var _calculateExplicitPad6 = _slicedToArray(_calculateExplicitPad5, 2);

              _paddingLeft = _calculateExplicitPad6[0];
              _paddingRight = _calculateExplicitPad6[1];

              var _calculateExplicitPad7 = calculateExplicitPadding(_inputHeight, _strideHeight, _filterHeight, _paddingCode);

              var _calculateExplicitPad8 = _slicedToArray(_calculateExplicitPad7, 2);

              _paddingTop = _calculateExplicitPad8[0];
              _paddingBottom = _calculateExplicitPad8[1];
            }
            var _output = operands[outputs[0]];
            success = nn_ops.depthwiseConvPrepare(_input.shape, _filter.shape, _bias.shape, _paddingLeft, _paddingRight, _paddingTop, _paddingBottom, _strideWidth, _strideHeight, _output.shape);
            if (!success) {
              throw new Error('depthwiseConvPrepare fails');
            }
            success = nn_ops.depthwiseConvFloat32(_input.value, _input.shape, _filter.value, _filter.shape, _bias.value, _bias.shape, _paddingLeft, _paddingRight, _paddingTop, _paddingBottom, _strideWidth, _strideHeight, depthMultipler, _activation3, _output.value, _output.shape);
            if (!success) {
              throw new Error('depthwiseConvFloat32 fails');
            }
          }break;
        case _Enums.OperationCode.AVERAGE_POOL_2D:
        case _Enums.OperationCode.MAX_POOL_2D:
          {
            var _inCount2 = inputs.length;
            if (_inCount2 !== 7 && _inCount2 !== 10) {
              throw new Error('Invalid parameters number of Pooling ' + op);
            }
            allParametersPresent(_inCount2, 1);
            var _i2 = 0;
            var _input2 = operands[inputs[_i2++]];
            var _paddingLeft2 = void 0,
                _paddingRight2 = void 0;
            var _paddingTop2 = void 0,
                _paddingBottom2 = void 0;
            var _strideWidth2 = void 0,
                _strideHeight2 = void 0;
            var _filterWidth2 = void 0,
                _filterHeight2 = void 0;
            var _activation4 = void 0;
            if (_inCount2 === 10) {
              _paddingLeft2 = operands[inputs[_i2++]].value[0];
              _paddingRight2 = operands[inputs[_i2++]].value[0];
              _paddingTop2 = operands[inputs[_i2++]].value[0];
              _paddingBottom2 = operands[inputs[_i2++]].value[0];
              _strideWidth2 = operands[inputs[_i2++]].value[0];
              _strideHeight2 = operands[inputs[_i2++]].value[0];
              _filterWidth2 = operands[inputs[_i2++]].value[0];
              _filterHeight2 = operands[inputs[_i2++]].value[0];
              _activation4 = FuseCodeMap.get(operands[inputs[_i2++]].value[0]);
            } else {
              var _paddingCode2 = operands[inputs[_i2++]].value[0];
              _strideWidth2 = operands[inputs[_i2++]].value[0];
              _strideHeight2 = operands[inputs[_i2++]].value[0];
              _filterWidth2 = operands[inputs[_i2++]].value[0];
              _filterHeight2 = operands[inputs[_i2++]].value[0];
              _activation4 = FuseCodeMap.get(operands[inputs[_i2++]].value[0]);

              var _inputWidth2 = _input2.shape.dimensions[2];
              var _inputHeight2 = _input2.shape.dimensions[1];

              var _calculateExplicitPad9 = calculateExplicitPadding(_inputWidth2, _strideWidth2, _filterWidth2, _paddingCode2);

              var _calculateExplicitPad10 = _slicedToArray(_calculateExplicitPad9, 2);

              _paddingLeft2 = _calculateExplicitPad10[0];
              _paddingRight2 = _calculateExplicitPad10[1];

              var _calculateExplicitPad11 = calculateExplicitPadding(_inputHeight2, _strideHeight2, _filterHeight2, _paddingCode2);

              var _calculateExplicitPad12 = _slicedToArray(_calculateExplicitPad11, 2);

              _paddingTop2 = _calculateExplicitPad12[0];
              _paddingBottom2 = _calculateExplicitPad12[1];
            }
            var _output2 = operands[outputs[0]];
            success = nn_ops.genericPoolingPrepare(_input2.shape, _paddingLeft2, _paddingRight2, _paddingTop2, _paddingBottom2, _strideWidth2, _strideHeight2, _filterWidth2, _filterHeight2, _output2.shape);
            if (!success) {
              throw new Error('genericPoolingPrepare fails');
            }
            if (op === _Enums.OperationCode.AVERAGE_POOL_2D) {
              success = nn_ops.averagePoolFloat32(_input2.value, _input2.shape, _paddingLeft2, _paddingRight2, _paddingTop2, _paddingBottom2, _strideWidth2, _strideHeight2, _filterWidth2, _filterHeight2, _activation4, _output2.value, _output2.shape);
            } else if (op === _Enums.OperationCode.MAX_POOL_2D) {
              success = nn_ops.maxPoolFloat32(_input2.value, _input2.shape, _paddingLeft2, _paddingRight2, _paddingTop2, _paddingBottom2, _strideWidth2, _strideHeight2, _filterWidth2, _filterHeight2, _activation4, _output2.value, _output2.shape);
            }
            if (!success) {
              throw new Error('Pooling ' + op + ' fails');
            }
          }break;
        case _Enums.OperationCode.SOFTMAX:
          {
            allParametersPresent(2, 1);
            var _input3 = operands[inputs[0]];
            var beta = operands[inputs[1]].value[0];
            if (beta <= 0.0) {
              throw new Error('beta must be positive for SOFTMAX');
            }
            var _output3 = operands[outputs[0]];
            success = nn_ops.genericActivationPrepare(_input3.shape, _output3.shape);
            if (!success) {
              throw new Error('genericActivationPrepare fails');
            }
            success = nn_ops.softmaxFloat32(_input3.value, _input3.shape, beta, _output3.value, _output3.shape);
            if (!success) {
              throw new Error('softmaxFloat32 fails');
            }
          }break;
        case _Enums.OperationCode.RESHAPE:
          {
            allParametersPresent(2, 1);
            var _input4 = operands[inputs[0]];
            var targetShape = operands[inputs[1]];
            var targetShapeBufferLength = (0, _utils.product)(targetShape.shape.dimensions);

            var _output4 = operands[outputs[0]];
            success = nn_ops.reshapePrepare(_input4.shape, targetShape.value, targetShapeBufferLength, _output4.shape);
            if (!success) {
              throw new Error('reshapePrepare fails');
            }
            success = nn_ops.reshapeGeneric(_input4.value, _input4.shape, _output4.value, _output4.shape);
            if (!success) {
              throw new Error('reshapeGeneric fails');
            }
          }break;
        case _Enums.OperationCode.CONCATENATION:
          {
            if (outputs.length < 1 || inputs.length < 2) {
              throw new Error('Invalid inputs or outputs');
            }
            var numInputTensors = inputs.length - 1;
            var axis = operands[inputs[numInputTensors]].value[0];
            var _output5 = operands[outputs[0]];
            var inputShapes = new nn_ops.VectorShape();
            var inputValues = new nn_ops.VectorPtr();
            for (var _i3 = 0; _i3 < numInputTensors; ++_i3) {
              var _input5 = operands[inputs[_i3]];
              inputShapes.push_back(_input5.shape);
              inputValues.push_back(_input5.value);
            }
            success = nn_ops.concatenationPrepare(inputShapes, axis, _output5.shape);
            if (!success) {
              throw new Error('concatenationPrepare fails');
            }
            success = nn_ops.concatenationFloat32(inputValues, inputShapes, axis, _output5.value, _output5.shape);
            if (!success) {
              throw new Error('concatenationFloat32 fails');
            }
            inputShapes.delete();
            inputValues.delete();
          }break;
        default:
          {
            throw new Error('Operation ' + op + ' is not supported');
          }
      }
    }
  }, {
    key: '_setTensorData',
    value: function _setTensorData(type, ptr, data) {
      var nn_ops = this._nn_ops;
      if (type === _Enums.OperandCode.TENSOR_FLOAT32) {
        nn_ops.HEAPF32.set(data, ptr >> 2);
      } else if (type === _Enums.OperandCode.TENSOR_INT32) {
        nn_ops.HEAP32.set(data, ptr >> 2);
      } else if (type === _Enums.OperandCode.TENSOR_QUANT8_ASYMM) {
        nn_ops.HEAPU8.set(data, ptr);
      } else {
        throw new Error('Operand type ' + type + ' is not supproted');
      }
    }
  }, {
    key: '_getTensorData',
    value: function _getTensorData(type, ptr, buffer) {
      var nn_ops = this._nn_ops;
      var view = void 0;
      if (type === _Enums.OperandCode.TENSOR_FLOAT32) {
        view = new Float32Array(nn_ops.HEAPF32.buffer, ptr, buffer.length);
      } else if (type === _Enums.OperandCode.TENSOR_INT32) {
        view = new Int32Array(nn_ops.HEAP32.buffer, ptr, buffer.length);
      } else if (type === _Enums.OperandCode.TENSOR_QUANT8_ASYMM) {
        view = new Uint8Array(nn_ops.HEAPU8.buffer, ptr, buffer.length);
      } else {
        throw new Error('Operand type ' + type + ' is not supproted');
      }
      buffer.set(view);
    }
  }, {
    key: '_allocateTensor',
    value: function _allocateTensor(operand) {
      var nn_ops = this._nn_ops;
      var byteLength = utils.sizeOfTensorData(operand.type, operand.dimensions);
      var ptr = nn_ops._malloc(byteLength);
      if (operand.lifetime === _Enums.OperandLifetime.CONSTANT_REFERENCE) {
        this._setTensorData(operand.type, ptr, operand.value);
      }
      return ptr;
    }
  }, {
    key: '_allocateShape',
    value: function _allocateShape(operand) {
      var nn_ops = this._nn_ops;
      var OperandTypeMap = new Map([[_Enums.OperandCode.TENSOR_FLOAT32, nn_ops.TENSOR_FLOAT32], [_Enums.OperandCode.TENSOR_INT32, nn_ops.TENSOR_INT32], [_Enums.OperandCode.TENSOR_QUANT8_ASYMM, nn_ops.TENSOR_QUANT8_ASYMM]]);
      var shape = new nn_ops.Shape();
      shape.type = OperandTypeMap.get(operand.type);
      shape.dimensions = operand.dimensions;
      return shape;
    }
  }, {
    key: '_deleteAll',
    value: function _deleteAll() {
      var _this2 = this;

      this._operands.forEach(function (operand) {
        if (operand.type === 3 || operand.type === 4) {
          _this2._nn_ops._free(operand.value);
          _this2._nn_ops._free(operand.shape);
        }
      });
      this._model._operands.forEach(function (operand) {
        operand.value = null;
      });
    }
  }]);

  return PreparedModel;
}();

exports.default = PreparedModel;

/***/ }),
/* 103 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(6) && !__webpack_require__(3)(function () {
  return Object.defineProperty(__webpack_require__(75)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(5);


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(17);
var toIObject = __webpack_require__(18);
var arrayIndexOf = __webpack_require__(59)(false);
var IE_PROTO = __webpack_require__(77)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(7);
var anObject = __webpack_require__(1);
var getKeys = __webpack_require__(40);

module.exports = __webpack_require__(6) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(18);
var gOPN = __webpack_require__(43).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = __webpack_require__(40);
var gOPS = __webpack_require__(60);
var pIE = __webpack_require__(53);
var toObject = __webpack_require__(9);
var IObject = __webpack_require__(52);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(3)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(10);
var isObject = __webpack_require__(4);
var invoke = __webpack_require__(111);
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};


/***/ }),
/* 111 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(2).parseInt;
var $trim = __webpack_require__(49).trim;
var ws = __webpack_require__(81);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(2).parseFloat;
var $trim = __webpack_require__(49).trim;

module.exports = 1 / $parseFloat(__webpack_require__(81) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(23);
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(4);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 116 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(84);
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(1);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(10);
var toObject = __webpack_require__(9);
var IObject = __webpack_require__(52);
var toLength = __webpack_require__(8);

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(9);
var toAbsoluteIndex = __webpack_require__(41);
var toLength = __webpack_require__(8);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 121 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(6) && /./g.flags != 'g') __webpack_require__(7).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(64)
});


/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var newPromiseCapability = __webpack_require__(99);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(126);
var validate = __webpack_require__(51);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(68)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(7).f;
var create = __webpack_require__(42);
var redefineAll = __webpack_require__(47);
var ctx = __webpack_require__(22);
var anInstance = __webpack_require__(45);
var forOf = __webpack_require__(46);
var $iterDefine = __webpack_require__(87);
var step = __webpack_require__(121);
var setSpecies = __webpack_require__(44);
var DESCRIPTORS = __webpack_require__(6);
var fastKey = __webpack_require__(32).fastKey;
var validate = __webpack_require__(51);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(126);
var validate = __webpack_require__(51);
var SET = 'Set';

// 23.2 Set Objects
module.exports = __webpack_require__(68)(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each = __webpack_require__(29)(0);
var redefine = __webpack_require__(15);
var meta = __webpack_require__(32);
var assign = __webpack_require__(109);
var weak = __webpack_require__(129);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var validate = __webpack_require__(51);
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(68)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(47);
var getWeak = __webpack_require__(32).getWeak;
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var anInstance = __webpack_require__(45);
var forOf = __webpack_require__(46);
var createArrayMethod = __webpack_require__(29);
var $has = __webpack_require__(17);
var validate = __webpack_require__(51);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(27);
var toLength = __webpack_require__(8);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(43);
var gOPS = __webpack_require__(60);
var anObject = __webpack_require__(1);
var Reflect = __webpack_require__(2).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = __webpack_require__(61);
var isObject = __webpack_require__(4);
var toLength = __webpack_require__(8);
var ctx = __webpack_require__(22);
var IS_CONCAT_SPREADABLE = __webpack_require__(5)('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(8);
var repeat = __webpack_require__(83);
var defined = __webpack_require__(26);

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys = __webpack_require__(40);
var toIObject = __webpack_require__(18);
var isEnum = __webpack_require__(53).f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(54);
var from = __webpack_require__(136);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(46);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 137 */
/***/ (function(module, exports) {

// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Enums = __webpack_require__(37);

var _PreparedModel = __webpack_require__(102);

var _PreparedModel2 = _interopRequireDefault(_PreparedModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Execution = function () {
  /**
   * Create an Execution to apply the given compilation.
   * 
   * @param {Compilation} compilation 
   */
  function Execution(compilation) {
    _classCallCheck(this, Execution);

    if (typeof compilation === 'undefined') {
      throw new Error('Invalid argument');
    }
    this._preparedModel = compilation._preparedModel;
    this._model = compilation._model;
    this._inputs = new Map();
    this._outputs = new Map();
  }

  /**
   * Associate a user data with an input of the model of the Execution.
   * 
   * @param {number} index - The index of the input argument we are setting.
   * @param {TypedArray} buffer - The typed array containing the data.
   */


  _createClass(Execution, [{
    key: 'setInput',
    value: function setInput(index, buffer) {
      var model = this._model;
      if (index > model._inputs.length) {
        throw new Error('Invalid index ' + index);
      }
      var inputIndex = model._inputs[index];
      if (inputIndex > model._operands.length) {
        throw new Error('Invalid input index ' + inputIndex);
      }
      var operand = model._operands[inputIndex];
      if (!model._validateOperandValue(buffer, operand)) {
        throw new Error('Invalid value ' + buffer);
      }
      if (operand.lifetime !== _Enums.OperandLifetime.MODEL_INPUT) {
        throw new Error('Invalid operand lifetime ' + operand.lifetime);
      }
      var tensor = {
        index: inputIndex,
        buffer: buffer
      };
      this._inputs.set(index, tensor);
      return _Enums.ResultCode.NO_ERROR;
    }

    /**
     * Associate a user buffer with an output of the model of the Execution.
     * 
     * @param {number} index - The index of output.
     * @param {TypedArray} buffer - The typed array to receive the output data.
     */

  }, {
    key: 'setOutput',
    value: function setOutput(index, buffer) {
      var model = this._model;
      if (index > model._outputs.length) {
        throw new Error('Invalid index ' + index);
      }
      var outputIndex = model._outputs[index];
      if (outputIndex > model._operands.length) {
        throw new Error('Invalid output index ' + outputIndex);
      }
      var operand = model._operands[outputIndex];
      if (!model._validateOperandValue(buffer, operand)) {
        throw new Error('Invalid value ' + buffer);
      }
      if (operand.lifetime !== _Enums.OperandLifetime.MODEL_OUTPUT) {
        throw new Error('Invalid operand lifetime ' + operand.lifetime);
      }
      var tensor = {
        index: outputIndex,
        buffer: buffer
      };
      this._outputs.set(index, tensor);
      return _Enums.ResultCode.NO_ERROR;
    }

    /**
     * Schedule evaluation of the execution.
     */

  }, {
    key: 'startCompute',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._preparedModel.execute(this._inputs, this._outputs);

              case 2:
                return _context.abrupt('return', _Enums.ResultCode.NO_ERROR);

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function startCompute() {
        return _ref.apply(this, arguments);
      }

      return startCompute;
    }()
  }]);

  return Execution;
}();

exports.default = Execution;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _modelUtils = __webpack_require__(372);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _ndarrayOps = __webpack_require__(36);

var _ndarrayOps2 = _interopRequireDefault(_ndarrayOps);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * WebGL2 Model class
 */
var Model = function () {
  /**
   * Create WebGL2 Model class in nn/Model.js
   *
   * @param {Object} model - Model from nn/Model.js
   */
  function Model(model) {
    _classCallCheck(this, Model);

    this._model = model;
    this._operands = Array(model._operands.length);
    this._layers = [];
    this.supportInputLayer = true;
    this.supportTopClasses = false;
    this.supportFeatureMapConcate = false;
  }

  /**
   * Called in nn/Compilation.js
   *
   */


  _createClass(Model, [{
    key: 'prepareModel',
    value: function prepareModel() {
      var _this = this;

      return new Promise(function (resolve) {
        if (_this.supportInputLayer) {
          var attrs = { inputsNum: _this._model._inputs.length };
          _this._layers.push(new _modelUtils.WebGL2SpecialLayers.Input(attrs));
        }
        _this._model._operations.forEach(function (op, i) {
          // console.log(op);
          var attrs = _modelUtils.OperationCodeAttrsMap.get(op.type)(_this._model._operands, op.inputs, op.outputs);
          var LayerClass = _modelUtils.OperationCodeToLayersMap.get(op.type);
          _this._layers.push(new LayerClass(attrs));
        });
        if (_this.supportTopClasses) {
          _this._layers.push(new _modelUtils.WebGL2SpecialLayers.TopClasses({ numTopClasses: 3 }));
        }
        if (_this.supportFeatureMapConcate) {
          _this._layers.push(new _modelUtils.WebGL2SpecialLayers.FeatureMapConcate({}));
        }
        // console.log(this._layers);
        resolve('compile success');
      });
    }

    /**
     * Called in nn/Execution.js
     *
     * @param {Map} inputs - input map with value: inputBuffers and indexes identifying the input operands.
     * @param {Map} outputs - output map with value: outputBuffers and indexes identifying the output operands.
     */

  }, {
    key: 'execute',
    value: function execute(inputs, outputs) {
      var _this2 = this;

      var inputShape = this._model._operands[inputs.get(0).index].dimensions;
      var outputShape = this._model._operands[outputs.get(0).index].dimensions;
      if (inputShape.length === 4 && inputShape[0] != 1) {
        (function () {
          var inputIndex = 0;
          var outputIndex = 0;
          var inputSize = 0;
          var outputSize = 0;
          var inputBuffer = [];
          var outputBuffer = [];
          var tmpInputs = new Map();
          var tmpOutputs = new Map();
          var tmpBuffer = [];
          var inputDim = [];
          for (var i = 0; i < outputs.size; ++i) {
            tmpBuffer[i] = [];
          }
          for (var _i = 0; _i < inputShape[0]; ++_i) {
            for (var j = 0; j < inputs.size; ++j) {
              inputDim = _this2._model._operands[inputs.get(j).index].dimensions;
              inputSize = inputDim.slice(1).reduce(function (accumulator, currentValue) {
                return accumulator * currentValue;
              });
              inputIndex = inputs.get(j).index;
              inputBuffer = inputs.get(j).buffer;
              tmpInputs.set(j, { index: inputIndex, buffer: inputBuffer.slice(inputSize * _i, inputSize * (_i + 1)) });
            }
            for (var _j = 0; _j < outputs.size; ++_j) {
              outputShape = _this2._model._operands[outputs.get(_j).index].dimensions;
              outputSize = outputShape.slice(1).reduce(function (accumulator, currentValue) {
                return accumulator * currentValue;
              });
              outputIndex = outputs.get(_j).index;
              outputBuffer = outputs.get(_j).buffer;
              tmpOutputs.set(_j, { index: outputIndex, buffer: outputBuffer.slice(outputSize * _i, outputSize * (_i + 1)) });
            }
            _this2._execute(tmpInputs, tmpOutputs, _i);

            var _loop = function _loop(_j2) {
              tmpOutputs.get(_j2).buffer.forEach(function (a) {
                return tmpBuffer[_j2].push(a);
              });
            };

            for (var _j2 = 0; _j2 < outputs.size; ++_j2) {
              _loop(_j2);
            }
          }
          for (var _j3 = 0; _j3 < outputs.size; ++_j3) {
            outputs.get(_j3).buffer.set(tmpBuffer[_j3]);
          }
        })();
      } else {
        this._execute(inputs, outputs);
      }
    }

    /**
       * Called in webgl2/Model.js
       *
       * @param {Map} inputs - input map with value: inputBuffers and indexes identifying the input operands.
       * @param {Map} outputs - output map with value: outputBuffers and indexes identifying the output operands.
       * @param {number} num - The number of batch.
       */

  }, {
    key: '_execute',
    value: function _execute(inputs, outputs) {
      var _this3 = this;

      var num = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      return new Promise(function (resolve) {
        var isLast = false;
        var nnOperands = _this3._model._operands;
        var inputBuffer = inputs.get(0).buffer;
        var inputIndex = inputs.get(0).index;
        var outputBuffer = outputs.get(0).buffer;
        var outputIndex = outputs.get(0).index;
        // let operationStart = performance.now();
        _this3._layers.forEach(function (layer, i) {
          // let start = performance.now();
          if (i === 0) {
            var shape = nnOperands[inputIndex].dimensions;
            if (shape.length === 4) {
              shape = shape.slice(1, 4);
            } else {
              shape = shape;
            }
            if (_this3.supportInputLayer) {
              var inputTensors = layer.call(inputs, shape, Float32Array);
              inputs.forEach(function (input, k) {
                _this3._operands[input.index] = inputTensors[k];
              });
            } else {
              var inputTensor = new _Tensor2.default(inputBuffer, shape);
              _this3._operands[layer.outputs[0]] = layer.call(inputTensor);
            }
          } else if (i === _this3._layers.length - 1 && (_this3.supportTopClasses || _this3.supportFeatureMapConcate)) {
            if (_this3.supportTopClasses) {
              var outBufferAndIndex = layer.call(_this3._operands[outputIndex]);
              // console.log(`outBufferAndIndex: ${outBufferAndIndex}`);
              outputBuffer.fill(0);
              var bufferLength = outBufferAndIndex.length / 2;
              for (var k = 0; k < bufferLength; ++k) {
                outputBuffer[outBufferAndIndex[k + bufferLength]] = outBufferAndIndex[k];
              }
              // console.log(`outputBuffer: ${outputBuffer}`);
            } else if (_this3.supportFeatureMapConcate) {
              var inputList = [];
              for (var _i2 = 0; _i2 < outputs.size; ++_i2) {
                outputIndex = outputs.get(_i2).index;
                inputList.push(_this3._operands[outputIndex]);
              }
              layer.call(inputList, outputs);
            }
          } else {
            if (layer.inputs.length === 1) {
              _this3._operands[layer.outputs[0]] = layer.call(_this3._operands[layer.inputs[0]]);
              isLast = true;
            } else {
              var MutiInputs = [];
              layer.inputs.forEach(function (input) {
                if (!(_this3._operands[input] instanceof _Tensor2.default)) {
                  var inputShape = nnOperands[input].dimensions;
                  if (inputShape.length === 4) {
                    inputShape = inputShape.slice(1, 4);
                  } else {
                    inputShape = inputShape;
                  }
                  var inputSize = inputShape.reduce(function (accumulator, currentValue) {
                    return accumulator * currentValue;
                  });
                  _this3._operands[input] = new _Tensor2.default(nnOperands[input].value.slice(inputSize * num, inputSize * (num + 1)), inputShape);
                  if (typeof nnOperands[input].value[inputSize * (num + 1)] === "undefined") {
                    isLast = true;
                  }
                }
                if (!_this3._operands[input].texture && !_this3._operands[input].textureSlices) {
                  if (_this3._operands[input].tensor.shape.length <= 2) {
                    _this3._operands[input].createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
                  } else if (_this3._operands[input].tensor.shape.length > 2) {
                    _this3._operands[input].reshapeTo2D();
                    _this3._operands[input].createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
                  }
                }
                MutiInputs.push(_this3._operands[input]);
              });
              _this3._operands[layer.outputs[0]] = layer.call(MutiInputs);
            }
            // this._operands[layer.outputs[0]].transferFromGLTexture();
          }
          // console.log(i, (performance.now() - start).toFixed(2), layer);
        });
        if (!_this3.supportTopClasses && !_this3.supportFeatureMapConcate) {
          // let transferTime = performance.now() - operationStart - operationTime;
          for (var i = 0; i < outputs.size; ++i) {
            outputBuffer = outputs.get(i).buffer;
            outputIndex = outputs.get(i).index;
            _this3._operands[outputIndex].transferFromGLTexture();
            outputBuffer.set(_this3._operands[outputIndex].tensor.data);
          }
          // console.log(`Read data from GPU time: ${transferTime.toFixed(2)} ms`)
        }
        if (!isLast) {
          _this3._operands = [];
        }
        // let operationTime = performance.now() - operationStart;
        // console.log(`WebGL2 execute time: ${operationTime.toFixed(2)} ms`);
        resolve('execute success');
      });
    }
  }, {
    key: '_deleteAll',
    value: function _deleteAll() {
      _WebGL2.default.deleteAll();
      this._model._operands.forEach(function (operand) {
        operand.value = null;
      });
    }
  }]);

  return Model;
}();

exports.default = Model;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _convolution = __webpack_require__(373);

Object.keys(_convolution).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _convolution[key];
    }
  });
});

var _fundamental = __webpack_require__(386);

Object.keys(_fundamental).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _fundamental[key];
    }
  });
});

var _pooling = __webpack_require__(395);

Object.keys(_pooling).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _pooling[key];
    }
  });
});

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var vertexShaderSource = exports.vertexShaderSource = "#version 300 es\nprecision highp float;\n\nin vec3 position;\nin vec2 texcoord;\nout vec2 outTex;\n\nvoid main () {\n  gl_Position = vec4(position, 1.0);\n\toutTex = texcoord;\n}";

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ndarray = __webpack_require__(73)

module.exports = squeeze

function squeeze (a, axes) {
  var i
  var shape = []
  var stride = []

  if (axes !== undefined && !Array.isArray(axes)) {
    throw new Error('axes must be an Array list of dimensions to squeeze')
  }

  for (i = 0; i < a.shape.length; i++) {
    if (a.shape[i] !== 1 || (axes !== undefined && axes.indexOf(i) === -1)) {
      shape.push(a.shape[i])
      stride.push(a.stride[i])
    }
  }

  return ndarray(a.data, shape, stride, a.offset)
}


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = matMul;
function matMul(fuse) {
  var source = "#version 300 es\n  precision highp float;\n  precision highp sampler2D;\n  \n  in vec2 outTex;\n  uniform sampler2D A;\n  uniform sampler2D B;\n  uniform sampler2D C;\n  uniform bool addC;\n  out vec4 outColor;\n  \n  void main() {\n    ivec2 A_size = textureSize(A, 0);\n    ivec2 B_size = textureSize(B, 0);\n    int out_x = int(float(B_size[0]) * outTex.x);\n    int out_y = int(float(A_size[1]) * outTex.y);\n    int commonDim = A_size[0];\n  \n    float sum = 0.0;\n    for (int i = 0; i < commonDim; ++i) {\n      float a = texelFetch(A, ivec2(i, out_y), 0).r;\n      float b = texelFetch(B, ivec2(out_x, i), 0).r;\n      sum += a * b;\n    }\n  \n    if (addC) {\n      sum += texelFetch(C, ivec2(out_x, 0), 0).r;\n    }\n  \n    " + fuse + "\n    outColor = vec4(sum);\n  }";
  return source;
}

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = conv2d;
/**
 * Create GLSL program for Conv2D layer
 *
 * @param {number[]} outputShape
 * @param {number[]} inputShape
 * @param {number[]} indexMapShape
 * @param {boolean} useBias
 * @param {boolean} [hasFragments]
 */
function conv2d(outputShape, inputShape, indexMapShape, useBias, hasFragments, fuse) {
  var addBias = useBias ? 'sum += texelFetch(bias, ivec2(out_x, 0), 0).r;' : '';

  var adjustIndicesForFragments = hasFragments ? 'int fragmentIndex = int(floor(float(rowIndex) / float(' + inputShape[0] + ')));\n      rowIndex = int(mod(float(rowIndex), float(' + inputShape[0] + ')));\n      colIndex += fragmentIndex * ' + inputShape[1] + ';' : '';

  var source = '#version 300 es\n  precision highp int;\n  precision highp float;\n  precision highp isampler2D;\n  precision highp sampler2D;\n\n  in vec2 outTex;\n  uniform sampler2D x;\n  uniform isampler2D indexMap;\n  uniform sampler2D kernel;\n  uniform sampler2D bias;\n  out vec4 outColor;\n\n  void main() {\n    int out_y = int(float(' + outputShape[0] + ') * outTex.y);\n    int out_x = int(float(' + outputShape[1] + ') * outTex.x);\n\n    float sum = 0.0;\n    for (int i = 0; i < ' + indexMapShape[1] + '; ++i) {\n      int index = texelFetch(indexMap, ivec2(i, out_y), 0).r;    \n      if (index != -1) {\n        int rowIndex = int(floor(float(index) / float(' + inputShape[1] + ')));\n        int colIndex = int(mod(float(index), float(' + inputShape[1] + ')));\n        ' + adjustIndicesForFragments + '\n        sum += texelFetch(x, ivec2(colIndex, rowIndex), 0).r * texelFetch(kernel, ivec2(out_x, i), 0).r;\n      }\n    }\n\n    ' + addBias + '\n    ' + fuse + '\n    outColor = vec4(sum);\n  }';
  return source;
}

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = matMulDepthwise;
function matMulDepthwise(fuse) {
  var source = "#version 300 es\n  precision highp int;\n  precision highp float;\n  precision highp sampler2D;\n  \n  in vec2 outTex;\n  uniform sampler2D A;\n  uniform sampler2D B;\n  uniform sampler2D C;\n  uniform int inputChannels;\n  uniform int outputChannels;\n  uniform int depthMultiplier;\n  uniform bool addC;\n  out vec4 outColor;\n  \n  void main() {\n    ivec2 A_size = textureSize(A, 0);\n    ivec2 B_size = textureSize(B, 0);\n    int length = B_size[1];\n    int out_x = int(float(outputChannels) * outTex.x);\n    int out_y = int(float(A_size[1]) * outTex.y);\n    int index = int(floor(float(out_x) / float(depthMultiplier)));\n    float sum = 0.0;\n\n    if (index < inputChannels) {\n      for (int i = 0; i < length; ++i) {\n        float a = texelFetch(A, ivec2(i + index * length, out_y), 0).r;\n        float b = texelFetch(B, ivec2(out_x, i), 0).r;\n        sum += a * b;\n      }\n    }\n  \n    if (addC) {\n      sum += texelFetch(C, ivec2(out_x, 0), 0).r;\n    }\n  \n    " + fuse + "\n    outColor = vec4(sum);\n  }";
  return source;
}

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = depthwiseConv2D;
/**
 * Create GLSL program for DepthwiseConv2 layer
 *
 * @param {number} inputChannels
 * @param {number} outputChannels
 * @param {number} depthMultiplier
 * @param {boolean} useBias
 * @param {boolean} [hasFragments]
 */
function depthwiseConv2D(inputChannels, outputChannels, depthMultiplier, useBias, hasSlices, fuse) {
  var addBias = useBias ? 'sum += texelFetch(bias, ivec2(out_x, 0), 0).r;' : '';

  var adjustIndicesForSlices = hasSlices ? 'ivec2 inputSize = textureSize(x, 0);\n      int sliceIndex = int(floor(float(index) / float(inputSize[1])));\n      index = int(mod(float(index), float(inputSize[1])));\n      int fetch_x = sliceIndex * ' + inputChannels + ' + in_x;' : 'int fetch_x = in_x;';

  var source = '#version 300 es\n  precision highp int;\n  precision highp float;\n  precision highp isampler2D;\n  precision highp sampler2D;\n  \n  in vec2 outTex;\n  uniform sampler2D x;\n  uniform isampler2D indexMap;\n  uniform sampler2D kernel;\n  uniform sampler2D bias;\n  out vec4 outColor;\n  \n  void main() {\n    ivec2 indexMapSize = textureSize(indexMap, 0);\n    int out_x = int(float(' + outputChannels + ') * outTex.x);\n    int out_y = int(float(indexMapSize[1]) * outTex.y);\n    ivec2 kernelSize = textureSize(kernel, 0);\n    int convSize = kernelSize[1];\n    int in_x = int(floor(float(out_x) / float(' + depthMultiplier + ')));\n    float sum = 0.0;\n\n    if(in_x < ' + inputChannels + ') {\n      for (int i = 0; i < convSize; ++i) {\n        int index = texelFetch(indexMap, ivec2(i, out_y), 0).r; \n        if (index != -1) {\n          ' + adjustIndicesForSlices + '\n          sum += texelFetch(x, ivec2(fetch_x, index), 0).r * texelFetch(kernel, ivec2(out_x, i), 0).r;\n        }\n      }\n    }\n    ' + addBias + '\n    ' + fuse + '\n    outColor = vec4(sum);\n  }';
  return source;
}

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = add;
function add(fuse) {
  var source = "#version 300 es\n  precision highp float;\n  precision highp sampler2D;\n  \n  in vec2 outTex;\n  uniform sampler2D A;\n  uniform sampler2D B;\n  out vec4 outColor;\n  \n  void main() {\n    ivec2 A_size = textureSize(A, 0);\n    int out_x = int(float(A_size[0]) * outTex.x);\n    int out_y = int(float(A_size[1]) * outTex.y);\n  \n    float a = texelFetch(A, ivec2(out_x, out_y), 0).r;\n    float b = texelFetch(B, ivec2(out_x, out_y), 0).r;\n    float sum = a + b;\n    " + fuse + "\n    outColor = vec4(sum);\n  }";
  return source;
}

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = mul;
function mul(fuse) {
  var source = "#version 300 es\n  precision highp float;\n  precision highp sampler2D;\n  \n  in vec2 outTex;\n  uniform sampler2D A;\n  uniform sampler2D B;\n  out vec4 outColor;\n  \n  void main() {\n    ivec2 A_size = textureSize(A, 0);\n    int out_x = int(float(A_size[0]) * outTex.x);\n    int out_y = int(float(A_size[1]) * outTex.y);\n  \n    float a = texelFetch(A, ivec2(out_x, out_y), 0).r;\n    float b = texelFetch(B, ivec2(out_x, out_y), 0).r;\n    float sum = a * b;\n    " + fuse + "\n    outColor = vec4(sum);\n  }";
  return source;
}

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = topClasses;
/**
 * Create GLSL program for TopClasses layer
 *
 * @param {number} numTopC
 * @param {number} length
 */

function topClasses(numTopC, length) {
  var source = " #version 300 es\n  precision highp float;\n  precision highp sampler2D;\n\n  in vec2 outTex;\n  uniform sampler2D x;\n  out vec4 outColor;\n\n  void main() {\n    ivec2 size = textureSize(x, 0);\n    int out_x = int(float(size[0]) * outTex.x);\n    if (out_x < 2 * " + numTopC + ") {\n      int numTop = out_x;\n      if (numTop >= " + numTopC + ") {\n        numTop = numTop - " + numTopC + ";\n      }\n\n      float textureCopy[" + length + "];\n      int index[" + length + "];\n      for (int i = 0; i < size[0]; ++i) {\n        textureCopy[i] = texelFetch(x, ivec2(i, 0), 0).r;\n        index[i] = i;\n      }\n      int high = size[0] - 1;\n      int low = 0;\n      while (low < high) {\n        int i = low;\n        int j = high;\n        float pixel = textureCopy[low];\n        int pixelIndex = index[low];\n        while (i < j) {\n          while (i < j && textureCopy[j] < pixel)\n            --j;\n          if (i < j) {\n            textureCopy[i] = textureCopy[j]; \n            index[i] = index[j];\n            i++;\n          }\n          while (i < j && textureCopy[i] > pixel)\n            ++i;\n          if (i < j) {\n            textureCopy[j] = textureCopy[i]; \n            index[j] = index[i];\n            j--;\n          }\n        }\n        textureCopy[i] = pixel;\n        index[i] = pixelIndex;\n        if (i == numTop) {\n          low = high;\n        }\n        else if (i < numTop)\n          low = i + 1;\n        else\n          high = i - 1;\n      }\n      if (out_x < " + numTopC + ") {\n        outColor = vec4(textureCopy[numTop]);\n      } else {\n        outColor = vec4(float(index[numTop]));\n      }\n    } else {\n      outColor = vec4(0.0);\n    }\n  }";
  return source;
}

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reduceClasses;
/**
 * Create GLSL program for TopClasses layer
 *
 * @param {number} reduceNums
 * @param {number} reduceLen
 * @param {number} index
 * @param {number} x_width
 */

function reduceClasses(reduceNums, reduceLen, index, x_width) {
  var high_index = void 0;
  if (index == 0) {
    high_index = "i";
  } else {
    high_index = "int(texelFetch(x, ivec2(i, 1), 0).r)";
  }

  var source = "#version 300 es\n  precision highp float;\n  precision highp sampler2D;\n\n  in vec2 outTex;\n  uniform sampler2D x;\n  out vec4 outColor;\n\n  void main() {\n    int out_x = int(float(" + reduceLen + ") * outTex.x);\n    int out_y = int(2.0 * outTex.y);\n    float high;\n    int high_index;\n    // outColor = vec4(float(out_x));\n    if (out_y == 0) {\n      for (int i = out_x * " + reduceNums + "; i < min((out_x + 1) * " + reduceNums + ", " + x_width + "); ++i) {\n        float x_pixelR = texelFetch(x, ivec2(i, 0), 0).r;\n        if (i == out_x * " + reduceNums + " || x_pixelR > high) {\n          high = x_pixelR;\n        }\n      }\n      outColor = vec4(high);\n    } else {\n      for (int i = out_x * " + reduceNums + "; i < min((out_x + 1) * " + reduceNums + ", " + x_width + "); ++i) {\n        float x_pixelR = texelFetch(x, ivec2(i, 0), 0).r;\n        if (i == out_x * " + reduceNums + " || x_pixelR > high) {\n          high = x_pixelR;\n          high_index = " + high_index + ";\n        }\n      }\n      outColor = vec4(float(high_index));\n    }\n  }";
  return source;
}

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _globalPooling = __webpack_require__(152);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * _GlobalPooling2D layer class
 */
var _GlobalPooling2D = function (_Layer) {
  _inherits(_GlobalPooling2D, _Layer);

  /**
   * Creates a _GlobalPooling2D layer
   *
   * @param {Object} [attrs] - layer config attributes
   */
  function _GlobalPooling2D() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, _GlobalPooling2D);

    var _this = _possibleConstructorReturn(this, (_GlobalPooling2D.__proto__ || Object.getPrototypeOf(_GlobalPooling2D)).call(this, attrs));

    _this.name = '_GlobalPooling2D';

    var _attrs$data_format = attrs.data_format,
        data_format = _attrs$data_format === undefined ? 'HWC' : _attrs$data_format;

    _this.dataFormat = data_format;

    // default pooling function
    // can be `max` or `average`
    _this.poolingFunc = 'max';
    _this.poolingProgram = _WebGL2.default.createProgram(_globalPooling.globalPoolingShaderSource);
    return _this;
  }

  /**
   * call
   *
   * @param {Tensor} x
   * @returns {Tensor}
   */


  _createClass(_GlobalPooling2D, [{
    key: 'call',
    value: function call(x) {
      if (x.is2DReshaped) {
        this.inputShape = x.originalShape;
      } else {
        // convert to HWC ordering
        if (this.dataFormat === 'CHW') {
          x.tensor = x.tensor.transpose(1, 2, 0);
        }
        this.inputShape = x.tensor.shape;
        x.reshapeTo2D();
        x.createGLTexture({ type: '2d', format: 'float' });
      }
      // create output textures if doesn't already exist
      if (!this.output) {
        this.output = new _Tensor2.default([], [1, 1, this.inputShape[2]]);
        this.output.reshapeTo2D();
        this.output.createGLTexture({ type: '2d', format: 'float' });
      }

      // `true` if max pooling, `false` if average pooling
      var isMaxPooling = this.poolingFunc === 'max';
      _WebGL2.default.runProgram({
        program: this.poolingProgram,
        output: this.output,
        inputs: [{ input: x, name: 'x' }],
        uniforms: [{ value: this.inputShape[0] * this.inputShape[1], type: 'int', name: 'channelDataSize' }, { value: isMaxPooling, type: 'bool', name: 'isMaxPooling' }]
      });
      return this.output;
    }
  }]);

  return _GlobalPooling2D;
}(_Layer3.default);

exports.default = _GlobalPooling2D;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var globalPoolingShaderSource = exports.globalPoolingShaderSource = "#version 300 es\nprecision highp float;\nprecision highp sampler2D;\n\nin vec2 outTex;\nuniform sampler2D x;\nuniform int channelDataSize;\nuniform bool isMaxPooling;\nout vec4 outColor;\n\nvoid main() {\n  ivec2 size = textureSize(x, 0);\n  int out_x = int(float(size[0]) * outTex.x);\n  int out_y = int(float(size[1]) * outTex.y);\n\n  if (isMaxPooling) {\n    // GlobalMaxPooling\n    float maxval = 0.0;\n    for (int j = 0; j < size[1]; ++j) {\n      float val = texelFetch(x, ivec2(out_x, j), 0).r;\n      if (j == 0 || val > maxval) {\n        maxval = val;\n      }\n    }\n    outColor = vec4(maxval);\n  } else {\n    // GlobalAveragePooling\n    float sum = 0.0;\n    for (int j = 0; j < size[1]; ++j) {\n      float val = texelFetch(x, ivec2(out_x, j), 0).r;\n      sum += val;\n    }\n    outColor = vec4(sum / float(channelDataSize));\n  }\n}";

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _activation = __webpack_require__(55);

var activations = _interopRequireWildcard(_activation);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _tensorUtils = __webpack_require__(35);

var tensorUtils = _interopRequireWildcard(_tensorUtils);

var _ndarrayOps = __webpack_require__(36);

var _ndarrayOps2 = _interopRequireDefault(_ndarrayOps);

var _pool2D = __webpack_require__(154);

var _pool2D2 = _interopRequireDefault(_pool2D);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * _Pool2D layer class
 */
var _Pool2D = function (_Layer) {
  _inherits(_Pool2D, _Layer);

  /**
   * Creates a _Pool2D layer
   */
  function _Pool2D() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, _Pool2D);

    var _this = _possibleConstructorReturn(this, (_Pool2D.__proto__ || Object.getPrototypeOf(_Pool2D)).call(this, attrs));

    _this.name = '_Pool2D';
    var _attrs$kernel_size = attrs.kernel_size,
        kernel_size = _attrs$kernel_size === undefined ? [2, 2] : _attrs$kernel_size,
        _attrs$strides = attrs.strides,
        strides = _attrs$strides === undefined ? [2, 2] : _attrs$strides,
        _attrs$padding = attrs.padding,
        padding = _attrs$padding === undefined ? 'VALID' : _attrs$padding,
        _attrs$data_format = attrs.data_format,
        data_format = _attrs$data_format === undefined ? 'NHWC' : _attrs$data_format,
        _attrs$activation = attrs.activation,
        activation = _attrs$activation === undefined ? 'NONE' : _attrs$activation;


    if (Array.isArray(kernel_size)) {
      _this.kernelShape = kernel_size;
    } else {
      _this.kernelShape = [kernel_size, kernel_size];
    }

    if (Array.isArray(strides)) {
      _this.strides = strides;
    } else {
      _this.strides = [strides, strides];
    }

    if (Array.isArray(padding)) {
      if (padding.length !== 4) {
        _this.throwError('Invalid padding.');
        // if all numbers in padding are 0, use padding = 'VALID'
      } else if (padding.every(function (x) {
        return !x;
      })) {
        _this.padding = 'VALID';
      } else {
        _this.padding = padding;
      }
    } else if (padding === 'VALID' || padding === 'SAME') {
      _this.padding = padding;
    } else {
      _this.throwError('Invalid padding.');
    }

    if (data_format === 'NHWC') {
      _this.dataFormat = data_format;
    } else {
      _this.throwError('Only NHWC data formats are allowed.');
    }

    _this.activation = activation;
    if (_this.activation !== 'NONE') {
      _this.activationProgram = _WebGL2.default.createProgram(activations[_this.activation]);
    }
    return _this;
  }

  /**
   * Method for computing output dimensions and padding, 
   * based on input dimensions, kernel size, and padding mode.
   *
   * @param {number[]} inputShape
   */


  _createClass(_Pool2D, [{
    key: '_calcOutputShape',
    value: function _calcOutputShape(inputShape) {
      if (this.outputShape && this.inputPadding) {
        return;
      }

      var _inputShape = _slicedToArray(inputShape, 3),
          inputRows = _inputShape[0],
          inputCols = _inputShape[1],
          inputChannels = _inputShape[2];

      var _kernelShape = _slicedToArray(this.kernelShape, 2),
          kernelH = _kernelShape[0],
          kernelW = _kernelShape[1];

      if (Array.isArray(this.padding)) {
        var outputRows = Math.floor((inputRows - kernelH + this.strides[0] + this.padding[0] + this.padding[1]) / this.strides[0]);
        var outputCols = Math.floor((inputCols - kernelW + this.strides[1] + this.padding[2] + this.padding[3]) / this.strides[1]);
        this.outputShape = [outputRows, outputCols, inputChannels];
        this.inputPadding = this.padding;
      } else {
        var _outputRows = this.padding === 'SAME' ? Math.floor((inputRows + this.strides[0] - 1) / this.strides[0]) : Math.floor((inputRows - kernelH + this.strides[0]) / this.strides[0]);
        var _outputCols = this.padding === 'SAME' ? Math.floor((inputCols + this.strides[1] - 1) / this.strides[1]) : Math.floor((inputCols - kernelW + this.strides[1]) / this.strides[1]);

        var paddingRow = this.padding === 'SAME' ? Math.max(0, Math.floor((_outputRows - 1) * this.strides[0] + kernelH - inputRows)) : 0;
        var paddingCol = this.padding === 'SAME' ? Math.max(0, Math.floor((_outputCols - 1) * this.strides[1] + kernelW - inputCols)) : 0;
        var paddingRowBefore = Math.floor(paddingRow / 2);
        var paddingRowAfter = paddingRow - paddingRowBefore;
        var paddingColBefore = Math.floor(paddingCol / 2);
        var paddingColAfter = paddingCol - paddingColBefore;
        this.outputShape = [_outputRows, _outputCols, inputChannels];
        this.inputPadding = [paddingRowBefore, paddingRowAfter, paddingColBefore, paddingColAfter];
      }
    }

    /**
     * Pre-compute index map for pooling function
     */

  }, {
    key: '_createIndexMap',
    value: function _createIndexMap() {
      if (this.poolIndexMap) {
        return;
      }

      var _inputShape2 = _slicedToArray(this.inputShape, 3),
          inputRows = _inputShape2[0],
          inputCols = _inputShape2[1],
          inputChannels = _inputShape2[2];

      var rowIndices = new _Tensor2.default([], [inputRows, inputCols]);
      var index = 0;
      for (var i = 0; i < inputRows; i++) {
        for (var j = 0; j < inputCols; j++) {
          rowIndices.tensor.set(i, j, index);
          index += 1;
        }
      }

      // padding
      if (this.padding === 'SAME' || Array.isArray(this.padding)) {
        var _inputPadding = _slicedToArray(this.inputPadding, 4),
            paddingRowBefore = _inputPadding[0],
            paddingRowAfter = _inputPadding[1],
            paddingColBefore = _inputPadding[2],
            paddingColAfter = _inputPadding[3];

        inputRows = inputRows + paddingRowBefore + paddingRowAfter;
        inputCols = inputCols + paddingColBefore + paddingColAfter;
        var _rowIndices = new _Tensor2.default([], [inputRows, inputCols]);
        _ndarrayOps2.default.assigns(_rowIndices.tensor, -1);
        _ndarrayOps2.default.assign(_rowIndices.tensor.hi(this.inputShape[0] + paddingRowBefore, this.inputShape[1] + paddingColBefore).lo(paddingRowBefore, paddingColBefore), rowIndices.tensor);
        rowIndices.tensor = _rowIndices.tensor;
      }

      var _kernelShape2 = _slicedToArray(this.kernelShape, 2),
          nbRow = _kernelShape2[0],
          nbCol = _kernelShape2[1];

      var outputRows = this.outputShape[0];
      var outputCols = this.outputShape[1];

      this.poolIndexMap = new _Tensor2.default([], [outputRows * outputCols, nbRow * nbCol], Int32Array);

      var patchRow = new _Tensor2.default([], [nbRow, nbCol]);
      var offset = 0;
      for (var _i = 0, limit = inputRows - nbRow; _i <= limit; _i += this.strides[0]) {
        for (var _j = 0, _limit = inputCols - nbCol; _j <= _limit; _j += this.strides[1]) {
          _ndarrayOps2.default.assign(patchRow.tensor, rowIndices.tensor.hi(_i + nbRow, _j + nbCol).lo(_i, _j));
          this.poolIndexMap.tensor.data.set(patchRow.tensor.data, offset);
          offset += nbRow * nbCol;
        }
      }
      this.poolIndexMap.createGLTexture({ type: '2d', format: 'int', supportSliceTexture: true });
    }

    /**
     * call
     *
     * @param {Tensor} x
     */

  }, {
    key: 'call',
    value: function call(x) {
      if (x.is2DReshaped) {
        this.inputShape = x.originalShape;
        this._calcOutputShape(this.inputShape);
        this._createIndexMap();
      } else {
        this.throwError('Invalid input.');
      }

      var _outputShape = _slicedToArray(this.outputShape, 3),
          outputRows = _outputShape[0],
          outputCols = _outputShape[1],
          inputChannels = _outputShape[2];

      var outputTextureShape = [outputRows * outputCols, inputChannels];
      // create output textures if doesn't already exist
      if (this.activation !== 'NONE' && !this.outputPreactiv) {
        this.outputPreactiv = new _Tensor2.default([], outputTextureShape);
        this.outputPreactiv.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
        this.outputPreactiv.is2DReshaped = true;
        this.outputPreactiv.originalShape = this.outputShape;
        this.outputPreactiv.indicesForReshaped = tensorUtils.createIndicesFor2DReshaped(this.outputShape, false, -1);
      }
      if (!this.output) {
        this.output = new _Tensor2.default([], outputTextureShape);
        this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
        this.output.is2DReshaped = true;
        this.output.originalShape = this.outputShape;
        this.output.indicesForReshaped = tensorUtils.createIndicesFor2DReshaped(this.outputShape, false, -1);
      }

      var poolSize = this.kernelShape[0] * this.kernelShape[1];
      // `true` if max pooling, `false` if average pooling
      var isMaxPooling = this.poolingFunc === 'max';
      var programUniforms = [{ value: this.output.textureShape[1], type: 'int', name: 'channels' }, { value: poolSize, type: 'int', name: 'poolSize' }, { value: +isMaxPooling, type: 'bool', name: 'isMaxPooling' }];
      if (x.textureSlices) {
        x.convertTextureSlicesToColStackTexture();
      }

      if (!this.poolingProgram) {
        var pool2DShaderSource = (0, _pool2D2.default)(x.textureSlices);
        this.poolingProgram = _WebGL2.default.createProgram(pool2DShaderSource);
      }
      _WebGL2.default.runProgram({
        program: this.poolingProgram,
        output: this.activation === 'NONE' ? this.output : this.outputPreactiv,
        inputs: [{ input: x, name: 'x' }, { input: this.poolIndexMap, name: 'poolIndexMap' }],
        uniforms: programUniforms,
        supportSliceTexture: true
      });

      // Activation
      if (this.activation !== 'NONE') {
        _WebGL2.default.runProgram({
          program: this.activationProgram,
          output: this.output,
          inputs: [{ input: this.outputPreactiv, name: 'x' }],
          supportSliceTexture: true
        });
      }
      return this.output;
    }
  }]);

  return _Pool2D;
}(_Layer3.default);

exports.default = _Pool2D;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pool2D;
/**
 * Create GLSL program for Pool2D layer
 *
 * @param {boolean} hasSlices
 */
function pool2D(hasSlices) {
  var adjustIndicesForSlices = hasSlices ? 'ivec2 inputSize = textureSize(x, 0);\n    int sliceIndex = int(floor(float(poolIndex) / float(inputSize[1])));\n    poolIndex = int(mod(float(poolIndex), float(inputSize[1])));\n    int fetch_x = sliceIndex * channels + out_x;' : 'int fetch_x = out_x;';

  var source = '#version 300 es\n  precision highp int;\n  precision highp float;\n  precision highp isampler2D;\n  precision highp sampler2D;\n\n  in vec2 outTex;\n  uniform sampler2D x;\n  uniform isampler2D poolIndexMap;\n  uniform int channels;\n  uniform int poolSize;\n  uniform bool isMaxPooling;\n  out vec4 outColor;\n\n  void main() {\n    ivec2 outputSize = textureSize(poolIndexMap, 0);\n    int out_x = int(float(channels) * outTex.x);\n    int out_y = int(float(outputSize[1]) * outTex.y);\n    float val = 0.;\n    int count = 0;\n    for (int i = 0; i < poolSize; ++i) {\n      int poolIndex = texelFetch(poolIndexMap, ivec2(i, out_y), 0).r;\n      if (poolIndex != -1) {\n        ' + adjustIndicesForSlices + '\n        float val2 = texelFetch(x, ivec2(fetch_x, poolIndex), 0).r;\n        if (isMaxPooling) {\n          if (count == 0 || val2 > val) {\n            val = val2;\n          }\n        } else {\n          val += val2;\n        }\n        count += 1;\n      }\n    }\n\n    if (!isMaxPooling) {\n      val /= float(count);\n    }\n\n    outColor = vec4(val);\n  }';
  return source;
}

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(156);


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _nn = __webpack_require__(157);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var WebMLPolyfill = function () {
  function WebMLPolyfill() {
    _classCallCheck(this, WebMLPolyfill);

    this._nnContext;
    this.isPolyfill = true;
  }

  _createClass(WebMLPolyfill, [{
    key: 'getNeuralNetworkContext',
    value: function getNeuralNetworkContext() {
      if (typeof this._nnContext === 'undefined') {
        this._nnContext = new _nn.NeuralNetworkContext();
      }
      return this._nnContext;
    }
  }]);

  return WebMLPolyfill;
}();

if (typeof navigator.ml === 'undefined') {
  navigator.ml = new WebMLPolyfill();
} else {
  navigator.ml_polyfill = new WebMLPolyfill();
}

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NeuralNetworkContext = undefined;

var _NeuralNetworkContext = __webpack_require__(158);

var _NeuralNetworkContext2 = _interopRequireDefault(_NeuralNetworkContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.NeuralNetworkContext = _NeuralNetworkContext2.default;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Enums = __webpack_require__(37);

var _Model = __webpack_require__(159);

var _Model2 = _interopRequireDefault(_Model);

var _Compilation = __webpack_require__(101);

var _Compilation2 = _interopRequireDefault(_Compilation);

var _Execution = __webpack_require__(138);

var _Execution2 = _interopRequireDefault(_Execution);

var _webgl = __webpack_require__(400);

var _webgl2 = _interopRequireDefault(_webgl);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NeuralNetworkContext = function () {
  function NeuralNetworkContext() {
    _classCallCheck(this, NeuralNetworkContext);

    this._initOperandTypes();
    this._initOperationTypes();
    this._initFusedActivationFunctionTypes();
    this._initImplicitPaddingTypes();
    this._initExecutionPreferenceTypes();
    this.supportWebGL2 = _webgl2.default;
    this.supportWasm = !!window.WebAssembly;
  }

  /**
   * Create a model object.
   * 
   * @param {options} options.useWebGL2 - create model backed by WebGL2.
   */


  _createClass(NeuralNetworkContext, [{
    key: 'createModel',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(options.useWebGL2 && !this.supportWebGL2)) {
                  _context.next = 4;
                  break;
                }

                return _context.abrupt('return', "WebGL2 is not available");

              case 4:
                if (this.supportWasm) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt('return', "WebAssembly is not available");

              case 6:
                return _context.abrupt('return', new _Model2.default(options));

              case 7:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createModel() {
        return _ref.apply(this, arguments);
      }

      return createModel;
    }()
  }, {
    key: '_initOperandTypes',
    value: function _initOperandTypes() {
      this.FLOAT32 = _Enums.OperandCode.FLOAT32;
      this.INT32 = _Enums.OperandCode.INT32;
      this.UINT32 = _Enums.OperandCode.UINT32;
      this.TENSOR_FLOAT32 = _Enums.OperandCode.TENSOR_FLOAT32;
      this.TENSOR_INT32 = _Enums.OperandCode.TENSOR_INT32;
      this.TENSOR_QUANT8_ASYMM = _Enums.OperandCode.TENSOR_QUANT8_ASYMM;
    }
  }, {
    key: '_initOperationTypes',
    value: function _initOperationTypes() {
      this.ADD = _Enums.OperationCode.ADD;
      this.AVERAGE_POOL_2D = _Enums.OperationCode.AVERAGE_POOL_2D;
      this.CONCATENATION = _Enums.OperationCode.CONCATENATION;
      this.CONV_2D = _Enums.OperationCode.CONV_2D;
      this.DEPTHWISE_CONV_2D = _Enums.OperationCode.DEPTHWISE_CONV_2D;
      this.DEPTH_TO_SPACE = _Enums.OperationCode.DEPTH_TO_SPACE;
      this.DEQUANTIZE = _Enums.OperationCode.DEQUANTIZE;
      this.EMBEDDING_LOOKUP = _Enums.OperationCode.EMBEDDING_LOOKUP;
      this.FLOOR = _Enums.OperationCode.FLOOR;
      this.FULLY_CONNECTED = _Enums.OperationCode.FULLY_CONNECTED;
      this.HASHTABLE_LOOKUP = _Enums.OperationCode.HASHTABLE_LOOKUP;
      this.L2_NORMALIZATION = _Enums.OperationCode.L2_NORMALIZATION;
      this.L2_POOL_2D = _Enums.OperationCode.L2_POOL_2D;
      this.LOCAL_RESPONSE_NORMALIZATION = _Enums.OperationCode.LOCAL_RESPONSE_NORMALIZATION;
      this.LOGISTIC = _Enums.OperationCode.LOGISTIC;
      this.LSH_PROJECTION = _Enums.OperationCode.LSH_PROJECTION;
      this.LSTM = _Enums.OperationCode.LSTM;
      this.MAX_POOL_2D = _Enums.OperationCode.MAX_POOL_2D;
      this.MUL = _Enums.OperationCode.MUL;
      this.RELU = _Enums.OperationCode.RELU;
      this.RELU1 = _Enums.OperationCode.RELU1;
      this.RELU6 = _Enums.OperationCode.RELU6;
      this.RESHAPE = _Enums.OperationCode.RESHAPE;
      this.RESIZE_BILINEAR = _Enums.OperationCode.RESIZE_BILINEAR;
      this.RNN = _Enums.OperationCode.RNN;
      this.SOFTMAX = _Enums.OperationCode.SOFTMAX;
      this.SPACE_TO_DEPTH = _Enums.OperationCode.SPACE_TO_DEPTH;
      this.SVDF = _Enums.OperationCode.SVDF;
      this.TANH = _Enums.OperationCode.TANH;
    }
  }, {
    key: '_initFusedActivationFunctionTypes',
    value: function _initFusedActivationFunctionTypes() {
      this.FUSED_NONE = _Enums.FuseCode.NONE;
      this.FUSED_RELU = _Enums.FuseCode.RELU;
      this.FUSED_RELU1 = _Enums.FuseCode.RELU1;
      this.FUSED_RELU6 = _Enums.FuseCode.RELU6;
    }
  }, {
    key: '_initImplicitPaddingTypes',
    value: function _initImplicitPaddingTypes() {
      this.PADDING_SAME = _Enums.PaddingCode.SAME;
      this.PADDING_VALID = _Enums.PaddingCode.VALID;
    }
  }, {
    key: '_initExecutionPreferenceTypes',
    value: function _initExecutionPreferenceTypes() {
      this.PREFER_LOW_POWER = _Enums.PreferenceCode.LOW_POWER;
      this.PREFER_FAST_SINGLE_ANSWER = _Enums.PreferenceCode.FAST_SINGLE_ANSWER;
      this.PREFER_SUSTAINED_SPEED = _Enums.PreferenceCode.SUSTAINED_SPEED;
    }
  }, {
    key: '_initResultCodes',
    value: function _initResultCodes() {
      this.NO_ERROR = _Enums.ResultCode.NO_ERROR;
      this.OUT_OF_MEMORY = _Enums.ResultCode.OUT_OF_MEMORY;
      this.INCOMPLETE = _Enums.ResultCode.INCOMPLETE;
      this.UNEXPECTED_NULL = _Enums.ResultCode.UNEXPECTED_NULL;
      this.BAD_DATA = _Enums.ResultCode.BAD_DATA;
      this.OP_FAILED = _Enums.ResultCode.OP_FAILED;
      this.UNMAPPABLE = _Enums.ResultCode.UNMAPPABLE;
      this.BAD_STATE = _Enums.ResultCode.BAD_STATE;
    }
  }]);

  return NeuralNetworkContext;
}();

exports.default = NeuralNetworkContext;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Enums = __webpack_require__(37);

var _utils = __webpack_require__(74);

var utils = _interopRequireWildcard(_utils);

var _Compilation = __webpack_require__(101);

var _Compilation2 = _interopRequireDefault(_Compilation);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Model = function () {
  /**
   * Create an empty model.
   */
  function Model() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Model);

    this._completed = false;
    this._operands = [];
    this._operations = [];
    this._inputs = null;
    this._outputs = null;
    this._useWebGL2 = options.useWebGL2;
  }

  /**
   * Create a compilation from model.
   * 
   * @returns {Compilation} - the compilation object.
   */


  _createClass(Model, [{
    key: 'createCompilation',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._completed) {
                  _context.next = 2;
                  break;
                }

                throw new Error('Model is not finished');

              case 2:
                return _context.abrupt('return', new _Compilation2.default(this));

              case 3:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function createCompilation() {
        return _ref.apply(this, arguments);
      }

      return createCompilation;
    }()

    /**
     * Indicate that we have finished modifying a model.
     */

  }, {
    key: 'finish',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!this._completed) {
                  _context2.next = 2;
                  break;
                }

                throw new Error('finish called more than once');

              case 2:
                if (!(this._inputs === null || this._outputs === null)) {
                  _context2.next = 4;
                  break;
                }

                throw new Error('No inputs or outputs of this model');

              case 4:

                this._sortIntoRunOrder();
                this._completed = true;
                return _context2.abrupt('return', _Enums.ResultCode.NO_ERROR);

              case 7:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function finish() {
        return _ref2.apply(this, arguments);
      }

      return finish;
    }()

    /**
     * Add an operand to a model.
     * 
     * @param {number} options.type -  The data type, e.g OperandCode.FLOAT32.
     * @param {number[]} options.dimensions - The dimensions of the tensor. It should be nullptr for scalars.
     * @param {number} options.scale - Only for quantized tensors whose value is defined by (value - zeroPoint) * scale.
     * @param {number} options.zeroPoint - Only for quantized tensors whose value is defined by (value - zeroPoint) * scale.
     */

  }, {
    key: 'addOperand',
    value: function addOperand() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (this._completed) {
        throw new Error('addOperand cant modify after model finished');
      }

      if (!this._validateOperandOptions(options)) {
        throw new Error('Invalid options');
      }

      var operand = {
        type: options.type,
        dimensions: options.dimensions,
        scale: options.scale,
        zeroPoint: options.zeroPoint,
        numberOfConsumers: 0,
        lifetime: _Enums.OperandLifetime.TEMPORARY_VARIABLE,
        value: null
      };
      this._operands.push(operand);
      return _Enums.ResultCode.NO_ERROR;
    }

    /**
     * Sets an operand to a constant value.
     * 
     * @param {number} index - The index of the model operand we're setting.
     * @param {TypedArray} value - The typed array containing data.
     */

  }, {
    key: 'setOperandValue',
    value: function setOperandValue(index, value) {
      if (index > this._operands.length) {
        throw new Error('Invalid index ' + index);
      }
      var operand = this._operands[index];
      if (!this._validateOperandValue(value, operand)) {
        throw new Error('Invalid value ' + value);
      }
      if (utils.isTensor(operand.type)) {
        operand.lifetime = _Enums.OperandLifetime.CONSTANT_REFERENCE;
      } else {
        operand.lifetime = _Enums.OperandLifetime.CONSTANT_COPY;
      }
      operand.value = value;
      return _Enums.ResultCode.NO_ERROR;
    }

    /**
     * Add an operation to a model.
     * 
     * @param {number} type - The type of the operation.
     * @param {number[]} inputs - An array of indexes identifying the input operands.
     * @param {number[]} outputs - An array of indexes identifying the output operands.
     */

  }, {
    key: 'addOperation',
    value: function addOperation(type, inputs, outputs) {
      var _this = this;

      if (this._completed) {
        throw new Error('addOperation cant modify after model finished');
      }

      if (!this._validateOperationCode(type)) {
        throw new Error('Invalid operation code ' + type);
      }
      if (!this._validateOperandList(inputs)) {
        throw new Error('Invalid inputs ' + inputs);
      }
      if (!this._validateOperandList(outputs)) {
        throw new Error('Invalid outputs ' + outputs);
      }
      var op = {
        type: type,
        inputs: inputs,
        outputs: outputs
      };
      inputs.forEach(function (i) {
        _this._operands[i].numberOfConsumers += 1;
      });
      this._operations.push(op);
      return _Enums.ResultCode.NO_ERROR;
    }

    /**
     * Specfifies which operands will be the model's inputs and outputs.
     * 
     * @param {number[]} inputs - An array of indexes identifying the input operands.
     * @param {number[]} outputs - An array of indexes identifying the output operands.
     */

  }, {
    key: 'identifyInputsAndOutputs',
    value: function identifyInputsAndOutputs(inputs, outputs) {
      var _this2 = this;

      if (!this._validateOperandList(inputs)) {
        throw new Error('Invalid inputs ' + inputs);
      }
      if (!this._validateOperandList(outputs)) {
        throw new Error('Invalid outputs ' + outputs);
      }
      this._inputs = inputs;
      this._inputs.forEach(function (i) {
        _this2._operands[i].lifetime = _Enums.OperandLifetime.MODEL_INPUT;
      });
      this._outputs = outputs;
      this._outputs.forEach(function (i) {
        _this2._operands[i].lifetime = _Enums.OperandLifetime.MODEL_OUTPUT;
      });
      return _Enums.ResultCode.NO_ERROR;
    }

    // private methods

  }, {
    key: '_validateOperandOptions',
    value: function _validateOperandOptions(options) {
      var type = options.type;
      if (!utils.validateEnum(type, _Enums.OperandCode)) {
        console.error('Invalid type ' + options.type);
        return false;
      }
      if (type === _Enums.OperandCode.TENSOR_QUANT8_ASYMM) {
        if (typeof options.zeroPoint === 'undefined') {
          console.error('zeroPoint is undefined');
          return false;
        } else if (options.zeroPoint < 0 || options.zeroPoint > 255) {
          console.error('Invalid zeroPoint value ' + options.zeroPoint);
          return false;
        }
        if (options.scale < 0.0) {
          console.error('Invalid scale ' + options.scale);
          return false;
        }
      }
      return true;
    }
  }, {
    key: '_validateOperandValue',
    value: function _validateOperandValue(value, operand) {
      var type = operand.type;
      var arrayType = utils.operandCodeToTypedArrayMap.get(type);
      if (value instanceof arrayType) {
        var valueLength = value.length * value.BYTES_PER_ELEMENT;
        var neededLength = void 0;
        if (utils.isTensor(type)) {
          neededLength = utils.sizeOfTensorData(type, operand.dimensions);
        } else {
          neededLength = utils.sizeOfScalarData(type);
        }
        if (valueLength != neededLength) {
          console.error('Sets ' + valueLength + ' bytes when needing ' + neededLength);
          return false;
        } else {
          return true;
        }
      } else {
        console.error('Invalid value type ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)));
        return false;
      }
    }
  }, {
    key: '_validateOperationCode',
    value: function _validateOperationCode(type) {
      return utils.validateEnum(type, _Enums.OperationCode);
    }
  }, {
    key: '_validateOperandList',
    value: function _validateOperandList(list) {
      var _this3 = this;

      var ret = true;
      list.forEach(function (index) {
        if (index >= _this3._operands) ret = false;
      });
      return ret;
    }
  }, {
    key: '_sortIntoRunOrder',
    value: function _sortIntoRunOrder() {
      var _this4 = this;

      var opsReadyToRun = [];
      var runOrder = [];
      var unknownInputCount = new Array(this._operations.length);
      unknownInputCount.fill(0);
      var operandToOperations = new Map();
      this._operations.forEach(function (operation, operationIndex) {
        var inputs = operation.inputs;
        inputs.forEach(function (operandIndex) {
          var lifetime = _this4._operands[operandIndex].lifetime;
          if (lifetime === _Enums.OperandLifetime.TEMPORARY_VARIABLE || lifetime === _Enums.OperandLifetime.MODEL_OUTPUT) {
            unknownInputCount[operationIndex] += 1;
            if (!operandToOperations.has(operandIndex)) {
              operandToOperations.set(operandIndex, [operationIndex]);
            } else {
              var array = operandToOperations.get(operandIndex);
              array.push(operationIndex);
              operandToOperations.set(operandIndex, array);
            }
          }
        });
        if (unknownInputCount[operationIndex] === 0) {
          opsReadyToRun.push(operationIndex);
        }
      });

      while (opsReadyToRun.length > 0) {
        var opIndex = opsReadyToRun.pop();
        var operation = this._operations[opIndex];
        runOrder.push(operation);

        operation.outputs.forEach(function (operandIndex) {
          if (operandToOperations.has(operandIndex)) {
            operandToOperations.get(operandIndex).forEach(function (operationIndex) {
              unknownInputCount[operationIndex] -= 1;
              if (unknownInputCount[operationIndex] === 0) {
                opsReadyToRun.push(operationIndex);
              }
            });
          }
        });
      }

      this._operations = runOrder;
    }
  }]);

  return Model;
}();

exports.default = Model;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _PreparedModel = __webpack_require__(102);

var _PreparedModel2 = _interopRequireDefault(_PreparedModel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Device = function () {
  /**
   * Create an instance of Device.
   */
  function Device() {
    _classCallCheck(this, Device);
  }

  /**
   * Creates a prepared model for execution.
   * 
   * @param {Object} model - The model.
   * @returns {Object} The prepared model.
   */


  _createClass(Device, [{
    key: 'prepareModel',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(model) {
        var preparedModel;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                preparedModel = new _PreparedModel2.default();
                _context.next = 3;
                return preparedModel.prepare(model);

              case 3:
                return _context.abrupt('return', preparedModel);

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function prepareModel(_x) {
        return _ref.apply(this, arguments);
      }

      return prepareModel;
    }()
  }]);

  return Device;
}();

exports.default = Device;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _nn_ops = __webpack_require__(162);

var _nn_ops2 = _interopRequireDefault(_nn_ops);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

if (!global._babelPolyfill) {
  __webpack_require__(170);
}

var nn_ops = null;

exports.default = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt('return', new Promise(function (resolve) {
              if (nn_ops === null) {
                (0, _nn_ops2.default)().then(function (m) {
                  // https://github.com/kripken/emscripten/issues/5820#issuecomment-353605456
                  delete m['then'];
                  nn_ops = m;
                  resolve(nn_ops);
                });
              } else {
                resolve(nn_ops);
              }
            }));

          case 1:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  function getNNOpsInstance() {
    return _ref.apply(this, arguments);
  }

  return getNNOpsInstance;
}();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(57)))

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, __dirname, Buffer, module) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Module = function () {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  return function (Module) {
    Module = Module || {};

    var Module = typeof Module !== "undefined" ? Module : {};var moduleOverrides = {};var key;for (key in Module) {
      if (Module.hasOwnProperty(key)) {
        moduleOverrides[key] = Module[key];
      }
    }Module["arguments"] = [];Module["thisProgram"] = "./this.program";Module["quit"] = function (status, toThrow) {
      throw toThrow;
    };Module["preRun"] = [];Module["postRun"] = [];var ENVIRONMENT_IS_WEB = false;var ENVIRONMENT_IS_WORKER = false;var ENVIRONMENT_IS_NODE = false;var ENVIRONMENT_IS_SHELL = false;ENVIRONMENT_IS_WEB = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object";ENVIRONMENT_IS_WORKER = typeof importScripts === "function";ENVIRONMENT_IS_NODE = (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && "function" === "function" && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;var scriptDirectory = "";function locateFile(path) {
      if (Module["locateFile"]) {
        return Module["locateFile"](path, scriptDirectory);
      } else {
        return scriptDirectory + path;
      }
    }if (ENVIRONMENT_IS_NODE) {
      scriptDirectory = __dirname + "/";var nodeFS;var nodePath;Module["read"] = function shell_read(filename, binary) {
        var ret;ret = tryParseAsDataURI(filename);if (!ret) {
          if (!nodeFS) nodeFS = __webpack_require__(168);if (!nodePath) nodePath = __webpack_require__(169);filename = nodePath["normalize"](filename);ret = nodeFS["readFileSync"](filename);
        }return binary ? ret : ret.toString();
      };Module["readBinary"] = function readBinary(filename) {
        var ret = Module["read"](filename, true);if (!ret.buffer) {
          ret = new Uint8Array(ret);
        }assert(ret.buffer);return ret;
      };if (process["argv"].length > 1) {
        Module["thisProgram"] = process["argv"][1].replace(/\\/g, "/");
      }Module["arguments"] = process["argv"].slice(2);process["on"]("uncaughtException", function (ex) {
        if (!(ex instanceof ExitStatus)) {
          throw ex;
        }
      });process["on"]("unhandledRejection", function (reason, p) {
        process["exit"](1);
      });Module["quit"] = function (status) {
        process["exit"](status);
      };Module["inspect"] = function () {
        return "[Emscripten Module object]";
      };
    } else if (ENVIRONMENT_IS_SHELL) {
      if (typeof read != "undefined") {
        Module["read"] = function shell_read(f) {
          var data = tryParseAsDataURI(f);if (data) {
            return intArrayToString(data);
          }return read(f);
        };
      }Module["readBinary"] = function readBinary(f) {
        var data;data = tryParseAsDataURI(f);if (data) {
          return data;
        }if (typeof readbuffer === "function") {
          return new Uint8Array(readbuffer(f));
        }data = read(f, "binary");assert((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object");return data;
      };if (typeof scriptArgs != "undefined") {
        Module["arguments"] = scriptArgs;
      } else if (typeof arguments != "undefined") {
        Module["arguments"] = arguments;
      }if (typeof quit === "function") {
        Module["quit"] = function (status) {
          quit(status);
        };
      }
    } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WEB) {
        if (document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
      } else {
        scriptDirectory = self.location.href;
      }if (_scriptDir) {
        scriptDirectory = _scriptDir;
      }if (scriptDirectory.indexOf("blob:") !== 0) {
        scriptDirectory = scriptDirectory.split("/").slice(0, -1).join("/") + "/";
      } else {
        scriptDirectory = "";
      }Module["read"] = function shell_read(url) {
        try {
          var xhr = new XMLHttpRequest();xhr.open("GET", url, false);xhr.send(null);return xhr.responseText;
        } catch (err) {
          var data = tryParseAsDataURI(url);if (data) {
            return intArrayToString(data);
          }throw err;
        }
      };if (ENVIRONMENT_IS_WORKER) {
        Module["readBinary"] = function readBinary(url) {
          try {
            var xhr = new XMLHttpRequest();xhr.open("GET", url, false);xhr.responseType = "arraybuffer";xhr.send(null);return new Uint8Array(xhr.response);
          } catch (err) {
            var data = tryParseAsDataURI(url);if (data) {
              return data;
            }throw err;
          }
        };
      }Module["readAsync"] = function readAsync(url, onload, onerror) {
        var xhr = new XMLHttpRequest();xhr.open("GET", url, true);xhr.responseType = "arraybuffer";xhr.onload = function xhr_onload() {
          if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
            onload(xhr.response);return;
          }var data = tryParseAsDataURI(url);if (data) {
            onload(data.buffer);return;
          }onerror();
        };xhr.onerror = onerror;xhr.send(null);
      };Module["setWindowTitle"] = function (title) {
        document.title = title;
      };
    } else {}var out = Module["print"] || (typeof console !== "undefined" ? console.log.bind(console) : typeof print !== "undefined" ? print : null);var err = Module["printErr"] || (typeof printErr !== "undefined" ? printErr : typeof console !== "undefined" && console.warn.bind(console) || out);for (key in moduleOverrides) {
      if (moduleOverrides.hasOwnProperty(key)) {
        Module[key] = moduleOverrides[key];
      }
    }moduleOverrides = undefined;var STACK_ALIGN = 16;function staticAlloc(size) {
      var ret = STATICTOP;STATICTOP = STATICTOP + size + 15 & -16;return ret;
    }function dynamicAlloc(size) {
      var ret = HEAP32[DYNAMICTOP_PTR >> 2];var end = ret + size + 15 & -16;HEAP32[DYNAMICTOP_PTR >> 2] = end;if (end >= TOTAL_MEMORY) {
        var success = enlargeMemory();if (!success) {
          HEAP32[DYNAMICTOP_PTR >> 2] = ret;return 0;
        }
      }return ret;
    }function alignMemory(size, factor) {
      if (!factor) factor = STACK_ALIGN;var ret = size = Math.ceil(size / factor) * factor;return ret;
    }function getNativeTypeSize(type) {
      switch (type) {case "i1":case "i8":
          return 1;case "i16":
          return 2;case "i32":
          return 4;case "i64":
          return 8;case "float":
          return 4;case "double":
          return 8;default:
          {
            if (type[type.length - 1] === "*") {
              return 4;
            } else if (type[0] === "i") {
              var bits = parseInt(type.substr(1));assert(bits % 8 === 0);return bits / 8;
            } else {
              return 0;
            }
          }}
    }function warnOnce(text) {
      if (!warnOnce.shown) warnOnce.shown = {};if (!warnOnce.shown[text]) {
        warnOnce.shown[text] = 1;err(text);
      }
    }var asm2wasmImports = { "f64-rem": function f64Rem(x, y) {
        return x % y;
      }, "debugger": function _debugger() {
        debugger;
      } };var jsCallStartIndex = 1;var functionPointers = new Array(0);var funcWrappers = {};function dynCall(sig, ptr, args) {
      if (args && args.length) {
        return Module["dynCall_" + sig].apply(null, [ptr].concat(args));
      } else {
        return Module["dynCall_" + sig].call(null, ptr);
      }
    }var GLOBAL_BASE = 1024;var ABORT = 0;var EXITSTATUS = 0;function assert(condition, text) {
      if (!condition) {
        abort("Assertion failed: " + text);
      }
    }function getCFunc(ident) {
      var func = Module["_" + ident];assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");return func;
    }var JSfuncs = { "stackSave": function stackSave() {
        _stackSave();
      }, "stackRestore": function stackRestore() {
        _stackRestore();
      }, "arrayToC": function arrayToC(arr) {
        var ret = stackAlloc(arr.length);writeArrayToMemory(arr, ret);return ret;
      }, "stringToC": function stringToC(str) {
        var ret = 0;if (str !== null && str !== undefined && str !== 0) {
          var len = (str.length << 2) + 1;ret = stackAlloc(len);stringToUTF8(str, ret, len);
        }return ret;
      } };var toC = { "string": JSfuncs["stringToC"], "array": JSfuncs["arrayToC"] };function ccall(ident, returnType, argTypes, args, opts) {
      function convertReturnValue(ret) {
        if (returnType === "string") return Pointer_stringify(ret);if (returnType === "boolean") return Boolean(ret);return ret;
      }var func = getCFunc(ident);var cArgs = [];var stack = 0;if (args) {
        for (var i = 0; i < args.length; i++) {
          var converter = toC[argTypes[i]];if (converter) {
            if (stack === 0) stack = _stackSave();cArgs[i] = converter(args[i]);
          } else {
            cArgs[i] = args[i];
          }
        }
      }var ret = func.apply(null, cArgs);ret = convertReturnValue(ret);if (stack !== 0) _stackRestore(stack);return ret;
    }function setValue(ptr, value, type, noSafe) {
      type = type || "i8";if (type.charAt(type.length - 1) === "*") type = "i32";switch (type) {case "i1":
          HEAP8[ptr >> 0] = value;break;case "i8":
          HEAP8[ptr >> 0] = value;break;case "i16":
          HEAP16[ptr >> 1] = value;break;case "i32":
          HEAP32[ptr >> 2] = value;break;case "i64":
          tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];break;case "float":
          HEAPF32[ptr >> 2] = value;break;case "double":
          HEAPF64[ptr >> 3] = value;break;default:
          abort("invalid type for setValue: " + type);}
    }var ALLOC_STATIC = 2;var ALLOC_NONE = 4;function Pointer_stringify(ptr, length) {
      if (length === 0 || !ptr) return "";var hasUtf = 0;var t;var i = 0;while (1) {
        t = HEAPU8[ptr + i >> 0];hasUtf |= t;if (t == 0 && !length) break;i++;if (length && i == length) break;
      }if (!length) length = i;var ret = "";if (hasUtf < 128) {
        var MAX_CHUNK = 1024;var curr;while (length > 0) {
          curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));ret = ret ? ret + curr : curr;ptr += MAX_CHUNK;length -= MAX_CHUNK;
        }return ret;
      }return UTF8ToString(ptr);
    }var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;function UTF8ArrayToString(u8Array, idx) {
      var endPtr = idx;while (u8Array[endPtr]) {
        ++endPtr;
      }if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
        return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
      } else {
        var u0, u1, u2, u3, u4, u5;var str = "";while (1) {
          u0 = u8Array[idx++];if (!u0) return str;if (!(u0 & 128)) {
            str += String.fromCharCode(u0);continue;
          }u1 = u8Array[idx++] & 63;if ((u0 & 224) == 192) {
            str += String.fromCharCode((u0 & 31) << 6 | u1);continue;
          }u2 = u8Array[idx++] & 63;if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            u3 = u8Array[idx++] & 63;if ((u0 & 248) == 240) {
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | u3;
            } else {
              u4 = u8Array[idx++] & 63;if ((u0 & 252) == 248) {
                u0 = (u0 & 3) << 24 | u1 << 18 | u2 << 12 | u3 << 6 | u4;
              } else {
                u5 = u8Array[idx++] & 63;u0 = (u0 & 1) << 30 | u1 << 24 | u2 << 18 | u3 << 12 | u4 << 6 | u5;
              }
            }
          }if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
      }
    }function UTF8ToString(ptr) {
      return UTF8ArrayToString(HEAPU8, ptr);
    }function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
      if (!(maxBytesToWrite > 0)) return 0;var startIdx = outIdx;var endIdx = outIdx + maxBytesToWrite - 1;for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }if (u <= 127) {
          if (outIdx >= endIdx) break;outU8Array[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;outU8Array[outIdx++] = 192 | u >> 6;outU8Array[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;outU8Array[outIdx++] = 224 | u >> 12;outU8Array[outIdx++] = 128 | u >> 6 & 63;outU8Array[outIdx++] = 128 | u & 63;
        } else if (u <= 2097151) {
          if (outIdx + 3 >= endIdx) break;outU8Array[outIdx++] = 240 | u >> 18;outU8Array[outIdx++] = 128 | u >> 12 & 63;outU8Array[outIdx++] = 128 | u >> 6 & 63;outU8Array[outIdx++] = 128 | u & 63;
        } else if (u <= 67108863) {
          if (outIdx + 4 >= endIdx) break;outU8Array[outIdx++] = 248 | u >> 24;outU8Array[outIdx++] = 128 | u >> 18 & 63;outU8Array[outIdx++] = 128 | u >> 12 & 63;outU8Array[outIdx++] = 128 | u >> 6 & 63;outU8Array[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 5 >= endIdx) break;outU8Array[outIdx++] = 252 | u >> 30;outU8Array[outIdx++] = 128 | u >> 24 & 63;outU8Array[outIdx++] = 128 | u >> 18 & 63;outU8Array[outIdx++] = 128 | u >> 12 & 63;outU8Array[outIdx++] = 128 | u >> 6 & 63;outU8Array[outIdx++] = 128 | u & 63;
        }
      }outU8Array[outIdx] = 0;return outIdx - startIdx;
    }function stringToUTF8(str, outPtr, maxBytesToWrite) {
      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
    }function lengthBytesUTF8(str) {
      var len = 0;for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);if (u >= 55296 && u <= 57343) u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;if (u <= 127) {
          ++len;
        } else if (u <= 2047) {
          len += 2;
        } else if (u <= 65535) {
          len += 3;
        } else if (u <= 2097151) {
          len += 4;
        } else if (u <= 67108863) {
          len += 5;
        } else {
          len += 6;
        }
      }return len;
    }var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : undefined;function allocateUTF8(str) {
      var size = lengthBytesUTF8(str) + 1;var ret = _malloc(size);if (ret) stringToUTF8Array(str, HEAP8, ret, size);return ret;
    }function demangle(func) {
      return func;
    }function demangleAll(text) {
      var regex = /__Z[\w\d_]+/g;return text.replace(regex, function (x) {
        var y = demangle(x);return x === y ? x : x + " [" + y + "]";
      });
    }function jsStackTrace() {
      var err = new Error();if (!err.stack) {
        try {
          throw new Error(0);
        } catch (e) {
          err = e;
        }if (!err.stack) {
          return "(no stack trace available)";
        }
      }return err.stack.toString();
    }var WASM_PAGE_SIZE = 65536;var ASMJS_PAGE_SIZE = 16777216;var MIN_TOTAL_MEMORY = 16777216;function alignUp(x, multiple) {
      if (x % multiple > 0) {
        x += multiple - x % multiple;
      }return x;
    }var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;function updateGlobalBuffer(buf) {
      Module["buffer"] = buffer = buf;
    }function updateGlobalBufferViews() {
      Module["HEAP8"] = HEAP8 = new Int8Array(buffer);Module["HEAP16"] = HEAP16 = new Int16Array(buffer);Module["HEAP32"] = HEAP32 = new Int32Array(buffer);Module["HEAPU8"] = HEAPU8 = new Uint8Array(buffer);Module["HEAPU16"] = HEAPU16 = new Uint16Array(buffer);Module["HEAPU32"] = HEAPU32 = new Uint32Array(buffer);Module["HEAPF32"] = HEAPF32 = new Float32Array(buffer);Module["HEAPF64"] = HEAPF64 = new Float64Array(buffer);
    }var STATIC_BASE, STATICTOP, staticSealed;var STACK_BASE, STACKTOP, STACK_MAX;var DYNAMIC_BASE, DYNAMICTOP_PTR;STATIC_BASE = STATICTOP = STACK_BASE = STACKTOP = STACK_MAX = DYNAMIC_BASE = DYNAMICTOP_PTR = 0;staticSealed = false;function abortOnCannotGrowMemory() {
      abort("Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value " + TOTAL_MEMORY + ", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ");
    }if (!Module["reallocBuffer"]) Module["reallocBuffer"] = function (size) {
      var ret;try {
        if (ArrayBuffer.transfer) {
          ret = ArrayBuffer.transfer(buffer, size);
        } else {
          var oldHEAP8 = HEAP8;ret = new ArrayBuffer(size);var temp = new Int8Array(ret);temp.set(oldHEAP8);
        }
      } catch (e) {
        return false;
      }var success = _emscripten_replace_memory(ret);if (!success) return false;return ret;
    };function enlargeMemory() {
      var PAGE_MULTIPLE = Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;var LIMIT = 2147483648 - PAGE_MULTIPLE;if (HEAP32[DYNAMICTOP_PTR >> 2] > LIMIT) {
        return false;
      }var OLD_TOTAL_MEMORY = TOTAL_MEMORY;TOTAL_MEMORY = Math.max(TOTAL_MEMORY, MIN_TOTAL_MEMORY);while (TOTAL_MEMORY < HEAP32[DYNAMICTOP_PTR >> 2]) {
        if (TOTAL_MEMORY <= 536870912) {
          TOTAL_MEMORY = alignUp(2 * TOTAL_MEMORY, PAGE_MULTIPLE);
        } else {
          TOTAL_MEMORY = Math.min(alignUp((3 * TOTAL_MEMORY + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
        }
      }var replacement = Module["reallocBuffer"](TOTAL_MEMORY);if (!replacement || replacement.byteLength != TOTAL_MEMORY) {
        TOTAL_MEMORY = OLD_TOTAL_MEMORY;return false;
      }updateGlobalBuffer(replacement);updateGlobalBufferViews();return true;
    }var byteLength;try {
      byteLength = Function.prototype.call.bind(Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get);byteLength(new ArrayBuffer(4));
    } catch (e) {
      byteLength = function byteLength(buffer) {
        return buffer.byteLength;
      };
    }var TOTAL_STACK = Module["TOTAL_STACK"] || 5242880;var TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 16777216;if (TOTAL_MEMORY < TOTAL_STACK) err("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + TOTAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")");if (Module["buffer"]) {
      buffer = Module["buffer"];
    } else {
      if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) === "object" && typeof WebAssembly.Memory === "function") {
        Module["wasmMemory"] = new WebAssembly.Memory({ "initial": TOTAL_MEMORY / WASM_PAGE_SIZE });buffer = Module["wasmMemory"].buffer;
      } else {
        buffer = new ArrayBuffer(TOTAL_MEMORY);
      }Module["buffer"] = buffer;
    }updateGlobalBufferViews();function getTotalMemory() {
      return TOTAL_MEMORY;
    }function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();if (typeof callback == "function") {
          callback();continue;
        }var func = callback.func;if (typeof func === "number") {
          if (callback.arg === undefined) {
            Module["dynCall_v"](func);
          } else {
            Module["dynCall_vi"](func, callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }var __ATPRERUN__ = [];var __ATINIT__ = [];var __ATMAIN__ = [];var __ATEXIT__ = [];var __ATPOSTRUN__ = [];var runtimeInitialized = false;var runtimeExited = false;function preRun() {
      if (Module["preRun"]) {
        if (typeof Module["preRun"] == "function") Module["preRun"] = [Module["preRun"]];while (Module["preRun"].length) {
          addOnPreRun(Module["preRun"].shift());
        }
      }callRuntimeCallbacks(__ATPRERUN__);
    }function ensureInitRuntime() {
      if (runtimeInitialized) return;runtimeInitialized = true;callRuntimeCallbacks(__ATINIT__);
    }function preMain() {
      callRuntimeCallbacks(__ATMAIN__);
    }function exitRuntime() {
      callRuntimeCallbacks(__ATEXIT__);runtimeExited = true;
    }function postRun() {
      if (Module["postRun"]) {
        if (typeof Module["postRun"] == "function") Module["postRun"] = [Module["postRun"]];while (Module["postRun"].length) {
          addOnPostRun(Module["postRun"].shift());
        }
      }callRuntimeCallbacks(__ATPOSTRUN__);
    }function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }function writeArrayToMemory(array, buffer) {
      HEAP8.set(array, buffer);
    }function writeAsciiToMemory(str, buffer, dontAddNull) {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer++ >> 0] = str.charCodeAt(i);
      }if (!dontAddNull) HEAP8[buffer >> 0] = 0;
    }var Math_abs = Math.abs;var Math_ceil = Math.ceil;var Math_floor = Math.floor;var Math_min = Math.min;var runDependencies = 0;var runDependencyWatcher = null;var dependenciesFulfilled = null;function addRunDependency(id) {
      runDependencies++;if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }
    }function removeRunDependency(id) {
      runDependencies--;if (Module["monitorRunDependencies"]) {
        Module["monitorRunDependencies"](runDependencies);
      }if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);runDependencyWatcher = null;
        }if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;dependenciesFulfilled = null;callback();
        }
      }
    }Module["preloadedImages"] = {};Module["preloadedAudios"] = {};var dataURIPrefix = "data:application/octet-stream;base64,";function isDataURI(filename) {
      return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
    }function integrateWasmJS() {
      var wasmTextFile = "";var wasmBinaryFile = "data:application/octet-stream;base64,AGFzbQEAAAABlwVBYAABf2ABfwF/YAJ/fwBgA39/fwBgA39/fwF/YAJ/fwF/YAp/f39/f39/f39/AX9gBH9/f38Bf2AHf39/f39/fwF/YBB/f39/f39/f39/f39/f39/AX9gD39/f39/f39/f39/f39/fwF/YA1/f39/f39/f39/f39/AX9gBX9/fX9/AX9gBX9/f39/AX9gCH9/f39/f39/AX9gAX8AYAZ/f39/f38Bf2AAAGAEf39/fwBgBn9/f39/fwBgBX9/f39/AGACf38BfWAGf39/fX9/AX9gBX9/f398AX9gBn9/f39/fAF/YAt/f39/f39/f39/fwF/YA5/f39/f39/f39/f39/fwF/YBF/f39/f39/f39/f39/f39/fwF/YAV/f39/fgF/YAN/f30AYAV/f35/fwBgDX9/f39/f39/f39/f38AYAh/f39/f39/fwBgCn9/f39/f39/f38AYAN/f3wAYAN/f38BfGAFf399f38AYA5/f39/f39/f39/f39/fwBgEn9/f39/f39/f39/f39/f39/fwBgDH9/f39/f39/f31/fwBgB39/f39/f38AYAx/f39/f39/fX9/f38AYAd/f39/f399AGADfn9/AX9gAn5/AX9gBn98f39/fwF/YAJ8fwF8YAR/f39+AX5gBX9/f39/AXxgBn9/f39/fwF8YAJ/fwF+YAJ8fAF8YAR/f39/AX5gA39/fgBgAn1/AX1gAX0BfWAMf39/f39/f39/f39/AX9gA39/fwF9YA9/f39/f39/f39/f39/f38AYAd/f39/f398AX9gCX9/f39/f39/fwF/YBJ/f39/f39/f39/f39/f39/f38Bf2AGf39/fH9/AX9gB39/f398f38Bf2AEf39/fAACsws8A2VudgZtZW1vcnkCAIACA2VudgV0YWJsZQFwAZoFmgUDZW52CXRhYmxlQmFzZQN/AANlbnYORFlOQU1JQ1RPUF9QVFIDfwADZW52CFNUQUNLVE9QA38AA2VudglTVEFDS19NQVgDfwAGZ2xvYmFsA05hTgN8AAZnbG9iYWwISW5maW5pdHkDfAADZW52BWFib3J0AA8DZW52DWVubGFyZ2VNZW1vcnkAAANlbnYOZ2V0VG90YWxNZW1vcnkAAANlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkAAANlbnYZX19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbgABA2VudgxfX19jeGFfdGhyb3cAAwNlbnYZX19fY3hhX3VuY2F1Z2h0X2V4Y2VwdGlvbgAAA2VudgdfX19sb2NrAA8DZW52C19fX21hcF9maWxlAAUDZW52C19fX3NldEVyck5vAA8DZW52DV9fX3N5c2NhbGwxNDAABQNlbnYNX19fc3lzY2FsbDE0NQAFA2Vudg1fX19zeXNjYWxsMTQ2AAUDZW52DF9fX3N5c2NhbGw1NAAFA2VudgtfX19zeXNjYWxsNgAFA2VudgxfX19zeXNjYWxsOTEABQNlbnYJX19fdW5sb2NrAA8DZW52Fl9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wAFANlbnYXX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MAHwNlbnYjX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IAEwNlbnYgX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24AIANlbnYgX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfcHJvcGVydHkAIQNlbnYaX19lbWJpbmRfcmVnaXN0ZXJfY29uc3RhbnQAIgNlbnYXX19lbWJpbmRfcmVnaXN0ZXJfZW12YWwAAgNlbnYXX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQAAwNlbnYaX19lbWJpbmRfcmVnaXN0ZXJfZnVuY3Rpb24AEwNlbnYZX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcgAUA2Vudh1fX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldwADA2VudhxfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nAAIDZW52HV9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nAAMDZW52Fl9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQAAgNlbnYKX19lbXZhbF9hcwAjA2VudhhfX2VtdmFsX2NhbGxfdm9pZF9tZXRob2QAEgNlbnYOX19lbXZhbF9kZWNyZWYADwNlbnYZX19lbXZhbF9nZXRfbWV0aG9kX2NhbGxlcgAFA2VudhRfX2VtdmFsX2dldF9wcm9wZXJ0eQAFA2Vudg5fX2VtdmFsX2luY3JlZgAPA2VudhFfX2VtdmFsX25ld19hcnJheQAAA2VudhNfX2VtdmFsX25ld19jc3RyaW5nAAEDZW52F19fZW12YWxfcnVuX2Rlc3RydWN0b3JzAA8DZW52El9fZW12YWxfdGFrZV92YWx1ZQAFA2VudgZfYWJvcnQAEQNlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwAEA2VudgdfZ2V0ZW52AAEDZW52El9sbHZtX3N0YWNrcmVzdG9yZQAPA2Vudg9fbGx2bV9zdGFja3NhdmUAAANlbnYSX3B0aHJlYWRfY29uZF93YWl0AAUDZW52FF9wdGhyZWFkX2dldHNwZWNpZmljAAEDZW52E19wdGhyZWFkX2tleV9jcmVhdGUABQNlbnYNX3B0aHJlYWRfb25jZQAFA2VudhRfcHRocmVhZF9zZXRzcGVjaWZpYwAFA2Vudgtfc3RyZnRpbWVfbAANA9UF0wUBAQAPAgIPAAECAgICBAUFBgYGBQcECAgECQoLCwwHDQ8PDwIBDwABBQMFAxUdBQMCAwEDBAIDAwEPAAMSBQQCBwMCAwEDBAMBDwMSBwcEGQ0OGwkaFhARDAMEJAMCAxANCiUlJSUmEgMSEicoKCkqCR8fHx8LISEhIQILISEhIQgTExMTCBMTExMEBQEBBQQFBQYGBgUEBwUFEQ8BAQ8FBQIBBAQBBAQBBQEBBwQNAwEDKywsBBQFLS4EBQQFBAEELwIvAQEBIyMwMTIuMzMuMwEFNDQRBQEBBAQEBAU1BwQHBAcFBA0HBwUFAQA2BQQPAQUEAQENBAQ3DwIPDw8CBB4SBAEBBQQBBA8PBAEEBA8PDw8PDw8PAgIFAg8PAQIPBREPAwMDAwIBBAUCBAUCAQEFBQIBAQUFDw8PDRIEAwINEgQDAhAQEBAQEBAQEBAFDwYABwEPAw8PEBQ4IxIQIxA5EAEDNBAHEAcQNBAHCBAQEBAQEBAQEBAGEBQ4EBAQBAMEEBAQEAgNDRwNHBcXDQ0EBAcoEigNDRwNHBcXDRAoKAEQEBAQEA4BAQEBAQEBERERExMOExMTExMTFBMTExMTFA0QEBAQEA4BAQEBAQEBERERExMOExMTExMTFBMTExMTFA0PDwgTDwgTAQICAgECCAgZBCEDAwgIGQQhGBAhOhgQIToEExMODg0NAQ0ODg4BDQ4ODQENAQ8PDg4NDQ4ODw8PDw8FBAUEBQcEDQ8PAQECAgIPDwEBAgICBAcHBwUEBQQFBwQNEgICAwICAhICAg8CAgIAAgAPAwECAgIDAwQPBCACBQMEKAQCAwMEIAIFKAQCABEAAgQTFBIEEhIUBxMUEhEPAQ8PAQ8EBBMUEhITFAEPBAEBBAQEAQUYOwg8OAo9DwIDEhQTKBUAAQUMBBYHFw0YEAgOBhkLGgoJGxwRDwIdAxIUEx4jPj8IQCgGKQh/ASMBC38BIwILfwEjAwt/AUEAC38BQQALfAEjBAt8ASMFC38BQQALB8QIOhBfX2dyb3dXYXNtTWVtb3J5ADQSX19HTE9CQUxfX0lfMDAwMTAxANYCGF9fR0xPQkFMX19zdWJfSV9iaW5kX2NwcADOARtfX0dMT0JBTF9fc3ViX0lfYmluZGluZ19jcHAAiwEcX19HTE9CQUxfX3N1Yl9JX2lvc3RyZWFtX2NwcACJAhpfX1pTdDE4dW5jYXVnaHRfZXhjZXB0aW9udgCrBRBfX19jeGFfY2FuX2NhdGNoAMwFFl9fX2N4YV9pc19wb2ludGVyX3R5cGUAzQUOX19fZ2V0VHlwZU5hbWUA0AEFX2ZyZWUA0gEPX2xsdm1fYnN3YXBfaTMyAM4FB19tYWxsb2MA0QEHX21lbWNweQDPBQhfbWVtbW92ZQDQBQdfbWVtc2V0ANEFF19wdGhyZWFkX2NvbmRfYnJvYWRjYXN0AKgCE19wdGhyZWFkX211dGV4X2xvY2sAqAIVX3B0aHJlYWRfbXV0ZXhfdW5sb2NrAKgCBV9zYnJrANIFC2R5bkNhbGxfZmlpAIEGCWR5bkNhbGxfaQBbCmR5bkNhbGxfaWkA0wULZHluQ2FsbF9paWkAggEOZHluQ2FsbF9paWlmaWkAggYMZHluQ2FsbF9paWlpAIEBD2R5bkNhbGxfaWlpaWZpaQCDBg1keW5DYWxsX2lpaWlpAIQBDmR5bkNhbGxfaWlpaWlkANQFDmR5bkNhbGxfaWlpaWlpAIoBD2R5bkNhbGxfaWlpaWlpZADVBQ9keW5DYWxsX2lpaWlpaWkA1gUQZHluQ2FsbF9paWlpaWlpaQCFARFkeW5DYWxsX2lpaWlpaWlpaQDXBRNkeW5DYWxsX2lpaWlpaWlpaWlpAIMBFGR5bkNhbGxfaWlpaWlpaWlpaWlpANgFFmR5bkNhbGxfaWlpaWlpaWlp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IQIjB0EQaiQHIAAQJSIENgIAIAFBCGoiBigCACABQQRqIgcoAgAiAUYEQCACJAcPCyACIQUDQEHwzOMALAAARQRAQfDM4wAQygUEQEGQ0uMAQQJB2NQAECI2AgALC0GQ0uMAKAIAIQggBSABIANBAnRqKAIANgIAIAggBEGY9wAgBRAgIANBAWoiAyAGKAIAIAcoAgAiAWtBAnVJBEAgACgCACEEDAELCyACJAcLvwEBBX8jByECIwdBEGokByACIgYgASgCACIBNgIAIAEQJCACQQRqIgMgAhBAIABBBGoiBSgCACIEBH8gAEEIaiIBIAQ2AgAgBBDSASAAQQxqIgBBADYCACABQQA2AgAgBUEANgIAIAAFIABBCGohASAAQQxqCyEEIAUgAygCADYCACABIANBBGoiASgCADYCACAEIANBCGoiACgCADYCACAAQQA2AgAgAUEANgIAIANBADYCACAGKAIAECEgAiQHC/cBAgp/AXwjByEEIwdBEGokByABKAIAQev6ABAmIgIQIyEDIAIQISADQaDUACAEIgIQHyEMIAIoAgAQJyAMqyEHIAMQISAAQQA2AgAgAEEEaiIIQQA2AgAgAEEIaiIKQQA2AgAgB0UEQCAEJAcPCyAEQQhqIQlBACEDA0AgASgCACEFIAIgAzYCACAFQaDUACACECgiBhAjIQUgBhAhIAVBoNQAIAIQHyEMIAIoAgAQJyAJIAyrIgs2AgAgCCgCACIGIAooAgBJBEAgBiALNgIAIAggBkEEajYCAAUgACAJEFcLIAUQISADQQFqIgMgB0kNAAsgBCQHCwsAIAAgASACEMMBCwkAIAAgARDEAQsJACAAIAEQxQELGQAgACABIAIgAyAEIAUgBiAHIAggCRDHAQsZACAAIAEgAiADIAQgBSAGIAcgCCAJEMYBCxkAIAAgASACIAMgBCAFIAYgByAIIAkQyAELCQAgACABEMkBCw0AIAAgASACIAMQywELCwAgACABIAIQygELEwAgACABIAIgAyAEIAUgBhC0AQsTACAAIAEgAiADIAQgBSAGELkBCwsAIAAgASACEL4BCyUAIAAgASACIAMgBCAFIAYgByAIIAkgCiALIAwgDSAOIA8QpAELIwAgACABIAIgAyAEIAUgBiAHIAggCSAKIAsgDCANIA4QlQELHwAgACABIAIgAyAE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QQRqIgQgAkECdBCRBSIDNgIAIAAgAzYCACAGIAMgAkECdGo2AgAgCEEATARADwsgAyABIAgQzwUaIAQgAyAIQQJ2QQJ0ajYCAAs0AQJ/IABBBGoiAygCACICIAAoAghGBEAgACABEFcFIAIgASgCADYCACADIAJBBGo2AgALC0MBA38gAEEEaiIEKAIAIAAoAgAiBWtBAnUiAyABSQRAIAAgASADayACEHsPCyADIAFNBEAPCyAEIAUgAUECdGo2AgALEAAgACgCBCAAKAIAa0ECdQtSAQF/IwchAyMHQRBqJAcgASgCBCABKAIAIgFrQQJ1IAJNBEAgAEEBNgIAIAMkBw8LIAMgASACQQJ0aigCADYCACAAQajUACADECg2AgAgAyQHCxcAIAAoAgAgAUECdGogAigCADYCAEEBC9wCAQp/IABBBGoiCSgCACIDIQUgAEEIaiILKAIAIgQgA2tBAnUgAU8EQCABIQMgBSEAA0AgACACKAIANgIAIABBBGohACADQX9qIgMNAAsgCSAFIAFBAnRqNgIADwsgAyAAKAIAIgZrIgpBAnUiBSABaiIDQf////8DSwRAECkLIAQgBmsiBEECdUH/////AUkhByAEQQF1IgQgA08EQCAEIQMLIAcEfyADBUH/////AwsiBARAIARB/////wNLBEBBCBAEIgNB8voAEJMFIANBrPYANgIAIANBmNMAQd0AEAUFIARBAnQQkQUiDCEICwsgASEDIAggBUECdGoiByEFA0AgBSACKAIANgIAIAVBBGohBSADQX9qIgMNAAsgCkEASgRAIAwgBiAKEM8FGgsgACAINgIAIAkgByABQQJ0ajYCACALIAggBEECdGo2AgAgBkUEQA8LIAYQ0gELBgBBkMYACyYBAX8gAEUEQA8LIAAoAgAiAQRAIAAgATYCBCABENIBCyAAENIBC1UBAn8jByEDIwdBEGokByAAKAIAIQQgASAAKAIEIgFBAXVqIQAgAUEBcQRAIAAoAgAgBGooAgAhBAsgAyACNgIAIAAgAyAEQT9xQagEahECACADJAcLVwECfyMHIQQjB0EQaiQHIAAoAgAhBSABIAAoAgQiAUEBdWohACABQQFxBEAgACgCACAFaigCACEFCyAEIAM2AgAgACACIAQgBUEPcUHqBGoRAwAgBCQHCzcBAX8jByEEIwdB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oMMAQcDDABCLBDYCAAwTCyATIAEoAgA2AgAgFCACKAIANgIAIAogEygCADYCACAIIBQoAgA2AgAgASAAIAogCCADIAQgBUHAwwBB4MMAEIsENgIADBILIBUgAigCADYCACAIIBUoAgA2AgAgACAFQQhqIAEgCCAEIAkQjQQMEQsgFiACKAIANgIAIAggFigCADYCACAAIAVBCGogASAIIAQgCRCOBAwQCyAXIAIoAgA2AgAgCCAXKAIANgIAIAAgBUEcaiABIAggBCAJEI8EDA8LIBggAigCADYCACAIIBgoAgA2AgAgACAFQRBqIAEgCCAEIAkQkAQMDgsgGSACKAIANgIAIAggGSgCADYCACAAIAVBBGogASAIIAQgCRCRBAwNCyAaIAIoAgA2AgAgCCAaKAIANgIAIAAgASAIIAQgCRCSBAwMCyAbIAIoAgA2AgAgCCAbKAIANgIAIAAgBUEIaiABIAggBCAJEJMEDAsLIBwgASgCADYCACAdIAIoAgA2AgAgCiAcKAIANgIAIAggHSgCADYCACABIAAgCiAIIAMgBCAFQeDDAEGMxAAQiwQ2AgAMCgsgHiABKAIANgIAIB8gAigCADYCACAKIB4oAgA2AgAgCCAfKAIANgIAIAEgACAKIAggAyAEIAVBkMQAQaTEABCLBDYCAAwJCyAgIAIoAgA2AgAgCCAgKAIANgIAIAAgBSABIAggBCAJEJQEDAgLICEgASgCADYCACAiIAIoAgA2AgAgCiAhKAIANgIAIAggIigCADYCACABIAAgCiAIIAMgBCAFQbDEAEHQxAAQiwQ2AgAMBwsgIyACKAIANgIAIAggIygCADYCACAAIAVBGGogASAIIAQgCRCVBAwGCyAAKAIAKAIUIQYgJCABKAIANgIAICUgAigCADYCACAKICQoAgA2AgAgCCAlKAIANgIAIAAgCiAIIAMgBCAFIAZBP3FBpgJqERAADAYLIABBCGoiBiAGKAIAKAIYQf8AcUEGahEBACEGICYgASgCADYCACAnIAIoAgA2AgAgBiwACyIJQQBIIQsgBigCACECIAYoAgQhDCAJQf8BcSEJIAogJigCADYCACAIICcoAgA2AgAgASAAIAogCCADIAQgBSALBH8gAgUgBiICCyACIAsEfyAMBSAJC0ECdGoQiwQ2AgAMBAsgKCACKAIANgIA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ADcCACADQQA2AgggAyABIAIQ8wIgAywACyICQQBIIQEgAygCACEEIAMoAgQhBiACQf8BcSECIAAgAQR/IAQFIAMLIAEEfyAGBSACCxCgBRogAxCYBQwCCyAHIAVrIApJBEAgACAHIAUgCmogB2sgBSAFQQBBABCfBQsgAiAFIAZraiEHIAksAABBAEgEfyAAKAIABSAACyIEIAVqIQYDQCABIAJHBEAgBiABEPQCIAZBAWohBiABQQFqIQEMAQsLIANBADoAACAEIAdqIAMQ9AIgBSAKaiEBIAksAABBAEgEQCAAIAE2AgQFIAkgAToAAAsLCyALJAcgAAujDAEDfyMHIQwjB0EQaiQHIAxBDGohCyAMIQogCSAABH8gCyABQYDh4wAQhAMiASABKAIAKAIsQT9xQagEahECACACIAsoAgA2AAAgCiABIAEoAgAoAiBBP3FBqARqEQIAIAhBC2oiACwAAEEASAR/IAgoAgAhACALQQA6AAAgACALEPQCIAhBADYCBCAIBSALQQA6AAAgCCALEPQCIABBADoAACAICyEAIAhBABCbBSAAIAopAgA3AgAgACAKKAIINgIIQQAhAANAIABBA0cEQCAKIABBAnRqQQA2AgAgAEEBaiEADAELCyAKEJgFIAogASABKAIAKAIcQT9xQagEahECACAHQQtqIgAsAABBAEgEfyAHKAIAIQAgC0EAOgAAIAAgCxD0AiAHQQA2AgQgBwUgC0EAOgAAIAcgCxD0AiAAQQA6AAAgBwshACAHQQAQmwUgACAKKQIANwIAIAAgCigCCDYCCEEAIQADQCAAQQNHBEAgCiAAQQJ0akEANgIAIABBAWohAAwBCwsgChCYBSADIAEgASgCACgCDEH/AHFBBmoRAQA6AAAgBCABIAEoAgAoAhBB/wBxQQZqEQEAOgAAIAogASABKAIAKAIUQT9xQagEahECACAFQQtqIgAsAABBAEgEfyAFKAIAIQAgC0EAOgAAIAAgCxD0AiAFQQA2AgQgBQUgC0EAOgAAIAUgCxD0AiAAQQA6AAAgBQshACAFQQAQmwUgACAKKQIANwIAIAAgCigCCDYCCEEAIQADQCAAQQNHBEAgCiAAQQJ0akEANgIAIABBAWohAAwBCwsgChCYBSAKIAEgASgCACgCGEE/cUGoBGoRAgAgBkELaiIALAAAQQBIBH8gBigCACEAIAtBADoAACAAIAsQ9AIgBkEANgIEIAYFIAtBADoAACAGIAsQ9AIgAEEAOgAAIAYLIQAgBkEAEJsFIAAgCikCADcCACAAIAooAgg2AghBACEAA0AgAEEDRwRAIAogAEECdGpBADYCACAAQQFqIQAMAQsLIAoQmAUgASABKAIAKAIkQf8AcUEGahEBAAUgCyABQfjg4wAQhAMiASABKAIAKAIsQT9xQagEahECACACIAsoAgA2AAAgCiABIAEoAgAoAiBBP3FBqARqEQIAIAhBC2oiACwAAEEASAR/IAgoAgAhACALQQA6AAAgACALEPQCIAhBADYCBCAIBSALQQA6AAAgCCALEPQCIABBADoAACAICyEAIAhBABCbBSAAIAopAgA3AgAgACAKKAIINgIIQQAhAANAIABBA0cEQCAKIABBAnRqQQA2AgAgAEEBaiEADAELCyAKEJgFIAogASABKAIAKAIcQT9xQagEahECACAHQQtqIgAsAABBAEgEfyAHKAIAIQAgC0EAOgAAIAAgCxD0AiAHQQA2AgQgBwUgC0EAOgAAIAcgCxD0AiAAQQA6AAAgBwshACAHQQAQmwUgACAKKQIANwIAIAAgCigCCDYCCEEAIQADQCAAQQNHBEAgCiAAQQJ0akEANgIAIABBAWohAAwBCwsgChCYBSADIAEgASgCACgCDEH/AHFBBmoRAQA6AAAgBCABIAEoAgAoAhBB/wBxQQZqEQEAOgAAIAogASABKAIAKAIUQT9xQagEahECACAFQQtqIgAsAABBAEgEfyAFKAIAIQAgC0EAOgAAIAAgCxD0AiAFQQA2AgQgBQUgC0EAOgAAIAUgCxD0AiAAQQA6AAAgBQshACAFQQAQmwUgACAKKQIANwIAIAAgCigCCDYCCEEAIQADQCAAQQNHBEAgCiAAQQJ0akEANgIAIABBAWohAAwBCwsgChCYBSAKIAEgASgCACgCGEE/cUGoBGoRAgAgBkELaiIALAAAQQBIBH8gBigCACEAIAtBADoAACAAIAsQ9AIgBkEANgIEIAYFIAtBADoAACAGIAsQ9AIgAEEAOgAAIAYLIQAgBkEAEJsFIAAgCikCADcCACAAIAooAgg2AghBACEAA0AgAEEDRwRAIAogAEECdGpBADYCACAAQQFqIQAMAQsLIAoQmAUgASABKAIA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aiEADAELCyAKEJgFIAogASABKAIAKAIcQT9xQagEahECACAHQQtqIgAsAABBAEgEQCAHKAIAIQAgC0EANgIAIAAgCxD5AiAHQQA2AgQFIAtBADYCACAHIAsQ+QIgAEEAOgAACyAHQQAQpgUgByAKKQIANwIAIAcgCigCCDYCCEEAIQADQCAAQQNHBEAgCiAAQQJ0akEANgIAIABBAWohAAwBCwsgChCYBSADIAEgASgCACgCDEH/AHFBBmoRAQA2AgAgBCABIAEoAgAoAhBB/wBxQQZqEQEANgIAIAogASABKAIAKAIUQT9xQagEahECACAFQQtqIgAsAABBAEgEfyAFKAIAIQAgC0EAOgAAIAAgCxD0AiAFQQA2AgQgBQUgC0EAOgAAIAUgCxD0AiAAQQA6AAAgBQshACAFQQAQmwUgACAKKQIANwIAIAAgCigCCDYCCEEAIQADQCAAQQNHBEAgCiAAQQJ0akEANgIAIABBAWohAAwBCwsgChCYBSAKIAEgASgCACgCGEE/cUGoBGoRAgAgBkELaiIALAAAQQBIBEAgBigCACEAIAtBADYCACAAIAsQ+QIgBkEANgIEBSALQQA2AgAgBiALEPkCIABBADoAAAsgBkEAEKYFIAYgCikCADcCACAGIAooAgg2AghBACEAA0AgAEEDRwRAIAogAEECdGpBADYCACAAQQFqIQAMAQsLIAoQmAUgASABKAIAKAIkQf8AcUEGahEBAAUgCyABQYjh4wAQhAMiASABKAIAKAIsQT9xQagEahECACACIAsoAgA2AAAgCiABIAEoAgAoAiBBP3FBqARqEQIAIAhBC2oiACwAAEEASARAIAgoAgAhACALQQA2AgAgACALEPkCIAhBADYCBAUgC0EANgIAIAggCxD5AiAAQQA6AAALIAhBABCmBSAIIAopAgA3AgAgCCAKKAIINgIIQQAhAANAIABBA0cEQCAKIABBAnRqQQA2AgAgAEEBaiEADAELCyAKEJgFIAogASABKAIAKAIcQT9xQagEahECACAHQQtqIgAsAABBAEgEQCAHKAIAIQAgC0EANgIAIAAgCxD5AiAHQQA2AgQFIAtBADYCACAHIAsQ+QIgAEEAOgAACyAHQQAQpgUgByAKKQIANwIAIAcgCigCCDYCCEEAIQADQCAAQQNHBEAgCiAAQQJ0akEANgIAIABBAWohAAwBCwsgChCYBSADIAEgASgCACgCDEH/AHFBBmoRAQA2AgAgBCABIAEoAgAoAhBB/wBxQQZqEQEANgIAIAogASABKAIAKAIUQT9xQagEahECACAFQQtqIgAsAABBAEgEfyAFKAIAIQAgC0EAOgAAIAAgCxD0AiAFQQA2AgQgBQUgC0EAOgAAIAUgCxD0AiAAQQA6AAAgBQshACAFQQAQmwUgACAKKQIANwIAIAAgCigCCDYCCEEAIQADQCAAQQNHBEAgCiAAQQJ0akEANgIAIABBAWohAAwBCwsgChCYBSAKIAEgASgCACgCGEE/cUGoBGoRAgAgBkELaiIALAAAQQBIBEAgBigCACEAIAtBADYCACAAIAsQ+QIgBkEANgIEBSALQQA2AgAgBiALEPkCIABBADoAAAsgBkEAEKYFIAYgCikCADcCACAGIAooAgg2AghBACEAA0AgAEEDRwRAIAogAEECdGpBADYCACAAQQFqIQAMAQsLIAoQmAUgASABKAIAKAIkQf8AcUEGahEBAAsiADYCACAMJAcL4gYBFX8jByEGIwdBoANqJAcgBkHIAmohCCAGQfAAaiEAIAZBkANqIgogBkHgAWoiBzYCACAGQdACaiIPIAU5AwAgB0HkAEGdpgEgDxCVAiIHQeMASwRAEIcDIQAgCCAFOQMAIAogAEGdpgEgCBDIAyEHIAooAgAiAEUEQBApCyAHENEBIgghCSAIBEAgCCENIAchCyAJIRIgACETBRApCwUgACENIAchCwsgBkGMA2oiECADEM8CIBBBmN/jABCEAyIUIAooAgAiACAAIAtqIA0gFCgCACgCIEEPcUHqAWoRBwAaIAsEfyAKKAIALAAAQS1GBUEACyEVIAZBmANqIRYgBkGVA2ohFyAGQZQDaiEYIAZB9AJqIQggBkHoAmohCSAGQeQCaiEHIAZBgANqIgpCADcCACAKQQA2AghBACEAA0AgAEEDRwRAIAogAEECdGpBADYCACAAQQFqIQAMAQsLIAhCADcCACAIQQA2AghBACEAA0AgAEEDRwRAIAggAEECdGpBADYCACAAQQFqIQAMAQsLIAlCADcCACAJQQA2AghBACEAA0AgAEEDRwRAIAkgAEECdGpBADYCACAAQQFqIQAMAQsLIAIgFSAQIBYgFyAYIAogCCAJIAcQtQQgCyAHKAIAIg5KBH8gCyAOa0EBdCEHIAkoAgQhAiAJLAALIgBB/wFxIQwgAEEATgRAIAwhAgsgCCgCBCEAIAgsAAsiDEH/AXEhGiAMQQBOBEAgGiEACyAOQQFqIAdqBSAJKAIEIQIgCSwACyIAQf8BcSEHIABBAE4EQCAHIQILIAgoAgQhACAILAALIgdB/wFxIQwgB0EATgRAIAwhAAsgDkECagshDCAGIQcgDCACaiAAaiIAQeQASwRAIAAQ0QEiACECIAAEQCAAIREgAiEZBRApCwUgByERCyARIAZB4AJqIgAgBkHYAmoiAiADKAIEIA0gDSALaiAUIBUgFiAXLAAAIBgsAAAgCiAIIAkgDhC2BCAGQdwCaiILIAEoAgA2AgAgACgCACEAIAIoAgAhASAPIAsoAgA2AgAgDyARIAAgASADIAQQkwEhACAZBEAgGRDSAQsgCRCYBSAIEJgFIAoQmAUgEBCFAyASBEAgEhDSAQsgEwRAIBMQ0gELIAYkByAAC6UGARJ/IwchByMHQbABaiQHIAdBmAFqIg4gAxDPAiAOQZjf4wAQhAMhDyAFQQtqIgssAAAiBkEASCEAIAVBBGoiDCgCACEIIAZB/wFxIQYgAAR/IAgFIAYLBH8gBSgCACEGIAAEfyAGBSAFCy0AACAPQS0gDygCACgCHEEfcUGGAWoRBQBB/wFxRgVBAAshEiAHQaQBaiETIAdBoQFqIRQgB0GgAWohFSAHQYABaiEIIAdB9ABqIQkgB0HwAGohBiAHQYwBaiINQgA3AgAgDUEANgIIQQAhAANAIABBA0cEQCANIABBAnRqQQA2AgAgAEEBaiEADAELCyAIQgA3AgAgCEEANgIIQQAhAANAIABBA0cEQCAIIABBAnRqQQA2AgAgAEEBaiEADAELCyAJQgA3AgAgCUEANgIIQQAhAANAIABBA0cEQCAJIABBAnRqQQA2AgAgAEEBaiEADAELCyACIBIgDiATIBQgFSANIAggCSAGELUEIAssAAAiAEEASCEWIAwoAgAhCyAAQf8BcSEAIBYEfyALBSAAIgsLIAYoAgAiDEoEfyALIAxrQQF0IQYgCSgCBCECIAksAAsiAEH/AXEhCiAAQQBOBEAgCiECCyAIKAIEIQAgCCwACyIKQf8BcSEQIApBAE4EQCAQIQALIAxBAWogBmoFIAkoAgQhAiAJLAALIgBB/wFxIQYgAEEATgRAIAYhAgsgCCgCBCEAIAgsAAsiBkH/AXEhCiAGQQBOBEAgCiEACyAMQQJqCyEKIAchBiAKIAJqIABqIgBB5ABLBEAgABDRASIAIQIgAARAIAAhESACIRcFECkLBSAGIRELIAdBnAFqIQIgB0HkAGohBiAFKAIAIQAgESAHQewAaiIKIAdB6ABqIhAgAygCBCAWBH8gAAUgBSIACyAAIAtqIA8gEiATIBQsAAAgFSwAACANIAggCSAMELYEIAYgASgCADYCACAKKAIAIQAgECgCACEBIAIgBigCADYCACACIBEgACABIAMgBBCTASEAIBcEQCAXENIBCyAJEJgFIAgQmAUgDRCYBSAOEIUDIAckByAAC/8MAQN/IwchDCMHQRBqJAcgDEEMaiEKIAwhCyAJIAAEfyACQYDh4wAQhAMhACABBH8gCiAAIAAoAgAoAixBP3FBqARqEQIAIAMgCigCADYAACALIAAgACgCACgCIEE/cUGoBGoRAgAgCEELaiIBLAAAQQBIBH8gCCgCACEBIApBADoAACABIAoQ9AIgCEEANgIEIAgFIApBADoAACAIIAoQ9AIgAUEAOgAAIAgLIQEgCEEAEJsFIAEgCykCADcCACABIAsoAgg2AghBACEBA0AgAUEDRwRAIAsgAUECdGpBADYCACABQQFqIQEMAQsLIAsQmAUgAAUgCiAAIAAoAgAoAihBP3FBqARqEQIAIAMgCigCADYAACALIAAgACgCACgCHEE/cUGoBGoRAgAgCEELaiIBLAAAQQBIBH8gCCgCACEBIApBADoAACABIAoQ9AIgCEEANgIEIAgFIApBADoAACAIIAoQ9AIgAUEAOgAAIAgLIQEgCEEAEJsFIAEgCykCADcCACABIAsoAgg2AghBACEBA0AgAUEDRwRAIAsgAUECdGpBADYCACABQQFqIQEMAQsLIAsQmAUgAAshASAEIAAgACgCACgCDEH/AHFBBmoRAQA6AAAgBSAAIAAoAgAoAhBB/wBxQQZqEQEAOgAAIAsgACABKAIAKAIUQT9xQagEahECACAGQQtqIgIsAABBAEgEfyAGKAIAIQIgCkEAOgAAIAIgChD0AiAGQQA2AgQgBgUgCkEAOgAAIAYgChD0AiACQQA6AAAgBgshAiAGQQAQmwUgAiALKQIANwIAIAIgCygCCDYCCEEAIQIDQCACQQNHBEAgCyACQQJ0akEANgIAIAJBAWohAgwBCwsgCxCYBSALIAAgASgCACgCGEE/cUGoBGoRAgAgB0ELaiIBLAAAQQBIBH8gBygCACEBIApBADoAACABIAoQ9AIgB0EANgIEIAcFIApBADoAACAHIAoQ9AIgAUEAOgAAIAcLIQEgB0EAEJsFIAEgCykCADcCACABIAsoAgg2AghBACEBA0AgAUEDRwRAIAsgAUECdGpBADYCACABQQFqIQEMAQsLIAsQmAUgACAAKAIAKAIkQf8AcUEGahEBAAUgAkH44OMAEIQDIQAgAQR/IAogACAAKAIAKAIsQT9xQagEahECACADIAooAgA2AAAgCyAAIAAoAgAoAiBBP3FBqARqEQIAIAhBC2oiASwAAEEASAR/IAgoAgAhASAKQQA6AAAgASAKEPQCIAhBADYCBCAIBSAKQQA6AAAgCCAKEPQCIAFBADoAACAICyEBIAhBABCbBSABIAspAgA3AgAgASALKAIINgIIQQAhAQNAIAFBA0cEQCALIAFBAnRqQQA2AgAgAUEBaiEBDAELCyALEJgFIAAFIAogACAAKAIAKAIoQT9xQagEahECACADIAooAgA2AAAgCyAAIAAoAgAoAhxBP3FBqARqEQIAIAhBC2oiASwAAEEASAR/IAgoAgAhASAKQQA6AAAgASAKEPQCIAhBADYCBCAIBSAKQQA6AAAgCCAKEPQCIAFBADoAACAICyEBIAhBABCbBSABIAspAgA3AgAgASALKAIINgIIQQAhAQNAIAFBA0cEQCALIAFBAnRqQQA2AgAgAUEBaiEBDAELCyALEJgFIAALIQEgBCAAIAAoAgAoAgxB/wBxQQZqEQEAOgAAIAUgACAAKAIAKAIQQf8AcUEGahEBADoAACALIAAgASgCACgCFEE/cUGoBGoRAgAgBkELaiICLAAAQQBIBH8gBigCACECIApBADoAACACIAoQ9AIgBkEANgIEIAYFIApBADoAACAGIAoQ9AIgAkEAOgAAIAYLIQIgBkEAEJsFIAIgCykCADcCACACIAsoAgg2AghBACECA0AgAkEDRwRAIAsgAkECdGpBADYCACACQQFqIQIMAQsLIAsQmAUgCyAAIAEoAgAoAhhBP3FBqARqEQIAIAdBC2oiASwAAEEASAR/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IQYgCSgCBCECIAksAAsiAEH/AXEhCiAAQQBOBEAgCiECCyAIKAIEIQAgCCwACyIKQf8BcSEQIApBAE4EQCAQIQALIAxBAWogBmoFIAkoAgQhAiAJLAALIgBB/wFxIQYgAEEATgRAIAYhAgsgCCgCBCEAIAgsAAsiBkH/AXEhCiAGQQBOBEAgCiEACyAMQQJqCyEKIAchBiAKIAJqIABqIgBB5ABLBEAgAEECdBDRASIAIQIgAARAIAAhESACIRcFECkLBSAGIRELIAdB0ANqIQIgB0GQA2ohBiAFKAIAIQAgESAHQZgDaiIKIAdBlANqIhAgAygCBCAWBH8gAAUgBSIACyAAIAtBAnRqIA8gEiATIBQoAgAgFSgCACANIAggCSAMELoEIAYgASgCADYCACAKKAIAIQAgECgCACEBIAIgBigCADYCACACIBEgACABIAMgBBDUAyEAIBcEQCAXENIBCyAJEJgFIAgQmAUgDRCYBSAOEIUDIAckByAAC88MAQN/IwchDCMHQRBqJAcgDEEMaiEKIAwhCyAJIAAEfyACQZDh4wAQhAMhAiABBEAgCiACIAIoAgAoAixBP3FBqARqEQIAIAMgCigCADYAACALIAIgAigCACgCIEE/cUGoBGoRAgAgCEELaiIALAAAQQBIBEAgCCgCACEAIApBADYCACAAIAoQ+QIgCEEANgIEBSAKQQA2AgAgCCAKEPkCIABBADoAAAsgCEEAEKYFIAggCykCADcCACAIIAsoAgg2AghBACEAA0AgAEEDRwRAIAsgAEECdGpBADYCACAAQQFqIQAMAQsLIAsQmAUFIAogAiACKAIAKAIoQT9xQagEahECACADIAooAgA2AAAgCyACIAIoAgAoAhxBP3FBqARqEQIAIAhBC2oiACwAAEEASARAIAgoAgAhACAKQQA2AgAgACAKEPkCIAhBADYCBAUgCkEANgIAIAggChD5AiAAQQA6AAALIAhBABCmBSAIIAspAgA3AgAgCCALKAIINgIIQQAhAANAIABBA0cEQCALIABBAnRqQQA2AgAgAEEBaiEADAELCyALEJgFCyAEIAIgAigCACgCDEH/AHFBBmoRAQA2AgAgBSACIAIoAgAoAhBB/wBxQQZqEQEANgIAIAsgAiACKAIAKAIUQT9xQagEahECACAGQQtqIgAsAABBAEgEfyAGKAIAIQAgCkEAOgAAIAAgChD0AiAGQQA2AgQgBgUgCkEAOgAAIAYgChD0AiAAQQA6AAAgBgshACAGQQAQmwUgACALKQIANwIAIAAgCygCCDYCCEEAIQADQCAAQQNHBEAgCyAAQQJ0akEANgIAIABBAWohAAwBCwsgCxCYBSALIAIgAigCACgCGEE/cUGoBGoRAgAgB0ELaiIALAAAQQBIBEAgBygCACEAIApBADYCACAAIAoQ+QIgB0EANgIEBSAKQQA2AgAgByAKEPkCIABBADoAAAsgB0EAEKYFIAcgCykCADcCACAHIAsoAgg2AghBACEAA0AgAEEDRwRAIAsgAEECdGpBADYCACAAQQFqIQAMAQsLIAsQmAUgAiACKAIAKAIkQf8AcUEGahEBAAUgAkGI4eMAEIQDIQIgAQRAIAogAiACKAIAKAIsQT9xQagEahECACADIAooAgA2AAAgCyACIAIoAgAoAiBBP3FBqARqEQIAIAhBC2oiACwAAEEASARAIAgoAgAhACAKQQA2AgAgACAKEPkCIAhBADYCBAUgCkEANgIAIAggChD5AiAAQQA6AAALIAhBABCmBSAIIAspAgA3AgAgCCALKAIINgIIQQAhAANAIABBA0cEQCALIABBAnRqQQA2AgAgAEEBaiEADAELCyALEJgFBSAKIAIgAigCACgCKEE/cUGoBGoRAgAgAyAKKAIANgAAIAsgAiACKAIAKAIcQT9xQagEahECACAIQQtqIgAsAABBAEgEQCAIKAIAIQAgCkEANgIAIAAgChD5AiAIQQA2AgQFIApBADYCACAIIAoQ+QIgAEEAOgAACyAIQQAQpgUgCCALKQIANwIAIAggCygCCDYCCEEAIQADQCAAQQNHBEAgCyAAQQJ0akEANgIAIABBAWohAAwBCwsgCxCYBQsgBCACIAIoAgAoAgxB/wBxQQZqEQEANgIAIAUgAiACKAIAKAIQQf8AcUEGahEBADYCACALIAIgAigCACgCFEE/cUGoBGoRAgAgBkELaiIALAAAQQBIBH8gBigCACEAIApBADoAACAAIAoQ9AIgBkEANgIEIAYFIApBADoAACAGIAoQ9AIgAEEAOgAAIAYLIQAgBkEAEJsFIAAgCykCADcCACAAIAsoAgg2AghBACEAA0AgAEEDRwRAIAsgAEECdGpBADYCACAAQQFq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DAAgABDXBCAAENIBCy4BAX8gACgCACIBBEAgACABNgIEIAEgAEEQakYEQCAAQQA6AIABBSABENIBCwsLJAEBfyAAQdDxADYCACAAKAIIIgEEQCAALAAMBEAgARDSAQsLCwwAIAAQ2gQgABDSAQsrACABQRh0QRh1QX9KBH9B8NsAKAIAIAFB/wFxQQJ0aigCAEH/AXEFIAELC0UAA0AgASACRwRAIAEsAAAiAEF/SgRAQfDbACgCACABLAAAQQJ0aigCAEH/AXEhAAsgASAAOgAAIAFBAWohAQwBCwsgAgstACABQRh0QRh1QX9KBH9B+NsAKAIAIAFBGHRBGHVBAnRqKAIAQf8BcQUgAQsLRQADQCABIAJHBEAgASwAACIAQX9KBEBB+NsAKAIAIAEsAABBAnRqKAIAQf8BcSEACyABIAA6AAAgAUEBaiEBDAELCyACCwQAIAELKQADQCABIAJHBEAgAyABLAAAOgAAIANBAWohAyABQQFqIQEMAQsLIAILFQAgAUEYdEEYdUF/SgR/IAEFIAILCzYAA0AgASACRwRAIAQgASwAACIAQX9KBH8gAAUgAws6AAAgBEEBaiEEIAFBAWohAQwBCwsgAgsTACAAQYTyADYCACAAQQxqEJgFCwwAIAAQ5AQgABDSAQsHACAALAAICwcAIAAsAAkLDAAgACABQQxqEJQFCyAAIABCADcCACAAQQA2AgggAEHeqgFB3qoBENwBEJUFCyAAIABCADcCACAAQQA2AgggAEHYqgFB2KoBENwBEJUFCxMAIABBrPIANgIAIABBEGoQmAULDAAgABDrBCAAENIBCwcAIAAoAggLBwAgACgCDAsMACAAIAFBEGoQlAULIAAgAEIANwIAIABBADYCCCAAQeTyAEHk8gAQhQIQogULIAAgAEIANwIAIABBADYCCCAAQczyAEHM8gAQhQIQogULKQAgAkGAAUkEf0H02wAoAgAgAkEBdGouAQAgAXFB//8DcUEARwVBAAsLRgADQCABIAJHBEAgAyABKAIAQYABSQR/QfTbACgCACABKAIAQQF0ai8BAAVBAAs7AQAgA0ECaiEDIAFBBGohAQwBCwsgAgtKAANAAkAgAiADRgRAIAMhAgwBCyACKAIAQYABSQRAQfTbACgCACACKAIAQQF0ai4BACABcUH//wNxDQELIAJBBGoh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IQEDQCABIAJHBEAgAyABQXxqIgE2AgAMAQsLIAAoAgAiAQRAIAEgACgCECIARgRAIABBADoAcAUgARDSAQsLC1sAIAAgAUF/ajYCBCAAQazyADYCACAAQS42AgggAEEsNgIMIABBEGoiAUIANwIAIAFBADYCCEEAIQADQCAAQQNHBEAgASAAQQJ0akEANgIAIABBAWohAAwBCwsLWwAgACABQX9qNgIEIABBhPIANgIAIABBLjoACCAAQSw6AAkgAEEMaiIBQgA3AgAgAUEANgIIQQAhAANAIABBA0cEQCABIABBAnRqQQA2AgAgAEEBaiEADAELCwtXAQF/Qf////8DIAFJBEAQKQsgACABQR1JIABBgAFqIgIsAABFcQR/IAJBAToAACAAQRBqBSABQQJ0EJEFCyICNgIEIAAgAjYCACAAIAIgAUECdGo2AggLRQBB4NDjACwAAEUEQEHg0OMAEMoFBEBB6NDjAEEBEP8EQejh4wBB6NDjADYCAEHs4eMAQejh4wA2AgALC0Hs4eMAKAIACyAAIAAgASgCACIANgIAIABBBGoiACAAKAIAQQFqNgIACzkAQYjS4wAsAABFBEBBiNLjABDKBQRAQfDh4wAQjAUQjQVB9OHjAEHw4eMANgIACwtB9OHjACgCAAshACAAEI4FKAIAIgA2AgAgAEEEaiIAIAAoAgBBAWo2AgALRQADQCAAKAIAQQFGBEBBlOLjAEH44eMAEC4aDAELCyAAKAIARQRAIABBATYCACABIAJB/wBxQagDahEPACAAQX82AgALC0oBAX8gAEUEQEEBIQALA38CfyAAENEBIgEEQCABDAELQczi4wBBzOLjACgCACIBNgIAIAEEfyABQQNxQaQDahERAAwCBUEACwsLCz8BAn8gARDcASIDQQ1qEJEFIgIgAzYCACACIAM2AgQgAkEANgIIIAJBDGoiAiABIANBAWoQzwUaIAAgAjYCAAsVACAAQZj2ADYCACAAQQRqIAEQkgULPwAgAEIANwIAIABBADYCCCABLAALQQBIBEAgACABKAIAIAEoAgQQlQUFIAAgASkCADcCACAAIAEoAgg2AggLC3UBA38jByEDIwdBEGokByACQW9LBEAQKQsgAkELSQRAIAAgAjoACwUgACACQRBqQXBxIgQQkQUiBTYCACAAIARBgICAgHhyNgII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AUH/AXEhAkEKCyEBIANBAWohBQJAAkAgAiABRgRAIAAgAUEBIAEgAUEAQQAQnwUgBCwAAEEASA0BBSAHDQELIAQgAkEBajoAAAwBCyAAKAIAIQEgACACQQFqNgIEIAEhAAsgACACaiIAIAYQ9AIgBUEAOgAAIABBAWogBRD0AiADJAcLjgEBA38jByEDIwdBEGokByACQe////8DSwRAECkLIAJBAkkEQCAAIAI6AAsgACEEBSACQQRqQXxxIgVB/////wNLBEAQKQUgACAFQQJ0EJEFIgQ2AgAgACAFQYCAgIB4cjYCCCAAIAI2AgQLCyAEIAEgAhDDAhogA0EANgIAIAQgAkECdGogAxD5AiADJAcLowEBBH8jByEFIwdBEGokByABQe////8DSwRAECkLIAFBAkkEQCAAIAE6AAsgACEEBSABQQRqQXxxIgNB/////wNLBEAQKQUgACADQQJ0EJEFIgQ2AgAgACADQYCAgIB4cjYCCCAAIAE2AgQLCyAFIQMgBCEAIAEiBgR/IAAgAiAGEKsCGiAABSAACxogA0EANgIAIAQgAUECdGogAxD5AiAFJAcLygEBBn8jByEHIwdBEGokByAHIQUgAEEIaiIDQQNqIggsAAAiBEEASCIGBH8gAygCAEH/////B3FBf2oFQQELIgMgAkkEQCAAIAMgAiADayAGBH8gACgCBAUgBEH/AXELIgVBACAFIAIgARClBQUgBgR/IAAoAgAFIAALIgMhBCACIgYEfyAEIAEgBhCsAhogBAUgBAsaIAVBADYCACADIAJBAnRqIAUQ+QIgCCwAAEEASARAIAAgAjYCBAUgCCACOgAACwsgByQHIAALtQIBBX8jByEJIwdBEGokB0Hu////AyABayACSQRAECkLIABBCGoiDCwAA0EASAR/IAAoAgAFIAALIQogAUHn////AUkEQCACIAFqIgIgAUEBdCIISQR/IAgFIAIiCAtBBGpBfHEhAiAIQQJJBH9BAiICBSACC0H/////A0sEQBApBSACIQsLBUHv////AyELCyALQQJ0EJEFIQggBARAIAggCiAEEMMCGgsgBgRAIAggBEECdGogByAGEMMCGgsgAyAFayIDIARrIgIEQCAIIARBAnRqIAZBAnRqIAogBEECdGogBUECdGogAhDDAhoLIAFBAUcEQCAKENIBCyAA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IAkgCiALIAwgDSAOIABBAXFBkgNqERoACzAAIAEgAiADIAQgBSAGIAcgCCAJIAogCyAMIA0gDiAPIBAgESAAQQFxQZoDahEbAAsOACAAQQNxQaQDahERAAsRACABIABB/wBxQagDahEPAAsSACABIAIgAEE/cUGoBGoRAgALFAAgASACIAMgAEEPcUHqBGoRAwALFgAgASACIAMgBCAAQQ9xQfoEahESAAsYACABIAIgAyAEIAUgAEEDcUGKBWoRFAALGgAgASACIAMgBCAFIAYgAEEHcUGOBWoREwALCwBBABAAQwAAAAALCABBARAAQQALCABBAhAAQQALCABBAxAAQQALCABBBBAAQQALCABBBRAAQQALCABBBhAAQQALCABBBxAAQQALCABBCBAAQQALCABBCRAAQQALCABBChAAQQALCABBCxAAQQALCABBDBAAQQALCABBDRAAQQALCABBDhAAQQALCABBDxAAQQALCABBEBAAQQALCABBERAAQQALCABBEhAAQQALCABBExAAQQALCABBFBAAQQALCABBFRAAQQALBgBBFhAACwYAQRcQAAsGAEEYEAALBgBBGRAACwYAQRoQAAsGAEEbEAALBgBBHBAACwYAQR0QAAsGAEEeEAALDwAgASACIABBAXERFQC7CxkAIAEgAiADtiAEIAUgAEEBcUGmAWoRDAALGwAgASACIAMgBLYgBSAGIABBAXFB6AFqERYACyAAIAEgAiADIAQgBa0gBq1CIIaEIABBB3FBnANqERwACxUAIAEgAiADtiAAQQFxQegEahEdAAsgACABIAIgA60gBK1CIIaEIAUgBiAAQQNxQZYFahEeAAsLv44BOABBgAgLwgHYKQAA2CIAADAqAABwIgAA6CkAAMAiAAAwKgAAcCIAANgpAAAoIwAAMCoAACgqAADoKQAAECMAADAqAAAoKgAA6CkAAHAiAABwIgAAcCIAAOgpAABwIgAAcCIAAHAiAAAYKgAAGCoAABgqAAAYKgAAGCoAABgqAABwIgAAAAAAAOgpAABwIgAAGCoAABgqAAAYKgAAGCoAABgqAAAYKgAAGCoAABgqAABwIgAAAAAAAOgpAABwIgAAKCoAABgqAABwIgBB0AkLggHoKQAAwCIAABgqAABwIgAA6CkAACgqAABwIgAAKCoAAHAiAAAYKgAAKCoAAHAiAADoKQAAKCoAACgqAABwIgAA6CkAACgqAABwIgAAKCoAAHAiAAAoKgAAcCIAABgqAAAYKgAAGCoAABgqAAAYKgAAGCoAABgqAAAYKgAAKCoAAHAiAEHgCgsSaWlpaWlpaWlpaWlpaWlpaWlpAEGACwtR6CkAACgqAABwIgAAKCoAAHAiAAAoKgAAcCIAABgqAAAYKgAAGCoAABgqAAAYKgAAGCoAABgqAAAoKgAAcCIAAGlpaWlpaWlpaWlpaWlpaWlpAEHgCws26CkAACgqAABwIgAAGCoAABgqAAAYKgAAGCoAABgqAAAYKgAAGCoAABgqAAAYKgAAKCoAAHAiAEGgDAsmaWlpaWlpaWlpaWlpaWlpAOgpAAAoKgAAcCIAADgqAAAoKgAAcCIAQdAMCxLoKQAAKCoAAHAiAAAoKgAAcCIAQfAMCxboKQAAECMAAMAiAAAYKgAAKCoAAHAiAEGQDQsVBAAAAAQAAAAEAAAABAAAAAQAAAABAEGwDQsU3hIElQAAAAD///////////////8AQdANC+gBAgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzTAAAAABEACgAREREAAAAABQAAAAAAAAkAAAAACwBBwA8LIREADwoREREDCgcAARMJCwsAAAkGCwAACwAGEQAAABEREQBB8Q8LAQsAQfoPCxgRAAoKERERAAoAAAIACQsAAAAJAAsAAAsAQasQCwEMAEG3EAsVDAAAAAAMAAAAAAkMAAAAAAAMAAAMAEHlEAsBDgBB8RALFQ0AAAAEDQAAAAAJDgAAAAAADgAADgBBnxELARAAQasRCx4PAAAAAA8AAAAACRAAAAAAABAAABAAABIAAAASEhIAQeIRCw4SAAAAEhISAAAAAAAACQBBkxILAQsAQZ8SCxUKAAAAAAoAAAAACQsAAAAAAAsAAAsAQc0SCwEMAEHZEgt+DAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGVCEiGQ0BAgMRSxwMEAQLHRIeJ2hub3BxYiAFBg8TFBUaCBYHKCQXGAkKDhsfJSODgn0mKis8PT4/Q0dKTVhZWltcXV5fYGFjZGVmZ2lqa2xyc3R5ent8AEHgEwuREElsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAAAAAAAA/////////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP///////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AQYAkCyAKAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCAlpgAAOH1BQBBpCgL+QMBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAADYAAAA3AAAAOAAAADkAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAQQAAAEIAAABDAAAARAAAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAAE4AAABPAAAAUAAAAFEAAABSAAAAUwAAAFQAAABVAAAAVgAAAFcAAABYAAAAWQAAAFoAAABbAAAAXAAAAF0AAABeAAAAXwAAAGAAAABBAAAAQgAAAEMAAABEAAAARQAAAEYAAABHAAAASAAAAEkAAABKAAAASwAAAEwAAABNAAAATgAAAE8AAABQAAAAUQAAAFIAAABTAAAAVAAAAFUAAABWAAAAVwAAAFgAAABZAAAAWgAAAHsAAAB8AAAAfQAAAH4AAAB/AEGgMgv/AQIAAgACAAIAAgACAAIAAgACAAMgAiACIAIgAiACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgABYATABMAEwATABMAEwATABMAEwATABMAEwATABMAEwAjYCNgI2AjYCNgI2AjYCNgI2AjYBMAEwATABMAEwATABMAI1QjVCNUI1QjVCNUIxQjFCMUIxQjFCMUIxQjFCMUIxQjFCMUIxQjFCMUIxQjFCMUIxQjFBMAEwATABMAEwATACNYI1gjWCNYI1gjWCMYIxgjGCMYIxgjGCMYIxgjGCMYIxgjGCMYIxgjGCMYIxgjGCMYIxgTABMAEwATAAgBBpDoL+QMBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAADYAAAA3AAAAOAAAADkAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAYQAAAGIAAABjAAAAZAAAAGUAAABmAAAAZwAAAGgAAABpAAAAagAAAGsAAABsAAAAbQAAAG4AAABvAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAHoAAABbAAAAXAAAAF0AAABeAAAAXwAAAGAAAABhAAAAYgAAAGMAAABkAAAAZQAAAGYAAABnAAAAaAAAAGkAAABqAAAAawAAAGwAAABtAAAAbgAAAG8AAABwAAAAcQAAAHIAAABzAAAAdAAAAHUAAAB2AAAAdwAAAHgAAAB5AAAAegAAAHsAAAB8AAAAfQAAAH4AAAB/AEGgwgALR0xDX0NUWVBFAAAAAExDX05VTUVSSUMAAExDX1RJTUUAAAAAAExDX0NPTExBVEUAAExDX01PTkVUQVJZAExDX01FU1NBR0VTAEHwwgALIDAxMjM0NTY3ODlhYmNkZWZBQkNERUZ4WCstcFBpSW5OAEGgwwALgQElAAAAbQAAAC8AAAAlAAAAZAAAAC8AAAAlAAAAeQAAACUAAABZAAAALQAAACUAAABtAAAALQAAACUAAABkAAAAJQAAAEkAAAA6AAAAJQAAAE0AAAA6AAAAJQAAAFMAAAAgAAAAJQAAAHAAAAAAAAAAJQAAAEgAAAA6AAAAJQAAAE0AQbDEAAuVESUAAABIAAAAOgAAACUAAABNAAAAOgAAACUAAABTAAAAJQAAAEgAAAA6AAAAJQAAAE0AAAA6AAAAJQAAAFMAAAC0OgAAtj0AAFw7AADKPQAAAAAAAHAiAABcOwAA3z0AAAEAAABwIgAAtDoAAAY+AAC0OgAAuD4AAHg7AAB4PgAAAAAAAAEAAACgIgAAAAAAAHg7AABAPgAAAAAAAAEAAACoIgAAAAAAAFw7AADdPgAAAAAAAMAiAABcOwAAFj8AAAEAAADAIgAAeDsAAIU/AAAAAAAAAQAAAKAiAAAAAAAAeDsAAGE/AAAAAAAAAQAAAPgiAAAAAAAAXDsAALE/AAAAAAAAECMAAFw7AADWPwAAAQAAABAjAAB4OwAAVkoAAAAAAAABAAAA8CMAAAAAAAB4OwAAF0oAAAAAAAABAAAA8CMAAAAAAAB4OwAAskkAAAAAAAABAAAA8CMAAAAAAAC0OgAAk0kAALQ6AAB0SQAAtDoAAFVJAAC0OgAANkkAALQ6AAAXSQAAtDoAAPhIAAC0OgAA2UgAALQ6AAC6SAAAtDoAAJtIAAC0OgAAfEgAALQ6AABdSAAAtDoAAD5IAAC0OgAA8UkAANw6AAAWSwAACCQAAAAAAAC0OgAABEsAANw6AABASwAACCQAAAAAAAC0OgAAaksAALQ6AACbSwAAeDsAAMxLAAAAAAAAAQAAAPgjAAAD9P//eDsAAPtLAAAAAAAAAQAAABAkAAAD9P//eDsAACpMAAAAAAAAAQAAAPgjAAAD9P//eDsAAFlMAAAAAAAAAQAAABAkAAAD9P//3DoAAIhMAAAoJAAAAAAAANw6AAChTAAAICQAAAAAAADcOgAA4EwAACgkAAAAAAAA3DoAAPhMAAAgJAAAAAAAANw6AAAQTQAA4CQAAAAAAADcOgAAJE0AADApAAAAAAAA3DoAADpNAADgJAAAAAAAAHg7AABTTQAAAAAAAAIAAADgJAAAAgAAACAlAAAAAAAAeDsAAJdNAAAAAAAAAQAAADglAAAAAAAAtDoAAK1NAAB4OwAAxk0AAAAAAAACAAAA4CQAAAIAAABgJQAAAAAAAHg7AAAKTgAAAAAAAAEAAAA4JQAAAAAAAHg7AAAzTgAAAAAAAAIAAADgJAAAAgAAAJglAAAAAAAAeDsAAHdOAAAAAAAAAQAAALAlAAAAAAAAtDoAAI1OAAB4OwAApk4AAAAAAAACAAAA4CQAAAIAAADYJQAAAAAAAHg7AADqTgAAAAAAAAEAAACwJQAAAAAAAHg7AABAUAAAAAAAAAMAAADgJAAAAgAAABgmAAACAAAAICYAAAAIAAC0OgAAp1AAALQ6AACFUAAAeDsAALpQAAAAAAAAAwAAAOAkAAACAAAAGCYAAAIAAABQJgAAAAgAALQ6AAD/UAAAeDsAACFRAAAAAAAAAgAAAOAkAAACAAAAeCYAAAAIAAC0OgAAZlEAAHg7AAB7UQAAAAAAAAIAAADgJAAAAgAAAHgmAAAACAAAeDsAAMBRAAAAAAAAAgAAAOAkAAACAAAAwCYAAAIAAAC0OgAA3FEAAHg7AADxUQAAAAAAAAIAAADgJAAAAgAAAMAmAAACAAAAeDsAAA1SAAAAAAAAAgAAAOAkAAACAAAAwCYAAAIAAAB4OwAAKVIAAAAAAAACAAAA4CQAAAIAAADAJgAAAgAAAHg7AABUUgAAAAAAAAIAAADgJAAAAgAAAEgnAAAAAAAAtDoAAJpSAAB4OwAAvlIAAAAAAAACAAAA4CQAAAIAAABwJwAAAAAAALQ6AAAEUwAAeDsAACNTAAAAAAAAAgAAAOAkAAACAAAAmCcAAAAAAAC0OgAAaVMAAHg7AACCUwAAAAAAAAIAAADgJAAAAgAAAMAnAAAAAAAAtDoAAMhTAAB4OwAA4VMAAAAAAAACAAAA4CQAAAIAAADoJwAAAgAAALQ6AAD2UwAAeDsAAI1UAAAAAAAAAgAAAOAkAAACAAAA6CcAAAIAAADcOgAADlQAACAoAAAAAAAAeDsAADFUAAAAAAAAAgAAAOAkAAACAAAAQCgAAAIAAAC0OgAAVFQAANw6AABrVAAAICgAAAAAAAB4OwAAolQAAAAAAAACAAAA4CQAAAIAAABAKAAAAgAAAHg7AADEVAAAAAAAAAIAAADgJAAAAgAAAEAoAAACAAAAeDsAAOZUAAAAAAAAAgAAAOAkAAACAAAAQCgAAAIAAADcOgAACVUAAOAkAAAAAAAAeDsAAB9VAAAAAAAAAgAAAOAkAAACAAAA6CgAAAIAAAC0OgAAMVUAAHg7AABGVQAAAAAAAAIAAADgJAAAAgAAAOgoAAACAAAA3DoAAGNVAADgJAAAAAAAANw6AAB4VQAA4CQAAAAAAAC0OgAAjVUAALQ6AAA3VgAA3DoAAJdWAABQKQAAAAAAANw6AABEVgAAYCkAAAAAAAC0OgAAZVYAANw6AAByVgAAQCkAAAAAAADcOgAAiFcAADgpAAAAAAAA3DoAAJVXAAA4KQAAAAAAANw6AAClVwAAiCkAAAAAAADcOgAA2lcAAFApAAAAAAAA3DoAALZXAACoKQAAAAAAANw6AAD8VwAAUCkAAAAAAABAOwAAJFgAAEA7AAAmWAAAQDsAAClYAABAOwAAK1gAAEA7AAAtWAAAQDsAAC9YAABAOwAAMVgAAEA7AAAzWAAAQDsAADVYAABAOwAAN1gAAEA7AAAxTgAAQDsAADlYAABAOwAAO1gAAEA7AAA9WAAA3DoAAD9YAABAKQAAAAAAANgpAAAgKgAAeCIAANgiAADYKQAA2CIAAHAiAAAwKgAA6CIAAJgiAADAIgAAMCoAACgjAADYKQAAKCMAACgqAAAwKgAAOCMAAJgiAAAQIwAAMCoAAOgpAABwIgAAcCIAAAAAAAABAAAAxCoAAAUAQdDVAAsBAQBB6NUACw4BAAAAAgAAAHjYGAAABABBgNYACwEBAEGP1gALBQr/////AEHA1gALCcQqAABIKwAACQBB1NYACwEBAEHo1gALEgMAAAAAAAAAAgAAAIjcGAAABABBlNcACwT/////AEHE1wALBcgrAAAFAEHU1wALAQEAQezXAAsLBAAAAAIAAABk8RgAQYTYAAsBAgBBk9gACwX//////wBBxNgACw+wBgAAFAAAAEMuVVRGLTgAQeDYAAsCRCwAQbTaAAsDMOsYAEGQ2wALAQUAQbfbAAsF//////8AQejbAAupBV9wiQD/CS8PIBQAACAZAAAgHQAAAAAAPwAAAL8AAAAACCQAAAEAAAACAAAAAAAAACAkAAADAAAABAAAAAEAAAAGAAAAAQAAAAEAAAACAAAAAwAAAAcAAAAEAAAABQAAAAEAAAAIAAAAAgAAAAAAAAAoJAAABQAAAAYAAAACAAAACQAAAAIAAAACAAAABgAAAAcAAAAKAAAACAAAAAkAAAADAAAACwAAAAQAAAAIAAAAAAAAADAkAAAHAAAACAAAAPj////4////MCQAAAkAAAAKAAAAoC4AALQuAAAIAAAAAAAAAEgkAAALAAAADAAAAPj////4////SCQAAA0AAAAOAAAA0C4AAOQuAAAEAAAAAAAAAGAkAAAPAAAAEAAAAPz////8////YCQAABEAAAASAAAAAC8AABQvAAAEAAAAAAAAAHgkAAATAAAAFAAAAPz////8////eCQAABUAAAAWAAAAMC8AAEQvAAAAAAAAkCQAAAUAAAAXAAAAAwAAAAkAAAACAAAAAgAAAAoAAAAHAAAACgAAAAgAAAAJAAAAAwAAAAwAAAAFAAAAAAAAAKAkAAADAAAAGAAAAAQAAAAGAAAAAQAAAAEAAAALAAAAAwAAAAcAAAAEAAAABQAAAAEAAAANAAAABgAAAAAAAACwJAAABQAAABkAAAAFAAAACQAAAAIAAAACAAAABgAAAAcAAAAKAAAADAAAAA0AAAAHAAAACwAAAAQAAAAAAAAAwCQAAAMAAAAaAAAABgAAAAYAAAABAAAAAQAAAAIAAAADAAAABwAAAA4AAAAPAAAACAAAAAgAAAACAAAAAAAAANAkAAAbAAAAHAAAAB0AAAABAAAAAwAAAA4AAAAAAAAA8CQAAB4AAAAfAAAAHQAAAAIAAAAEAAAADwBBmeEAC8QLJQAAIAAAACEAAAAdAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAAAAAAQCUAACIAAAAjAAAAHQAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAAAAAAHglAAAkAAAAJQAAAB0AAAADAAAABAAAAAEAAAAFAAAAAgAAAAEAAAACAAAABgAAAAAAAAC4JQAAJgAAACcAAAAdAAAABwAAAAgAAAADAAAACQAAAAQAAAADAAAABAAAAAoAAAAAAAAA8CUAACgAAAApAAAAHQAAABAAAAAXAAAAGAAAABkAAAAaAAAAGwAAAAEAAAD4////8CUAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAAAAAAKCYAACoAAAArAAAAHQAAABgAAAAcAAAAHQAAAB4AAAAfAAAAIAAAAAIAAAD4////KCYAABkAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAlAAAASAAAADoAAAAlAAAATQAAADoAAAAlAAAAUwAAAAAAAAAlAAAAbQAAAC8AAAAlAAAAZAAAAC8AAAAlAAAAeQAAAAAAAAAlAAAASQAAADoAAAAlAAAATQAAADoAAAAlAAAAUwAAACAAAAAlAAAAcAAAAAAAAAAlAAAAYQAAACAAAAAlAAAAYgAAACAAAAAlAAAAZAAAACAAAAAlAAAASAAAADoAAAAlAAAATQAAADoAAAAlAAAAUwAAACAAAAAlAAAAWQAAAAAAAABBAAAATQAAAAAAAABQAAAATQAAAAAAAABKAAAAYQAAAG4AAAB1AAAAYQAAAHIAAAB5AAAAAAAAAEYAAABlAAAAYgAAAHIAAAB1AAAAYQAAAHIAAAB5AAAAAAAAAE0AAABhAAAAcgAAAGMAAABoAAAAAAAAAEEAAABwAAAAcgAAAGkAAABsAAAAAAAAAE0AAABhAAAAeQAAAAAAAABKAAAAdQAAAG4AAABlAAAAAAAAAEoAAAB1AAAAbAAAAHkAAAAAAAAAQQAAAHUAAABnAAAAdQAAAHMAAAB0AAAAAAAAAFMAAABlAAAAcAAAAHQAAABlAAAAbQAAAGIAAABlAAAAcgAAAAAAAABPAAAAYwAAAHQAAABvAAAAYgAAAGUAAAByAAAAAAAAAE4AAABvAAAAdgAAAGUAAABtAAAAYgAAAGUAAAByAAAAAAAAAEQAAABlAAAAYwAAAGUAAABtAAAAYgAAAGUAAAByAAAAAAAAAEoAAABhAAAAbgAAAAAAAABGAAAAZQAAAGIAAAAAAAAATQAAAGEAAAByAAAAAAAAAEEAAABwAAAAcgAAAAAAAABKAAAAdQAAAG4AAAAAAAAASgAAAHUAAABsAAAAAAAAAEEAAAB1AAAAZwAAAAAAAABTAAAAZQAAAHAAAAAAAAAATwAAAGMAAAB0AAAAAAAAAE4AAABvAAAAdgAAAAAAAABEAAAAZQAAAGMAAAAAAAAAUwAAAHUAAABuAAAAZAAAAGEAAAB5AAAAAAAAAE0AAABvAAAAbgAAAGQAAABhAAAAeQAAAAAAAABUAAAAdQAAAGUAAABzAAAAZAAAAGEAAAB5AAAAAAAAAFcAAABlAAAAZAAAAG4AAABlAAAAcwAAAGQAAABhAAAAeQAAAAAAAABUAAAAaAAAAHUAAAByAAAAcwAAAGQAAABhAAAAeQAAAAAAAABGAAAAcgAAAGkAAABkAAAAYQAAAHkAAAAAAAAAUwAAAGEAAAB0AAAAdQAAAHIAAABkAAAAYQAAAHkAAAAAAAAAUwAAAHUAAABuAAAAAAAAAE0AAABvAAAAbgAAAAAAAABUAAAAdQAAAGUAAAAAAAAAVwAAAGUAAABkAAAAAAAAAFQAAABoAAAAdQAAAAAAAABGAAAAcgAAAGkAAAAAAAAAUwAAAGEAAAB0AEHo7AALiQZYJgAALAAAAC0AAAAdAAAAAQAAAAAAAACAJgAALgAAAC8AAAAdAAAAAgAAAAAAAACgJgAAMAAAADEAAAAdAAAAIAAAACEAAAAHAAAACAAAAAkAAAAKAAAAIgAAAAsAAAAMAAAAAAAAAMgmAAAyAAAAMwAAAB0AAAAjAAAAJAAAAA0AAAAOAAAADwAAABAAAAAlAAAAEQAAABIAAAAAAAAA6CYAADQAAAA1AAAAHQAAACYAAAAnAAAAEwAAABQAAAAVAAAAFgAAACgAAAAXAAAAGAAAAAAAAAAIJwAANgAAADcAAAAdAAAAKQAAACoAAAAZAAAAGgAAABsAAAAcAAAAKwAAAB0AAAAeAAAAAAAAACgnAAA4AAAAOQAAAB0AAAADAAAABAAAAAAAAABQJwAAOgAAADsAAAAdAAAABQAAAAYAAAAAAAAAeCcAADwAAAA9AAAAHQAAAAEAAAAhAAAAAAAAAKAnAAA+AAAAPwAAAB0AAAACAAAAIgAAAAAAAADIJwAAQAAAAEEAAAAdAAAAEAAAAAEAAAAfAAAAAAAAAPAnAABCAAAAQwAAAB0AAAARAAAAAgAAACAAAAAAAAAASCgAAEQAAABFAAAAHQAAAAMAAAAEAAAACwAAACwAAAAtAAAADAAAAC4AAAAAAAAAECgAAEQAAABGAAAAHQAAAAMAAAAEAAAACwAAACwAAAAtAAAADAAAAC4AAAAAAAAAeCgAAEcAAABIAAAAHQAAAAUAAAAGAAAADQAAAC8AAAAwAAAADgAAADEAAAAAAAAAuCgAAEkAAABKAAAAHQAAAAAAAADIKAAASwAAAEwAAAAdAAAACQAAABIAAAAKAAAAEwAAAAsAAAABAAAAFAAAAA8AAAAAAAAAECkAAE0AAABOAAAAHQAAADIAAAAzAAAAIQAAACIAAAAjAAAAAAAAACApAABPAAAAUAAAAB0AAAA0AAAANQAAACQAAAAlAAAAJgAAAGYAAABhAAAAbAAAAHMAAABlAAAAAAAAAHQAAAByAAAAdQAAAGUAQfzyAAvoPeAkAABEAAAAUQAAAB0AAAAAAAAA8CgAAEQAAABSAAAAHQAAABUAAAACAAAAAwAAAAQAAAAMAAAAFgAAAA0AAAAXAAAADgAAAAUAAAAYAAAAEAAAAAAAAABYKAAARAAAAFMAAAAdAAAABwAAAAgAAAARAAAANgAAADcAAAASAAAAOAAAAAAAAACYKAAARAAAAFQAAAAdAAAACQAAAAoAAAATAAAAOQAAADoAAAAUAAAAOwAAAAAAAAAgKAAARAAAAFUAAAAdAAAAAwAAAAQAAAALAAAALAAAAC0AAAAMAAAALgAAAAAAAAAgJgAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAAAAAAABQJgAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAEAAAAAAAAAQCkAAFYAAABXAAAAWAAAAFkAAAAZAAAAAwAAAAEAAAAFAAAAAAAAAGgpAABWAAAAWgAAAFgAAABZAAAAGQAAAAQAAAACAAAABgAAAAAAAAB4KQAAWwAAAFwAAAA8AAAAAAAAAIgpAABdAAAAXgAAAD0AAAAAAAAAmCkAAF0AAABfAAAAPQAAAAAAAADIKQAAVgAAAGAAAABYAAAAWQAAABoAAAAAAAAAuCkAAFYAAABhAAAAWAAAAFkAAAAbAAAAAAAAAEgqAABWAAAAYgAAAFgAAABZAAAAGQAAAAUAAAADAAAABwAAAHB1c2gATk9ORQBSRUxVAFJFTFUxAFJFTFU2AEZMT0FUMzIASU5UMzIAVUlOVDMyAFRFTlNPUl9GTE9BVDMyAFRFTlNPUl9JTlQzMgBURU5TT1JfUVVBTlQ4X0FTWU1NAFNoYXBlAHR5cGUAZGltZW5zaW9ucwBzY2FsZQBvZmZzZXQAVmVjdG9yU2hhcGUAVmVjdG9yUHRyAGFkZE11bFByZXBhcmUAZmxvb3JQcmVwYXJlAGRlcXVhbnRpemVQcmVwYXJlAGRlcHRod2lzZUNvbnZQcmVwYXJlAGNvbnZQcmVwYXJlAGdlbmVyaWNQb29saW5nUHJlcGFyZQBnZW5lcmljQWN0aXZhdGlvblByZXBhcmUAcmVzaGFwZVByZXBhcmUAY29uY2F0ZW5hdGlvblByZXBhcmUAYWRkRmxvYXQzMgBtdWxGbG9hdDMyAGZsb29yRmxvYXQzMgBkZXB0aHdpc2VDb252RmxvYXQzMgBjb252RmxvYXQzMgBhdmVyYWdlUG9vbEZsb2F0MzIAc29mdG1heEZsb2F0MzIAcmVzaGFwZUdlbmVyaWMAbWF4UG9vbEZsb2F0MzIAY29uY2F0ZW5hdGlvbkZsb2F0MzIAbGVuZ3RoAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUATjdhbmRyb2lkMm5uNVNoYXBlRQBQTjdhbmRyb2lkMm5uNVNoYXBlRQBQS043YW5kcm9pZDJubjVTaGFwZUUAaWkAdgB2aQBpaWkAdmlpaQBOMTBlbXNjcmlwdGVuM3ZhbEUAZmlpAHZpaWYAcHVzaF9iYWNrAHJlc2l6ZQBzaXplAGdldABzZXQATlN0M19fMjZ2ZWN0b3JJTjdhbmRyb2lkMm5uNVNoYXBlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQBOU3QzX18yMTNfX3ZlY3Rvcl9iYXNlSU43YW5kcm9pZDJubjVTaGFwZUVOU185YWxsb2NhdG9ySVMzX0VFRUUATlN0M19fMjIwX192ZWN0b3JfYmFzZV9jb21tb25JTGIxRUVFAFBOU3QzX18yNnZlY3RvcklON2FuZHJvaWQybm41U2hhcGVFTlNfOWFsbG9jYXRvcklTM19FRUVFAFBLTlN0M19fMjZ2ZWN0b3JJTjdhbmRyb2lkMm5uNVNoYXBlRU5TXzlhbGxvY2F0b3JJUzNfRUVFRQB2aWlpaQBpaWlpAGlpaWlpAE5TdDNfXzI2dmVjdG9ySWxOU185YWxsb2NhdG9ySWxFRUVFAE5TdDNfXzIxM19fdmVjdG9yX2Jhc2VJbE5TXzlhbGxvY2F0b3JJbEVFRUUAUE5TdDNfXzI2dmVjdG9ySWxOU185YWxsb2NhdG9ySWxFRUVFAFBLTlN0M19fMjZ2ZWN0b3JJbE5TXzlhbGxvY2F0b3JJbEVFRUUAaWlpaWlpaWlpaWlpAGlpaWlpaQBpaWlpaWlpaWkAaWlpaWZpaQBpaWlpaWlpAG9ubHkgMkQgYW5kIDREIHRlbnNvcnMgc3VwcG9ydGVkAFVuc3VwcG9ydGVkIGZ1c2VkIGFjdGl2YXRpb24gZnVuY3Rpb24gdHlwZQBOTl9DSEVDSyBmYWlsZWQ6IABnZXROdW1iZXJPZkRpbWVuc2lvbnMoaW4xKSA8PSA0ICYmIGdldE51bWJlck9mRGltZW5zaW9ucyhpbjIpIDw9IDQAaW4xLnR5cGUgPT0gaW4yLnR5cGUARGltZW5zaW9ucyBtaXNtYXRjaCBmb3IgQnJvYWRjYXN0QWRkAGJhZCBpbnB1dCAvIG91dHB1dCBvcGVyYW5kIHR5cGUuAGlucHV0IGFuZCBvdXRwdXQgdGVuc29ycyBkb24ndCBoYXZlIHRoZSBzYW1lIHJhbmsuAGlucHV0LnR5cGUgPT0gZmlsdGVyLnR5cGUAYmlhcy50eXBlID09IE9wZXJhbmRUeXBlOjpURU5TT1JfSU5UMzIAaW5wdXQudHlwZSA9PSBiaWFzLnR5cGUAZ2V0TnVtYmVyT2ZEaW1lbnNpb25zKGlucHV0KSA9PSA0AGdldE51bWJlck9mRGltZW5zaW9ucyhmaWx0ZXIpID09IDQAZ2V0TnVtYmVyT2ZEaW1lbnNpb25zKGJpYXMpID09IDEAZ2V0U2l6ZU9mRGltZW5zaW9uKGZpbHRlciwgMCkgPT0gZ2V0U2l6ZU9mRGltZW5zaW9uKGJpYXMsIDApAGdldFNpemVPZkRpbWVuc2lvbihmaWx0ZXIsIDMpID09IGdldFNpemVPZkRpbWVuc2lvbihpbnB1dCwgMykAZ2V0U2l6ZU9mRGltZW5zaW9uKGZpbHRlciwgMykgPT0gZ2V0U2l6ZU9mRGltZW5zaW9uKGJpYXMsIDApAGdldE51bWJlck9mRGltZW5zaW9ucyhpbnB1dCkgPD0gNABheGlzID49IDAAYXhpcyA8IChpbnQzMl90KW51bV9kaW1lbnNpb25zAGdldE51bWJlck9mRGltZW5zaW9ucyhpbnB1dFNoYXBlc1tpXSkgPT0gbnVtX2RpbWVuc2lvbnMAaW5wdXRTaGFwZXNbaV0udHlwZSA9PSBpbnB1dFNoYXBlc1swXS50eXBlAGlucHV0U2hhcGVzWzBdLm9mZnNldCA9PSBpbnB1dFNoYXBlc1tpXS5vZmZzZXQAaW5wdXRTaGFwZXNbMF0uc2NhbGUgPT0gaW5wdXRTaGFwZXNbaV0uc2NhbGUAZ2V0U2l6ZU9mRGltZW5zaW9uKGlucHV0U2hhcGVzWzBdLCBkKSA9PSBnZXRTaXplT2ZEaW1lbnNpb24oaW5wdXRTaGFwZXNbaV0sIGQpAGlucHV0U2hhcGVzWzBdLm9mZnNldCA9PSBvdXRwdXQtPm9mZnNldABpbnB1dFNoYXBlc1swXS5zY2FsZSA9PSBvdXRwdXQtPnNjYWxlAHN0cmVjaERpbSA9PSAtMQBudW1JbnB1dEVsZW1lbnRzID09IG51bU91dHB1dEVsZW1lbnRzAG5uQXNzZXJ0IGZhaWxlZCBhdCAAL2hvbWUveGlhbmd3ZW56aGFvL0RvY3VtZW50cy9uZXd3ZWJtbC9tbC9ubi9jb21tb24vVXRpbHMuY3BwADoAIC0gJwAhInRhYmxlTG9va3VwOiBiYWQgY29kZSIAJwoAdm9pZABib29sAGNoYXIAc2lnbmVkIGNoYXIAdW5zaWduZWQgY2hhcgBzaG9ydAB1bnNpZ25lZCBzaG9ydABpbnQAdW5zaWduZWQgaW50AGxvbmcAdW5zaWduZWQgbG9uZwBmbG9hdABkb3VibGUAc3RkOjpzdHJpbmcAc3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4Ac3RkOjp3c3RyaW5nAGVtc2NyaXB0ZW46OnZhbABlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmcgZG91YmxlPgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0llRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWpFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXNFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQBOU3QzX18yMjFfX2Jhc2ljX3N0cmluZ19jb21tb25JTGIxRUVFAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAC0rICAgMFgweAAobnVsbCkALTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYATkFOAC4AAAECBAcDBgUAaW5maW5pdHkAbmFuAExDX0FMTABMQU5HAEMuVVRGLTgAUE9TSVgATVVTTF9MT0NQQVRIAE5TdDNfXzI4aW9zX2Jhc2VFAE5TdDNfXzI5YmFzaWNfaW9zSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAE5TdDNfXzI5YmFzaWNfaW9zSXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFAE5TdDNfXzIxNWJhc2ljX3N0cmVhbWJ1ZkljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQBOU3QzX18yMTViYXNpY19zdHJlYW1idWZJd05TXzExY2hhcl90cmFpdHNJd0VFRUUATlN0M19fMjEzYmFzaWNfaXN0cmVhbUljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQBOU3QzX18yMTNiYXNpY19pc3RyZWFtSXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFAE5TdDNfXzIxM2Jhc2ljX29zdHJlYW1JY05TXzExY2hhcl90cmFpdHNJY0VFRUUATlN0M19fMjEzYmFzaWNfb3N0cmVhbUl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRQBOU3QzX18yMTFfX3N0ZG91dGJ1Zkl3RUUATlN0M19fMjExX19zdGRvdXRidWZJY0VFAHVuc3VwcG9ydGVkIGxvY2FsZSBmb3Igc3RhbmRhcmQgaW5wdXQATlN0M19fMjEwX19zdGRpbmJ1Zkl3RUUATlN0M19fMjEwX19zdGRpbmJ1ZkljRUUATlN0M19fMjdjb2xsYXRlSWNFRQBOU3QzX18yNmxvY2FsZTVmYWNldEUATlN0M19fMjdjb2xsYXRlSXdFRQAlcABDAE5TdDNfXzI3bnVtX2dldEljTlNfMTlpc3RyZWFtYnVmX2l0ZXJhdG9ySWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFRUUATlN0M19fMjlfX251bV9nZXRJY0VFAE5TdDNfXzIxNF9fbnVtX2dldF9iYXNlRQBOU3QzX18yN251bV9nZXRJd05TXzE5aXN0cmVhbWJ1Zl9pdGVyYXRvckl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRUVFAE5TdDNfXzI5X19udW1fZ2V0SXdFRQAlcAAAAABMAGxsACUAAAAAAGwATlN0M19fMjdudW1fcHV0SWNOU18xOW9zdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yOV9fbnVtX3B1dEljRUUATlN0M19fMjE0X19udW1fcHV0X2Jhc2VFAE5TdDNfXzI3bnVtX3B1dEl3TlNfMTlvc3RyZWFtYnVmX2l0ZXJhdG9ySXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFRUUATlN0M19fMjlfX251bV9wdXRJd0VFACVIOiVNOiVTACVtLyVkLyV5ACVJOiVNOiVTICVwACVhICViICVkICVIOiVNOiVTICVZAEFNAFBNAEphbnVhcnkARmVicnVhcnkATWFyY2gAQXByaWwATWF5AEp1bmUASnVseQBBdWd1c3QAU2VwdGVtYmVyAE9jdG9iZXIATm92ZW1iZXIARGVjZW1iZXIASmFuAEZlYgBNYXIAQXByAEp1bgBKdWwAQXVnAFNlcABPY3QATm92AERlYwBTdW5kYXkATW9uZGF5AFR1ZXNkYXkAV2VkbmVzZGF5AFRodXJzZGF5AEZyaWRheQBTYXR1cmRheQBTdW4ATW9uAFR1ZQBXZWQAVGh1AEZyaQBTYXQAJW0vJWQvJXklWS0lbS0lZCVJOiVNOiVTICVwJUg6JU0lSDolTTolUyVIOiVNOiVTTlN0M19fMjh0aW1lX2dldEljTlNfMTlpc3RyZWFtYnVmX2l0ZXJhdG9ySWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFRUUATlN0M19fMjIwX190aW1lX2dldF9jX3N0b3JhZ2VJY0VFAE5TdDNfXzI5dGltZV9iYXNlRQBOU3QzX18yOHRpbWVfZ2V0SXdOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yMjBfX3RpbWVfZ2V0X2Nfc3RvcmFnZUl3RUUATlN0M19fMjh0aW1lX3B1dEljTlNfMTlvc3RyZWFtYnVmX2l0ZXJhdG9ySWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFRUUATlN0M19fMjEwX190aW1lX3B1dEUATlN0M19fMjh0aW1lX3B1dEl3TlNfMTlvc3RyZWFtYnVmX2l0ZXJhdG9ySXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFRUUATlN0M19fMjEwbW9uZXlwdW5jdEljTGIwRUVFAE5TdDNfXzIxMG1vbmV5X2Jhc2VFAE5TdDNfXzIxMG1vbmV5cHVuY3RJY0xiMUVFRQBOU3QzX18yMTBtb25leXB1bmN0SXdMYjBFRUUATlN0M19fMjEwbW9uZXlwdW5jdEl3TGIxRUVFADAxMjM0NTY3ODkAJUxmAE5TdDNfXzI5bW9uZXlfZ2V0SWNOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yMTFfX21vbmV5X2dldEljRUUAMDEyMzQ1Njc4OQBOU3QzX18yOW1vbmV5X2dldEl3TlNfMTlpc3RyZWFtYnVmX2l0ZXJhdG9ySXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFRUUATlN0M19fMjExX19tb25leV9nZXRJd0VFACUuMExmAE5TdDNfXzI5bW9uZXlfcHV0SWNOU18xOW9zdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yMTFfX21vbmV5X3B1dEljRUUATlN0M19fMjltb25leV9wdXRJd05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRUVFAE5TdDNfXzIxMV9fbW9uZXlfcHV0SXdFRQBOU3QzX18yOG1lc3NhZ2VzSWNFRQBOU3QzX18yMTNtZXNzYWdlc19iYXNlRQBOU3QzX18yMTdfX3dpZGVuX2Zyb21fdXRmOElMbTMyRUVFAE5TdDNfXzI3Y29kZWN2dElEaWMxMV9fbWJzdGF0ZV90RUUATlN0M19fMjEyY29kZWN2dF9iYXNlRQBOU3QzX18yMTZfX25hcnJvd190b191dGY4SUxtMzJFRUUATlN0M19fMjhtZXNzYWdlc0l3RUUATlN0M19fMjdjb2RlY3Z0SWNjMTFfX21ic3RhdGVfdEVFAE5TdDNfXzI3Y29kZWN2dEl3YzExX19tYnN0YXRlX3RFRQBOU3QzX18yN2NvZGVjdnRJRHNjMTFfX21ic3RhdGVfdEVFAE5TdDNfXzI2bG9jYWxlNV9faW1wRQBOU3QzX18yNWN0eXBlSWNFRQBOU3QzX18yMTBjdHlwZV9iYXNlRQBOU3QzX18yNWN0eXBlSXdFRQBmYWxzZQB0cnVlAE5TdDNfXzI4bnVtcHVuY3RJY0VFAE5TdDNfXzI4bnVtcHVuY3RJd0VFAE5TdDNfXzIxNF9fc2hhcmVkX2NvdW50RQB0ZXJtaW5hdGluZyB3aXRoICVzIGV4Y2VwdGlvbiBvZiB0eXBlICVzOiAlcwB0ZXJtaW5hdGluZyB3aXRoICVzIGV4Y2VwdGlvbiBvZiB0eXBlICVzAHRlcm1pbmF0aW5nIHdpdGggJXMgZm9yZWlnbiBleGNlcHRpb24AdGVybWluYXRpbmcAdW5jYXVnaHQAU3Q5ZXhjZXB0aW9uAE4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAFN0OXR5cGVfaW5mbwBOMTBfX2N4eGFiaXYxMjBfX3NpX2NsYXNzX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTE3X19jbGFzc190eXBlX2luZm9FAHB0aHJlYWRfb25jZSBmYWlsdXJlIGluIF9fY3hhX2dldF9nbG9iYWxzX2Zhc3QoKQBjYW5ub3QgY3JlYXRlIHB0aHJlYWQga2V5IGZvciBfX2N4YV9nZXRfZ2xvYmFscygpAGNhbm5vdCB6ZXJvIG91dCB0aHJlYWQgdmFsdWUgZm9yIF9fY3hhX2dldF9nbG9iYWxzKCkAdGVybWluYXRlX2hhbmRsZXIgdW5leHBlY3RlZGx5IHJldHVybmVkAHN0ZDo6YmFkX2FsbG9jAFN0OWJhZF9hbGxvYwBTdDExbG9naWNfZXJyb3IAU3QxMmxlbmd0aF9lcnJvcgBOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAHYARG4AYgBjAGgAYQBzAHQAaQBqAG0AZgBkAE4xMF9fY3h4YWJpdjEyMV9fdm1pX2NsYXNzX3R5cGVfaW5mb0U=";var asmjsCodeFile = "";if (!isDataURI(wasmTextFile)) {
        wasmTextFile = locateFile(wasmTextFile);
      }if (!isDataURI(wasmBinaryFile)) {
        wasmBinaryFile = locateFile(wasmBinaryFile);
      }if (!isDataURI(asmjsCodeFile)) {
        asmjsCodeFile = locateFile(asmjsCodeFile);
      }var wasmPageSize = 64 * 1024;var info = { "global": null, "env": null, "asm2wasm": asm2wasmImports, "parent": Module };var exports = null;function mergeMemory(newBuffer) {
        var oldBuffer = Module["buffer"];if (newBuffer.byteLength < oldBuffer.byteLength) {
          err("the new buffer in mergeMemory is smaller than the previous one. in native wasm, we should grow memory here");
        }var oldView = new Int8Array(oldBuffer);var newView = new Int8Array(newBuffer);newView.set(oldView);updateGlobalBuffer(newBuffer);updateGlobalBufferViews();
      }function fixImports(imports) {
        return imports;
      }function getBinary() {
        try {
          if (Module["wasmBinary"]) {
            return new Uint8Array(Module["wasmBinary"]);
          }var binary = tryParseAsDataURI(wasmBinaryFile);if (binary) {
            return binary;
          }if (Module["readBinary"]) {
            return Module["readBinary"](wasmBinaryFile);
          } else {
            throw "both async and sync fetching of the wasm failed";
          }
        } catch (err) {
          abort(err);
        }
      }function getBinaryPromise() {
        if (!Module["wasmBinary"] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === "function") {
          return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function (response) {
            if (!response["ok"]) {
              throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
            }return response["arrayBuffer"]();
          }).catch(function () {
            return getBinary();
          });
        }return new Promise(function (resolve, reject) {
          resolve(getBinary());
        });
      }function doNativeWasm(global, env, providedBuffer) {
        if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) !== "object") {
          err("no native wasm support detected");return false;
        }if (!(Module["wasmMemory"] instanceof WebAssembly.Memory)) {
          err("no native wasm Memory in use");return false;
        }env["memory"] = Module["wasmMemory"];info["global"] = { "NaN": NaN, "Infinity": Infinity };info["global.Math"] = Math;info["env"] = env;function receiveInstance(instance, module) {
          exports = instance.exports;if (exports.memory) mergeMemory(exports.memory);Module["asm"] = exports;Module["usingWasm"] = true;removeRunDependency("wasm-instantiate");
        }addRunDependency("wasm-instantiate");if (Module["instantiateWasm"]) {
          try {
            return Module["instantiateWasm"](info, receiveInstance);
          } catch (e) {
            err("Module.instantiateWasm callback failed with error: " + e);return false;
          }
        }function receiveInstantiatedSource(output) {
          receiveInstance(output["instance"], output["module"]);
        }function instantiateArrayBuffer(receiver) {
          getBinaryPromise().then(function (binary) {
            return WebAssembly.instantiate(binary, info);
          }).then(receiver).catch(function (reason) {
            err("failed to asynchronously prepare wasm: " + reason);abort(reason);
          });
        }if (!Module["wasmBinary"] && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && typeof fetch === "function") {
          WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, { credentials: "same-origin" }), info).then(receiveInstantiatedSource).catch(function (reason) {
            err("wasm streaming compile failed: " + reason);err("falling back to ArrayBuffer instantiation");instantiateArrayBuffer(receiveInstantiatedSource);
          });
        } else {
          instantiateArrayBuffer(receiveInstantiatedSource);
        }return {};
      }Module["asmPreload"] = Module["asm"];var asmjsReallocBuffer = Module["reallocBuffer"];var wasmReallocBuffer = function wasmReallocBuffer(size) {
        var PAGE_MULTIPLE = Module["usingWasm"] ? WASM_PAGE_SIZE : ASMJS_PAGE_SIZE;size = alignUp(size, PAGE_MULTIPLE);var old = Module["buffer"];var oldSize = old.byteLength;if (Module["usingWasm"]) {
          try {
            var result = Module["wasmMemory"].grow((size - oldSize) / wasmPageSize);if (result !== (-1 | 0)) {
              return Module["buffer"] = Module["wasmMemory"].buffer;
            } else {
              return null;
            }
          } catch (e) {
            return null;
          }
        }
      };Module["reallocBuffer"] = function (size) {
        if (finalMethod === "asmjs") {
          return asmjsReallocBuffer(size);
        } else {
          return wasmReallocBuffer(size);
        }
      };var finalMethod = "";Module["asm"] = function (global, env, providedBuffer) {
        env = fixImports(env);if (!env["table"]) {
          var TABLE_SIZE = Module["wasmTableSize"];if (TABLE_SIZE === undefined) TABLE_SIZE = 1024;var MAX_TABLE_SIZE = Module["wasmMaxTableSize"];if ((typeof WebAssembly === "undefined" ? "undefined" : _typeof(WebAssembly)) === "object" && typeof WebAssembly.Table === "function") {
            if (MAX_TABLE_SIZE !== undefined) {
              env["table"] = new WebAssembly.Table({ "initial": TABLE_SIZE, "maximum": MAX_TABLE_SIZE, "element": "anyfunc" });
            } else {
              env["table"] = new WebAssembly.Table({ "initial": TABLE_SIZE, element: "anyfunc" });
            }
          } else {
            env["table"] = new Array(TABLE_SIZE);
          }Module["wasmTable"] = env["table"];
        }if (!env["memoryBase"]) {
          env["memoryBase"] = Module["STATIC_BASE"];
        }if (!env["tableBase"]) {
          env["tableBase"] = 0;
        }var exports;exports = doNativeWasm(global, env, providedBuffer);assert(exports, "no binaryen method succeeded.");return exports;
      };
    }integrateWasmJS();STATIC_BASE = GLOBAL_BASE;STATICTOP = STATIC_BASE + 1634672;__ATINIT__.push({ func: function func() {
        __GLOBAL__I_000101();
      } }, { func: function func() {
        __GLOBAL__sub_I_binding_cpp();
      } }, { func: function func() {
        __GLOBAL__sub_I_bind_cpp();
      } }, { func: function func() {
        __GLOBAL__sub_I_iostream_cpp();
      } });var STATIC_BUMP = 1634672;Module["STATIC_BASE"] = STATIC_BASE;Module["STATIC_BUMP"] = STATIC_BUMP;var tempDoublePtr = STATICTOP;STATICTOP += 16;function ___cxa_allocate_exception(size) {
      return _malloc(size);
    }var EXCEPTIONS = { last: 0, caught: [], infos: {}, deAdjust: function deAdjust(adjusted) {
        if (!adjusted || EXCEPTIONS.infos[adjusted]) return adjusted;for (var key in EXCEPTIONS.infos) {
          var ptr = +key;var info = EXCEPTIONS.infos[ptr];if (info.adjusted === adjusted) {
            return ptr;
          }
        }return adjusted;
      }, addRef: function addRef(ptr) {
        if (!ptr) return;var info = EXCEPTIONS.infos[ptr];info.refcount++;
      }, decRef: function decRef(ptr) {
        if (!ptr) return;var info = EXCEPTIONS.infos[ptr];assert(info.refcount > 0);info.refcount--;if (info.refcount === 0 && !info.rethrown) {
          if (info.destructor) {
            Module["dynCall_vi"](info.destructor, ptr);
          }delete EXCEPTIONS.infos[ptr];___cxa_free_exception(ptr);
        }
      }, clearRef: function clearRef(ptr) {
        if (!ptr) return;var info = EXCEPTIONS.infos[ptr];info.refcount = 0;
      } };function ___cxa_begin_catch(ptr) {
      var info = EXCEPTIONS.infos[ptr];if (info && !info.caught) {
        info.caught = true;__ZSt18uncaught_exceptionv.uncaught_exception--;
      }if (info) info.rethrown = false;EXCEPTIONS.caught.push(ptr);EXCEPTIONS.addRef(EXCEPTIONS.deAdjust(ptr));return ptr;
    }function ___resumeException(ptr) {
      if (!EXCEPTIONS.last) {
        EXCEPTIONS.last = ptr;
      }throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";
    }function ___cxa_find_matching_catch() {
      var thrown = EXCEPTIONS.last;if (!thrown) {
        return (setTempRet0(0), 0) | 0;
      }var info = EXCEPTIONS.infos[thrown];var throwntype = info.type;if (!throwntype) {
        return (setTempRet0(0), thrown) | 0;
      }var typeArray = Array.prototype.slice.call(arguments);var pointer = Module["___cxa_is_pointer_type"](throwntype);if (!___cxa_find_matching_catch.buffer) ___cxa_find_matching_catch.buffer = _malloc(4);HEAP32[___cxa_find_matching_catch.buffer >> 2] = thrown;thrown = ___cxa_find_matching_catch.buffer;for (var i = 0; i < typeArray.length; i++) {
        if (typeArray[i] && Module["___cxa_can_catch"](typeArray[i], throwntype, thrown)) {
          thrown = HEAP32[thrown >> 2];info.adjusted = thrown;return (setTempRet0(typeArray[i]), thrown) | 0;
        }
      }thrown = HEAP32[thrown >> 2];return (setTempRet0(throwntype), thrown) | 0;
    }function ___cxa_throw(ptr, type, destructor) {
      EXCEPTIONS.infos[ptr] = { ptr: ptr, adjusted: ptr, type: type, destructor: destructor, refcount: 0, caught: false, rethrown: false };EXCEPTIONS.last = ptr;if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
        __ZSt18uncaught_exceptionv.uncaught_exception = 1;
      } else {
        __ZSt18uncaught_exceptionv.uncaught_exception++;
      }throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";
    }function ___cxa_uncaught_exception() {
      return !!__ZSt18uncaught_exceptionv.uncaught_exception;
    }function ___gxx_personality_v0() {}function ___lock() {}var ERRNO_CODES = { EPERM: 1, ENOENT: 2, ESRCH: 3, EINTR: 4, EIO: 5, ENXIO: 6, E2BIG: 7, ENOEXEC: 8, EBADF: 9, ECHILD: 10, EAGAIN: 11, EWOULDBLOCK: 11, ENOMEM: 12, EACCES: 13, EFAULT: 14, ENOTBLK: 15, EBUSY: 16, EEXIST: 17, EXDEV: 18, ENODEV: 19, ENOTDIR: 20, EISDIR: 21, EINVAL: 22, ENFILE: 23, EMFILE: 24, ENOTTY: 25, ETXTBSY: 26, EFBIG: 27, ENOSPC: 28, ESPIPE: 29, EROFS: 30, EMLINK: 31, EPIPE: 32, EDOM: 33, ERANGE: 34, ENOMSG: 42, EIDRM: 43, ECHRNG: 44, EL2NSYNC: 45, EL3HLT: 46, EL3RST: 47, ELNRNG: 48, EUNATCH: 49, ENOCSI: 50, EL2HLT: 51, EDEADLK: 35, ENOLCK: 37, EBADE: 52, EBADR: 53, EXFULL: 54, ENOANO: 55, EBADRQC: 56, EBADSLT: 57, EDEADLOCK: 35, EBFONT: 59, ENOSTR: 60, ENODATA: 61, ETIME: 62, ENOSR: 63, ENONET: 64, ENOPKG: 65, EREMOTE: 66, ENOLINK: 67, EADV: 68, ESRMNT: 69, ECOMM: 70, EPROTO: 71, EMULTIHOP: 72, EDOTDOT: 73, EBADMSG: 74, ENOTUNIQ: 76, EBADFD: 77, EREMCHG: 78, ELIBACC: 79, ELIBBAD: 80, ELIBSCN: 81, ELIBMAX: 82, ELIBEXEC: 83, ENOSYS: 38, ENOTEMPTY: 39, ENAMETOOLONG: 36, ELOOP: 40, EOPNOTSUPP: 95, EPFNOSUPPORT: 96, ECONNRESET: 104, ENOBUFS: 105, EAFNOSUPPORT: 97, EPROTOTYPE: 91, ENOTSOCK: 88, ENOPROTOOPT: 92, ESHUTDOWN: 108, ECONNREFUSED: 111, EADDRINUSE: 98, ECONNABORTED: 103, ENETUNREACH: 101, ENETDOWN: 100, ETIMEDOUT: 110, EHOSTDOWN: 112, EHOSTUNREACH: 113, EINPROGRESS: 115, EALREADY: 114, EDESTADDRREQ: 89, EMSGSIZE: 90, EPROTONOSUPPORT: 93, ESOCKTNOSUPPORT: 94, EADDRNOTAVAIL: 99, ENETRESET: 102, EISCONN: 106, ENOTCONN: 107, ETOOMANYREFS: 109, EUSERS: 87, EDQUOT: 122, ESTALE: 116, ENOTSUP: 95, ENOMEDIUM: 123, EILSEQ: 84, EOVERFLOW: 75, ECANCELED: 125, ENOTRECOVERABLE: 131, EOWNERDEAD: 130, ESTRPIPE: 86 };function ___setErrNo(value) {
      if (Module["___errno_location"]) HEAP32[Module["___errno_location"]() >> 2] = value;return value;
    }function ___map_file(pathname, size) {
      ___setErrNo(ERRNO_CODES.EPERM);return -1;
    }var SYSCALLS = { varargs: 0, get: function get(varargs) {
        SYSCALLS.varargs += 4;var ret = HEAP32[SYSCALLS.varargs - 4 >> 2];return ret;
      }, getStr: function getStr() {
        var ret = Pointer_stringify(SYSCALLS.get());return ret;
      }, get64: function get64() {
        var low = SYSCALLS.get(),
            high = SYSCALLS.get();if (low >= 0) assert(high === 0);else assert(high === -1);return low;
      }, getZero: function getZero() {
        assert(SYSCALLS.get() === 0);
      } };function ___syscall140(which, varargs) {
      SYSCALLS.varargs = varargs;try {
        var stream = SYSCALLS.getStreamFromFD(),
            offset_high = SYSCALLS.get(),
            offset_low = SYSCALLS.get(),
            result = SYSCALLS.get(),
            whence = SYSCALLS.get();var offset = offset_low;FS.llseek(stream, offset, whence);HEAP32[result >> 2] = stream.position;if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);return -e.errno;
      }
    }function ___syscall145(which, varargs) {
      SYSCALLS.varargs = varargs;try {
        var stream = SYSCALLS.getStreamFromFD(),
            iov = SYSCALLS.get(),
            iovcnt = SYSCALLS.get();return SYSCALLS.doReadv(stream, iov, iovcnt);
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);return -e.errno;
      }
    }function flush_NO_FILESYSTEM() {
      var fflush = Module["_fflush"];if (fflush) fflush(0);var printChar = ___syscall146.printChar;if (!printChar) return;var buffers = ___syscall146.buffers;if (buffers[1].length) printChar(1, 10);if (buffers[2].length) printChar(2, 10);
    }function ___syscall146(which, varargs) {
      SYSCALLS.varargs = varargs;try {
        var stream = SYSCALLS.get(),
            iov = SYSCALLS.get(),
            iovcnt = SYSCALLS.get();var ret = 0;if (!___syscall146.buffers) {
          ___syscall146.buffers = [null, [], []];___syscall146.printChar = function (stream, curr) {
            var buffer = ___syscall146.buffers[stream];assert(buffer);if (curr === 0 || curr === 10) {
              (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));buffer.length = 0;
            } else {
              buffer.push(curr);
            }
          };
        }for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[iov + i * 8 >> 2];var len = HEAP32[iov + (i * 8 + 4) >> 2];for (var j = 0; j < len; j++) {
            ___syscall146.printChar(stream, HEAPU8[ptr + j]);
          }ret += len;
        }return ret;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);return -e.errno;
      }
    }function ___syscall54(which, varargs) {
      SYSCALLS.varargs = varargs;try {
        return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);return -e.errno;
      }
    }function ___syscall6(which, varargs) {
      SYSCALLS.varargs = varargs;try {
        var stream = SYSCALLS.getStreamFromFD();FS.close(stream);return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);return -e.errno;
      }
    }function ___syscall91(which, varargs) {
      SYSCALLS.varargs = varargs;try {
        var addr = SYSCALLS.get(),
            len = SYSCALLS.get();var info = SYSCALLS.mappings[addr];if (!info) return 0;if (len === info.len) {
          var stream = FS.getStream(info.fd);SYSCALLS.doMsync(addr, stream, len, info.flags);FS.munmap(stream);SYSCALLS.mappings[addr] = null;if (info.allocated) {
            _free(info.malloc);
          }
        }return 0;
      } catch (e) {
        if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError)) abort(e);return -e.errno;
      }
    }function ___unlock() {}function getShiftFromSize(size) {
      switch (size) {case 1:
          return 0;case 2:
          return 1;case 4:
          return 2;case 8:
          return 3;default:
          throw new TypeError("Unknown type size: " + size);}
    }function embind_init_charCodes() {
      var codes = new Array(256);for (var i = 0; i < 256; ++i) {
        codes[i] = String.fromCharCode(i);
      }embind_charCodes = codes;
    }var embind_charCodes = undefined;function readLatin1String(ptr) {
      var ret = "";var c = ptr;while (HEAPU8[c]) {
        ret += embind_charCodes[HEAPU8[c++]];
      }return ret;
    }var awaitingDependencies = {};var registeredTypes = {};var typeDependencies = {};var char_0 = 48;var char_9 = 57;function makeLegalFunctionName(name) {
      if (undefined === name) {
        return "_unknown";
      }name = name.replace(/[^a-zA-Z0-9_]/g, "$");var f = name.charCodeAt(0);if (f >= char_0 && f <= char_9) {
        return "_" + name;
      } else {
        return name;
      }
    }function createNamedFunction(name, body) {
      name = makeLegalFunctionName(name);return new Function("body", "return function " + name + "() {\n" + '    "use strict";' + "    return body.apply(this, arguments);\n" + "};\n")(body);
    }function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function (message) {
        this.name = errorName;this.message = message;var stack = new Error(message).stack;if (stack !== undefined) {
          this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
        }
      });errorClass.prototype = Object.create(baseErrorType.prototype);errorClass.prototype.constructor = errorClass;errorClass.prototype.toString = function () {
        if (this.message === undefined) {
          return this.name;
        } else {
          return this.name + ": " + this.message;
        }
      };return errorClass;
    }var BindingError = undefined;function throwBindingError(message) {
      throw new BindingError(message);
    }var InternalError = undefined;function throwInternalError(message) {
      throw new InternalError(message);
    }function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function (type) {
        typeDependencies[type] = dependentTypes;
      });function onComplete(typeConverters) {
        var myTypeConverters = getTypeConverters(typeConverters);if (myTypeConverters.length !== myTypes.length) {
          throwInternalError("Mismatched type converter count");
        }for (var i = 0; i < myTypes.length; ++i) {
          registerType(myTypes[i], myTypeConverters[i]);
        }
      }var typeConverters = new Array(dependentTypes.length);var unregisteredTypes = [];var registered = 0;dependentTypes.forEach(function (dt, i) {
        if (registeredTypes.hasOwnProperty(dt)) {
          typeConverters[i] = registeredTypes[dt];
        } else {
          unregisteredTypes.push(dt);if (!awaitingDependencies.hasOwnProperty(dt)) {
            awaitingDependencies[dt] = [];
          }awaitingDependencies[dt].push(function () {
            typeConverters[i] = registeredTypes[dt];++registered;if (registered === unregisteredTypes.length) {
              onComplete(typeConverters);
            }
          });
        }
      });if (0 === unregisteredTypes.length) {
        onComplete(typeConverters);
      }
    }function registerType(rawType, registeredInstance, options) {
      options = options || {};if (!("argPackAdvance" in registeredInstance)) {
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      }var name = registeredInstance.name;if (!rawType) {
        throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
      }if (registeredTypes.hasOwnProperty(rawType)) {
        if (options.ignoreDuplicateRegistrations) {
          return;
        } else {
          throwBindingError("Cannot register type '" + name + "' twice");
        }
      }registeredTypes[rawType] = registeredInstance;delete typeDependencies[rawType];if (awaitingDependencies.hasOwnProperty(rawType)) {
        var callbacks = awaitingDependencies[rawType];delete awaitingDependencies[rawType];callbacks.forEach(function (cb) {
          cb();
        });
      }
    }function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);name = readLatin1String(name);registerType(rawType, { name: name, "fromWireType": function fromWireType(wt) {
          return !!wt;
        }, "toWireType": function toWireType(destructors, o) {
          return o ? trueValue : falseValue;
        }, "argPackAdvance": 8, "readValueFromPointer": function readValueFromPointer(pointer) {
          var heap;if (size === 1) {
            heap = HEAP8;
          } else if (size === 2) {
            heap = HEAP16;
          } else if (size === 4) {
            heap = HEAP32;
          } else {
            throw new TypeError("Unknown boolean type size: " + name);
          }return this["fromWireType"](heap[pointer >> shift]);
        }, destructorFunction: null });
    }function ClassHandle_isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
        return false;
      }if (!(other instanceof ClassHandle)) {
        return false;
      }var leftClass = this.$$.ptrType.registeredClass;var left = this.$$.ptr;var rightClass = other.$$.ptrType.registeredClass;var right = other.$$.ptr;while (leftClass.baseClass) {
        left = leftClass.upcast(left);leftClass = leftClass.baseClass;
      }while (rightClass.baseClass) {
        right = rightClass.upcast(right);rightClass = rightClass.baseClass;
      }return leftClass === rightClass && left === right;
    }function shallowCopyInternalPointer(o) {
      return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
    }function throwInstanceAlreadyDeleted(obj) {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
    }function ClassHandle_clone() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }if (this.$$.preservePointerOnDelete) {
        this.$$.count.value += 1;return this;
      } else {
        var clone = Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } });clone.$$.count.value += 1;clone.$$.deleteScheduled = false;return clone;
      }
    }function runDestructor(handle) {
      var $$ = handle.$$;if ($$.smartPtr) {
        $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
        $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    }function ClassHandle_delete() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError("Object already scheduled for deletion");
      }this.$$.count.value -= 1;var toDelete = 0 === this.$$.count.value;if (toDelete) {
        runDestructor(this);
      }if (!this.$$.preservePointerOnDelete) {
        this.$$.smartPtr = undefined;this.$$.ptr = undefined;
      }
    }function ClassHandle_isDeleted() {
      return !this.$$.ptr;
    }var delayFunction = undefined;var deletionQueue = [];function flushPendingDeletes() {
      while (deletionQueue.length) {
        var obj = deletionQueue.pop();obj.$$.deleteScheduled = false;obj["delete"]();
      }
    }function ClassHandle_deleteLater() {
      if (!this.$$.ptr) {
        throwInstanceAlreadyDeleted(this);
      }if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
        throwBindingError("Object already scheduled for deletion");
      }deletionQueue.push(this);if (deletionQueue.length === 1 && delayFunction) {
        delayFunction(flushPendingDeletes);
      }this.$$.deleteScheduled = true;return this;
    }function init_ClassHandle() {
      ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;ClassHandle.prototype["clone"] = ClassHandle_clone;ClassHandle.prototype["delete"] = ClassHandle_delete;ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
    }function ClassHandle() {}var registeredPointers = {};function ensureOverloadTable(proto, methodName, humanName) {
      if (undefined === proto[methodName].overloadTable) {
        var prevFunc = proto[methodName];proto[methodName] = function () {
          if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
            throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
          }return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
        };proto[methodName].overloadTable = [];proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    }function exposePublicSymbol(name, value, numArguments) {
      if (Module.hasOwnProperty(name)) {
        if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {
          throwBindingError("Cannot register public name '" + name + "' twice");
        }ensureOverloadTable(Module, name, name);if (Module.hasOwnProperty(numArguments)) {
          throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
        }Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;if (undefined !== numArguments) {
          Module[name].numArguments = numArguments;
        }
      }
    }function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
      this.name = name;this.constructor = constructor;this.instancePrototype = instancePrototype;this.rawDestructor = rawDestructor;this.baseClass = baseClass;this.getActualType = getActualType;this.upcast = upcast;this.downcast = downcast;this.pureVirtualFunctions = [];
    }function upcastPointer(ptr, ptrClass, desiredClass) {
      while (ptrClass !== desiredClass) {
        if (!ptrClass.upcast) {
          throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
        }ptr = ptrClass.upcast(ptr);ptrClass = ptrClass.baseClass;
      }return ptr;
    }function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError("null is not a valid " + this.name);
        }return 0;
      }if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }if (!handle.$$.ptr) {
        throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
      }var handleClass = handle.$$.ptrType.registeredClass;var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);return ptr;
    }function genericPointerToWireType(destructors, handle) {
      var ptr;if (handle === null) {
        if (this.isReference) {
          throwBindingError("null is not a valid " + this.name);
        }if (this.isSmartPointer) {
          ptr = this.rawConstructor();if (destructors !== null) {
            destructors.push(this.rawDestructor, ptr);
          }return ptr;
        } else {
          return 0;
        }
      }if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }if (!handle.$$.ptr) {
        throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
      }if (!this.isConst && handle.$$.ptrType.isConst) {
        throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
      }var handleClass = handle.$$.ptrType.registeredClass;ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);if (this.isSmartPointer) {
        if (undefined === handle.$$.smartPtr) {
          throwBindingError("Passing raw pointer to smart pointer is illegal");
        }switch (this.sharingPolicy) {case 0:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
            }break;case 1:
            ptr = handle.$$.smartPtr;break;case 2:
            if (handle.$$.smartPtrType === this) {
              ptr = handle.$$.smartPtr;
            } else {
              var clonedHandle = handle["clone"]();ptr = this.rawShare(ptr, __emval_register(function () {
                clonedHandle["delete"]();
              }));if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
            }break;default:
            throwBindingError("Unsupporting sharing policy");}
      }return ptr;
    }function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
        if (this.isReference) {
          throwBindingError("null is not a valid " + this.name);
        }return 0;
      }if (!handle.$$) {
        throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }if (!handle.$$.ptr) {
        throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
      }if (handle.$$.ptrType.isConst) {
        throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
      }var handleClass = handle.$$.ptrType.registeredClass;var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);return ptr;
    }function simpleReadValueFromPointer(pointer) {
      return this["fromWireType"](HEAPU32[pointer >> 2]);
    }function RegisteredPointer_getPointee(ptr) {
      if (this.rawGetPointee) {
        ptr = this.rawGetPointee(ptr);
      }return ptr;
    }function RegisteredPointer_destructor(ptr) {
      if (this.rawDestructor) {
        this.rawDestructor(ptr);
      }
    }function RegisteredPointer_deleteObject(handle) {
      if (handle !== null) {
        handle["delete"]();
      }
    }function downcastPointer(ptr, ptrClass, desiredClass) {
      if (ptrClass === desiredClass) {
        return ptr;
      }if (undefined === desiredClass.baseClass) {
        return null;
      }var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);if (rv === null) {
        return null;
      }return desiredClass.downcast(rv);
    }function getInheritedInstanceCount() {
      return Object.keys(registeredInstances).length;
    }function getLiveInheritedInstances() {
      var rv = [];for (var k in registeredInstances) {
        if (registeredInstances.hasOwnProperty(k)) {
          rv.push(registeredInstances[k]);
        }
      }return rv;
    }function setDelayFunction(fn) {
      delayFunction = fn;if (deletionQueue.length && delayFunction) {
        delayFunction(flushPendingDeletes);
      }
    }function init_embind() {
      Module["getInheritedInstanceCount"] = getInheritedInstanceCount;Module["getLiveInheritedInstances"] = getLiveInheritedInstances;Module["flushPendingDeletes"] = flushPendingDeletes;Module["setDelayFunction"] = setDelayFunction;
    }var registeredInstances = {};function getBasestPointer(class_, ptr) {
      if (ptr === undefined) {
        throwBindingError("ptr should not be undefined");
      }while (class_.baseClass) {
        ptr = class_.upcast(ptr);class_ = class_.baseClass;
      }return ptr;
    }function getInheritedInstance(class_, ptr) {
      ptr = getBasestPointer(class_, ptr);return registeredInstances[ptr];
    }function makeClassHandle(prototype, record) {
      if (!record.ptrType || !record.ptr) {
        throwInternalError("makeClassHandle requires ptr and ptrType");
      }var hasSmartPtrType = !!record.smartPtrType;var hasSmartPtr = !!record.smartPtr;if (hasSmartPtrType !== hasSmartPtr) {
        throwInternalError("Both smartPtrType and smartPtr must be specified");
      }record.count = { value: 1 };return Object.create(prototype, { $$: { value: record } });
    }function RegisteredPointer_fromWireType(ptr) {
      var rawPointer = this.getPointee(ptr);if (!rawPointer) {
        this.destructor(ptr);return null;
      }var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);if (undefined !== registeredInstance) {
        if (0 === registeredInstance.$$.count.value) {
          registeredInstance.$$.ptr = rawPointer;registeredInstance.$$.smartPtr = ptr;return registeredInstance["clone"]();
        } else {
          var rv = registeredInstance["clone"]();this.destructor(ptr);return rv;
        }
      }function makeDefaultHandle() {
        if (this.isSmartPointer) {
          return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
        } else {
          return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr: ptr });
        }
      }var actualType = this.registeredClass.getActualType(rawPointer);var registeredPointerRecord = registeredPointers[actualType];if (!registeredPointerRecord) {
        return makeDefaultHandle.call(this);
      }var toType;if (this.isConst) {
        toType = registeredPointerRecord.constPointerType;
      } else {
        toType = registeredPointerRecord.pointerType;
      }var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);if (dp === null) {
        return makeDefaultHandle.call(this);
      }if (this.isSmartPointer) {
        return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
      } else {
        return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
      }
    }function init_RegisteredPointer() {
      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;RegisteredPointer.prototype["argPackAdvance"] = 8;RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
    }function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
      this.name = name;this.registeredClass = registeredClass;this.isReference = isReference;this.isConst = isConst;this.isSmartPointer = isSmartPointer;this.pointeeType = pointeeType;this.sharingPolicy = sharingPolicy;this.rawGetPointee = rawGetPointee;this.rawConstructor = rawConstructor;this.rawShare = rawShare;this.rawDestructor = rawDestructor;if (!isSmartPointer && registeredClass.baseClass === undefined) {
        if (isConst) {
          this["toWireType"] = constNoSmartPtrRawPointerToWireType;this.destructorFunction = null;
        } else {
          this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;this.destructorFunction = null;
        }
      } else {
        this["toWireType"] = genericPointerToWireType;
      }
    }function replacePublicSymbol(name, value, numArguments) {
      if (!Module.hasOwnProperty(name)) {
        throwInternalError("Replacing nonexistant public symbol");
      }if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
        Module[name].overloadTable[numArguments] = value;
      } else {
        Module[name] = value;Module[name].argCount = numArguments;
      }
    }function embind__requireFunction(signature, rawFunction) {
      signature = readLatin1String(signature);function makeDynCaller(dynCall) {
        var args = [];for (var i = 1; i < signature.length; ++i) {
          args.push("a" + i);
        }var name = "dynCall_" + signature + "_" + rawFunction;var body = "return function " + name + "(" + args.join(", ") + ") {\n";body += "    return dynCall(rawFunction" + (args.length ? ", " : "") + args.join(", ") + ");\n";body += "};\n";return new Function("dynCall", "rawFunction", body)(dynCall, rawFunction);
      }var fp;if (Module["FUNCTION_TABLE_" + signature] !== undefined) {
        fp = Module["FUNCTION_TABLE_" + signature][rawFunction];
      } else if (typeof FUNCTION_TABLE !== "undefined") {
        fp = FUNCTION_TABLE[rawFunction];
      } else {
        var dc = Module["asm"]["dynCall_" + signature];if (dc === undefined) {
          dc = Module["asm"]["dynCall_" + signature.replace(/f/g, "d")];if (dc === undefined) {
            throwBindingError("No dynCall invoker for signature: " + signature);
          }
        }fp = makeDynCaller(dc);
      }if (typeof fp !== "function") {
        throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
      }return fp;
    }var UnboundTypeError = undefined;function getTypeName(type) {
      var ptr = ___getTypeName(type);var rv = readLatin1String(ptr);_free(ptr);return rv;
    }function throwUnboundTypeError(message, types) {
      var unboundTypes = [];var seen = {};function visit(type) {
        if (seen[type]) {
          return;
        }if (registeredTypes[type]) {
          return;
        }if (typeDependencies[type]) {
          typeDependencies[type].forEach(visit);return;
        }unboundTypes.push(type);seen[type] = true;
      }types.forEach(visit);throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
    }function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor) {
      name = readLatin1String(name);getActualType = embind__requireFunction(getActualTypeSignature, getActualType);if (upcast) {
        upcast = embind__requireFunction(upcastSignature, upcast);
      }if (downcast) {
        downcast = embind__requireFunction(downcastSignature, downcast);
      }rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);var legalFunctionName = makeLegalFunctionName(name);exposePublicSymbol(legalFunctionName, function () {
        throwUnboundTypeError("Cannot construct " + name + " due to unbound types", [baseClassRawType]);
      });whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function (base) {
        base = base[0];var baseClass;var basePrototype;if (baseClassRawType) {
          baseClass = base.registeredClass;basePrototype = baseClass.instancePrototype;
        } else {
          basePrototype = ClassHandle.prototype;
        }var constructor = createNamedFunction(legalFunctionName, function () {
          if (Object.getPrototypeOf(this) !== instancePrototype) {
            throw new BindingError("Use 'new' to construct " + name);
          }if (undefined === registeredClass.constructor_body) {
            throw new BindingError(name + " has no accessible constructor");
          }var body = registeredClass.constructor_body[arguments.length];if (undefined === body) {
            throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
          }return body.apply(this, arguments);
        });var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });constructor.prototype = instancePrototype;var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);var pointerConverter = new RegisteredPointer(name + "*", registeredClass, false, false, false);var constPointerConverter = new RegisteredPointer(name + " const*", registeredClass, false, true, false);registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };replacePublicSymbol(legalFunctionName, constructor);return [referenceConverter, pointerConverter, constPointerConverter];
      });
    }function heap32VectorToArray(count, firstElement) {
      var array = [];for (var i = 0; i < count; i++) {
        array.push(HEAP32[(firstElement >> 2) + i]);
      }return array;
    }function runDestructors(destructors) {
      while (destructors.length) {
        var ptr = destructors.pop();var del = destructors.pop();del(ptr);
      }
    }function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);invoker = embind__requireFunction(invokerSignature, invoker);whenDependentTypesAreResolved([], [rawClassType], function (classType) {
        classType = classType[0];var humanName = "constructor " + classType.name;if (undefined === classType.registeredClass.constructor_body) {
          classType.registeredClass.constructor_body = [];
        }if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
          throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        }classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
          throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
        };whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {
          classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
            if (arguments.length !== argCount - 1) {
              throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
            }var destructors = [];var args = new Array(argCount);args[0] = rawConstructor;for (var i = 1; i < argCount; ++i) {
              args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
            }var ptr = invoker.apply(null, args);runDestructors(destructors);return argTypes[0]["fromWireType"](ptr);
          };return [];
        });return [];
      });
    }function new_(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
        throw new TypeError("new_ called with constructor type " + (typeof constructor === "undefined" ? "undefined" : _typeof(constructor)) + " which is not a function");
      }var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function () {});dummy.prototype = constructor.prototype;var obj = new dummy();var r = constructor.apply(obj, argumentList);return r instanceof Object ? r : obj;
    }function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
      var argCount = argTypes.length;if (argCount < 2) {
        throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }var isClassMethodFunc = argTypes[1] !== null && classType !== null;var needsDestructorStack = false;for (var i = 1; i < argTypes.length; ++i) {
        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {
          needsDestructorStack = true;break;
        }
      }var returns = argTypes[0].name !== "void";var argsList = "";var argsListWired = "";for (var i = 0; i < argCount - 2; ++i) {
        argsList += (i !== 0 ? ", " : "") + "arg" + i;argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
      }var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\n" + "if (arguments.length !== " + (argCount - 2) + ") {\n" + "throwBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n" + "}\n";if (needsDestructorStack) {
        invokerFnBody += "var destructors = [];\n";
      }var dtorStack = needsDestructorStack ? "destructors" : "null";var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];if (isClassMethodFunc) {
        invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
      }for (var i = 0; i < argCount - 2; ++i) {
        invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";args1.push("argType" + i);args2.push(argTypes[i + 2]);
      }if (isClassMethodFunc) {
        argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
      }invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";if (needsDestructorStack) {
        invokerFnBody += "runDestructors(destructors);\n";
      } else {
        for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
          var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";if (argTypes[i].destructorFunction !== null) {
            invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";args1.push(paramName + "_dtor");args2.push(argTypes[i].destructorFunction);
          }
        }
      }if (returns) {
        invokerFnBody += "var ret = retType.fromWireType(rv);\n" + "return ret;\n";
      } else {}invokerFnBody += "}\n";args1.push(invokerFnBody);var invokerFunction = new_(Function, args1).apply(null, args2);return invokerFunction;
    }function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);methodName = readLatin1String(methodName);rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);whenDependentTypesAreResolved([], [rawClassType], function (classType) {
        classType = classType[0];var humanName = classType.name + "." + methodName;if (isPureVirtual) {
          classType.registeredClass.pureVirtualFunctions.push(methodName);
        }function unboundTypesHandler() {
          throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
        }var proto = classType.registeredClass.instancePrototype;var method = proto[methodName];if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
          unboundTypesHandler.argCount = argCount - 2;unboundTypesHandler.className = classType.name;proto[methodName] = unboundTypesHandler;
        } else {
          ensureOverloadTable(proto, methodName, humanName);proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
        }whenDependentTypesAreResolved([], rawArgTypes, function (argTypes) {
          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);if (undefined === proto[methodName].overloadTable) {
            memberFunction.argCount = argCount - 2;proto[methodName] = memberFunction;
          } else {
            proto[methodName].overloadTable[argCount - 2] = memberFunction;
          }return [];
        });return [];
      });
    }function validateThis(this_, classType, humanName) {
      if (!(this_ instanceof Object)) {
        throwBindingError(humanName + ' with invalid "this": ' + this_);
      }if (!(this_ instanceof classType.registeredClass.constructor)) {
        throwBindingError(humanName + ' incompatible with "this" of type ' + this_.constructor.name);
      }if (!this_.$$.ptr) {
        throwBindingError("cannot call emscripten binding method " + humanName + " on deleted object");
      }return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);
    }function __embind_register_class_property(classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
      fieldName = readLatin1String(fieldName);getter = embind__requireFunction(getterSignature, getter);whenDependentTypesAreResolved([], [classType], function (classType) {
        classType = classType[0];var humanName = classType.name + "." + fieldName;var desc = { get: function get() {
            throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [getterReturnType, setterArgumentType]);
          }, enumerable: true, configurable: true };if (setter) {
          desc.set = function () {
            throwUnboundTypeError("Cannot access " + humanName + " due to unbound types", [getterReturnType, setterArgumentType]);
          };
        } else {
          desc.set = function (v) {
            throwBindingError(humanName + " is a read-only property");
          };
        }Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);whenDependentTypesAreResolved([], setter ? [getterReturnType, setterArgumentType] : [getterReturnType], function (types) {
          var getterReturnType = types[0];var desc = { get: function get() {
              var ptr = validateThis(this, classType, humanName + " getter");return getterReturnType["fromWireType"](getter(getterContext, ptr));
            }, enumerable: true };if (setter) {
            setter = embind__requireFunction(setterSignature, setter);var setterArgumentType = types[1];desc.set = function (v) {
              var ptr = validateThis(this, classType, humanName + " setter");var destructors = [];setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, v));runDestructors(destructors);
            };
          }Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);return [];
        });return [];
      });
    }function __embind_register_constant(name, type, value) {
      name = readLatin1String(name);whenDependentTypesAreResolved([], [type], function (type) {
        type = type[0];Module[name] = type["fromWireType"](value);return [];
      });
    }var emval_free_list = [];var emval_handle_array = [{}, { value: undefined }, { value: null }, { value: true }, { value: false }];function __emval_decref(handle) {
      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
        emval_handle_array[handle] = undefined;emval_free_list.push(handle);
      }
    }function count_emval_handles() {
      var count = 0;for (var i = 5; i < emval_handle_array.length; ++i) {
        if (emval_handle_array[i] !== undefined) {
          ++count;
        }
      }return count;
    }function get_first_emval() {
      for (var i = 5; i < emval_handle_array.length; ++i) {
        if (emval_handle_array[i] !== undefined) {
          return emval_handle_array[i];
        }
      }return null;
    }function init_emval() {
      Module["count_emval_handles"] = count_emval_handles;Module["get_first_emval"] = get_first_emval;
    }function __emval_register(value) {
      switch (value) {case undefined:
          {
            return 1;
          };case null:
          {
            return 2;
          };case true:
          {
            return 3;
          };case false:
          {
            return 4;
          };default:
          {
            var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;emval_handle_array[handle] = { refcount: 1, value: value };return handle;
          }}
    }function __embind_register_emval(rawType, name) {
      name = readLatin1String(name);registerType(rawType, { name: name, "fromWireType": function fromWireType(handle) {
          var rv = emval_handle_array[handle].value;__emval_decref(handle);return rv;
        }, "toWireType": function toWireType(destructors, value) {
          return __emval_register(value);
        }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
    }function _embind_repr(v) {
      if (v === null) {
        return "null";
      }var t = typeof v === "undefined" ? "undefined" : _typeof(v);if (t === "object" || t === "array" || t === "function") {
        return v.toString();
      } else {
        return "" + v;
      }
    }function floatReadValueFromPointer(name, shift) {
      switch (shift) {case 2:
          return function (pointer) {
            return this["fromWireType"](HEAPF32[pointer >> 2]);
          };case 3:
          return function (pointer) {
            return this["fromWireType"](HEAPF64[pointer >> 3]);
          };default:
          throw new TypeError("Unknown float type: " + name);}
    }function __embind_register_float(rawType, name, size) {
      var shift = getShiftFromSize(size);name = readLatin1String(name);registerType(rawType, { name: name, "fromWireType": function fromWireType(value) {
          return value;
        }, "toWireType": function toWireType(destructors, value) {
          if (typeof value !== "number" && typeof value !== "boolean") {
            throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
          }return value;
        }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name, shift), destructorFunction: null });
    }function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);name = readLatin1String(name);rawInvoker = embind__requireFunction(signature, rawInvoker);exposePublicSymbol(name, function () {
        throwUnboundTypeError("Cannot call " + name + " due to unbound types", argTypes);
      }, argCount - 1);whenDependentTypesAreResolved([], argTypes, function (argTypes) {
        var invokerArgsArray = [argTypes[0], null].concat(argTypes.slice(1));replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn), argCount - 1);return [];
      });
    }function integerReadValueFromPointer(name, shift, signed) {
      switch (shift) {case 0:
          return signed ? function readS8FromPointer(pointer) {
            return HEAP8[pointer];
          } : function readU8FromPointer(pointer) {
            return HEAPU8[pointer];
          };case 1:
          return signed ? function readS16FromPointer(pointer) {
            return HEAP16[pointer >> 1];
          } : function readU16FromPointer(pointer) {
            return HEAPU16[pointer >> 1];
          };case 2:
          return signed ? function readS32FromPointer(pointer) {
            return HEAP32[pointer >> 2];
          } : function readU32FromPointer(pointer) {
            return HEAPU32[pointer >> 2];
          };default:
          throw new TypeError("Unknown integer type: " + name);}
    }function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
      name = readLatin1String(name);if (maxRange === -1) {
        maxRange = 4294967295;
      }var shift = getShiftFromSize(size);var fromWireType = function fromWireType(value) {
        return value;
      };if (minRange === 0) {
        var bitshift = 32 - 8 * size;fromWireType = function fromWireType(value) {
          return value << bitshift >>> bitshift;
        };
      }var isUnsignedType = name.indexOf("unsigned") != -1;registerType(primitiveType, { name: name, "fromWireType": fromWireType, "toWireType": function toWireType(destructors, value) {
          if (typeof value !== "number" && typeof value !== "boolean") {
            throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
          }if (value < minRange || value > maxRange) {
            throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
          }return isUnsignedType ? value >>> 0 : value | 0;
        }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name, shift, minRange !== 0), destructorFunction: null });
    }function __embind_register_memory_view(rawType, dataTypeIndex, name) {
      var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];var TA = typeMapping[dataTypeIndex];function decodeMemoryView(handle) {
        handle = handle >> 2;var heap = HEAPU32;var size = heap[handle];var data = heap[handle + 1];return new TA(heap["buffer"], data, size);
      }name = readLatin1String(name);registerType(rawType, { name: name, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
    }function __embind_register_std_string(rawType, name) {
      name = readLatin1String(name);var stdStringIsUTF8 = name === "std::string";registerType(rawType, { name: name, "fromWireType": function fromWireType(value) {
          var length = HEAPU32[value >> 2];var str;if (stdStringIsUTF8) {
            var endChar = HEAPU8[value + 4 + length];var endCharSwap = 0;if (endChar != 0) {
              endCharSwap = endChar;HEAPU8[value + 4 + length] = 0;
            }var decodeStartPtr = value + 4;for (var i = 0; i <= length; ++i) {
              var currentBytePtr = value + 4 + i;if (HEAPU8[currentBytePtr] == 0) {
                var stringSegment = UTF8ToString(decodeStartPtr);if (str === undefined) str = stringSegment;else {
                  str += String.fromCharCode(0);str += stringSegment;
                }decodeStartPtr = currentBytePtr + 1;
              }
            }if (endCharSwap != 0) HEAPU8[value + 4 + length] = endCharSwap;
          } else {
            var a = new Array(length);for (var i = 0; i < length; ++i) {
              a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
            }str = a.join("");
          }_free(value);return str;
        }, "toWireType": function toWireType(destructors, value) {
          if (value instanceof ArrayBuffer) {
            value = new Uint8Array(value);
          }var getLength;var valueIsOfTypeString = typeof value === "string";if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
            throwBindingError("Cannot pass non-string to std::string");
          }if (stdStringIsUTF8 && valueIsOfTypeString) {
            getLength = function getLength() {
              return lengthBytesUTF8(value);
            };
          } else {
            getLength = function getLength() {
              return value.length;
            };
          }var length = getLength();var ptr = _malloc(4 + length + 1);HEAPU32[ptr >> 2] = length;if (stdStringIsUTF8 && valueIsOfTypeString) {
            stringToUTF8(value, ptr + 4, length + 1);
          } else {
            if (valueIsOfTypeString) {
              for (var i = 0; i < length; ++i) {
                var charCode = value.charCodeAt(i);if (charCode > 255) {
                  _free(ptr);throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                }HEAPU8[ptr + 4 + i] = charCode;
              }
            } else {
              for (var i = 0; i < length; ++i) {
                HEAPU8[ptr + 4 + i] = value[i];
              }
            }
          }if (destructors !== null) {
            destructors.push(_free, ptr);
          }return ptr;
        }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function destructorFunction(ptr) {
          _free(ptr);
        } });
    }function __embind_register_std_wstring(rawType, charSize, name) {
      name = readLatin1String(name);var getHeap, shift;if (charSize === 2) {
        getHeap = function getHeap() {
          return HEAPU16;
        };shift = 1;
      } else if (charSize === 4) {
        getHeap = function getHeap() {
          return HEAPU32;
        };shift = 2;
      }registerType(rawType, { name: name, "fromWireType": function fromWireType(value) {
          var HEAP = getHeap();var length = HEAPU32[value >> 2];var a = new Array(length);var start = value + 4 >> shift;for (var i = 0; i < length; ++i) {
            a[i] = String.fromCharCode(HEAP[start + i]);
          }_free(value);return a.join("");
        }, "toWireType": function toWireType(destructors, value) {
          var HEAP = getHeap();var length = value.length;var ptr = _malloc(4 + length * charSize);HEAPU32[ptr >> 2] = length;var start = ptr + 4 >> shift;for (var i = 0; i < length; ++i) {
            HEAP[start + i] = value.charCodeAt(i);
          }if (destructors !== null) {
            destructors.push(_free, ptr);
          }return ptr;
        }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function destructorFunction(ptr) {
          _free(ptr);
        } });
    }function __embind_register_void(rawType, name) {
      name = readLatin1String(name);registerType(rawType, { isVoid: true, name: name, "argPackAdvance": 0, "fromWireType": function fromWireType() {
          return undefined;
        }, "toWireType": function toWireType(destructors, o) {
          return undefined;
        } });
    }function requireHandle(handle) {
      if (!handle) {
        throwBindingError("Cannot use deleted val. handle = " + handle);
      }return emval_handle_array[handle].value;
    }function requireRegisteredType(rawType, humanName) {
      var impl = registeredTypes[rawType];if (undefined === impl) {
        throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
      }return impl;
    }function __emval_as(handle, returnType, destructorsRef) {
      handle = requireHandle(handle);returnType = requireRegisteredType(returnType, "emval::as");var destructors = [];var rd = __emval_register(destructors);HEAP32[destructorsRef >> 2] = rd;return returnType["toWireType"](destructors, handle);
    }function __emval_allocateDestructors(destructorsRef) {
      var destructors = [];HEAP32[destructorsRef >> 2] = __emval_register(destructors);return destructors;
    }var emval_symbols = {};function getStringOrSymbol(address) {
      var symbol = emval_symbols[address];if (symbol === undefined) {
        return readLatin1String(address);
      } else {
        return symbol;
      }
    }var emval_methodCallers = [];function __emval_call_void_method(caller, handle, methodName, args) {
      caller = emval_methodCallers[caller];handle = requireHandle(handle);methodName = getStringOrSymbol(methodName);caller(handle, methodName, null, args);
    }function __emval_addMethodCaller(caller) {
      var id = emval_methodCallers.length;emval_methodCallers.push(caller);return id;
    }function __emval_lookupTypes(argCount, argTypes, argWireTypes) {
      var a = new Array(argCount);for (var i = 0; i < argCount; ++i) {
        a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i], "parameter " + i);
      }return a;
    }function __emval_get_method_caller(argCount, argTypes) {
      var types = __emval_lookupTypes(argCount, argTypes);var retType = types[0];var signatureName = retType.name + "_$" + types.slice(1).map(function (t) {
        return t.name;
      }).join("_") + "$";var params = ["retType"];var args = [retType];var argsList = "";for (var i = 0; i < argCount - 1; ++i) {
        argsList += (i !== 0 ? ", " : "") + "arg" + i;params.push("argType" + i);args.push(types[1 + i]);
      }var functionName = makeLegalFunctionName("methodCaller_" + signatureName);var functionBody = "return function " + functionName + "(handle, name, destructors, args) {\n";var offset = 0;for (var i = 0; i < argCount - 1; ++i) {
        functionBody += "    var arg" + i + " = argType" + i + ".readValueFromPointer(args" + (offset ? "+" + offset : "") + ");\n";offset += types[i + 1]["argPackAdvance"];
      }functionBody += "    var rv = handle[name](" + argsList + ");\n";for (var i = 0; i < argCount - 1; ++i) {
        if (types[i + 1]["deleteObject"]) {
          functionBody += "    argType" + i + ".deleteObject(arg" + i + ");\n";
        }
      }if (!retType.isVoid) {
        functionBody += "    return retType.toWireType(destructors, rv);\n";
      }functionBody += "};\n";params.push(functionBody);var invokerFunction = new_(Function, params).apply(null, args);return __emval_addMethodCaller(invokerFunction);
    }function __emval_get_property(handle, key) {
      handle = requireHandle(handle);key = requireHandle(key);return __emval_register(handle[key]);
    }function __emval_incref(handle) {
      if (handle > 4) {
        emval_handle_array[handle].refcount += 1;
      }
    }function __emval_new_array() {
      return __emval_register([]);
    }function __emval_new_cstring(v) {
      return __emval_register(getStringOrSymbol(v));
    }function __emval_run_destructors(handle) {
      var destructors = emval_handle_array[handle].value;runDestructors(destructors);__emval_decref(handle);
    }function __emval_take_value(type, argv) {
      type = requireRegisteredType(type, "_emval_take_value");var v = type["readValueFromPointer"](argv);return __emval_register(v);
    }function _abort() {
      Module["abort"]();
    }var ENV = {};function _getenv(name) {
      if (name === 0) return 0;name = Pointer_stringify(name);if (!ENV.hasOwnProperty(name)) return 0;if (_getenv.ret) _free(_getenv.ret);_getenv.ret = allocateUTF8(ENV[name]);return _getenv.ret;
    }var _llvm_floor_f32 = Math_floor;function _llvm_stackrestore(p) {
      var self = _llvm_stacksave;var ret = self.LLVM_SAVEDSTACKS[p];self.LLVM_SAVEDSTACKS.splice(p, 1);_stackRestore(ret);
    }function _llvm_stacksave() {
      var self = _llvm_stacksave;if (!self.LLVM_SAVEDSTACKS) {
        self.LLVM_SAVEDSTACKS = [];
      }self.LLVM_SAVEDSTACKS.push(_stackSave());return self.LLVM_SAVEDSTACKS.length - 1;
    }function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src + num), dest);return dest;
    }function _pthread_cond_wait() {
      return 0;
    }var PTHREAD_SPECIFIC = {};function _pthread_getspecific(key) {
      return PTHREAD_SPECIFIC[key] || 0;
    }var PTHREAD_SPECIFIC_NEXT_KEY = 1;function _pthread_key_create(key, destructor) {
      if (key == 0) {
        return ERRNO_CODES.EINVAL;
      }HEAP32[key >> 2] = PTHREAD_SPECIFIC_NEXT_KEY;PTHREAD_SPECIFIC[PTHREAD_SPECIFIC_NEXT_KEY] = 0;PTHREAD_SPECIFIC_NEXT_KEY++;return 0;
    }function _pthread_once(ptr, func) {
      if (!_pthread_once.seen) _pthread_once.seen = {};if (ptr in _pthread_once.seen) return;Module["dynCall_v"](func);_pthread_once.seen[ptr] = 1;
    }function _pthread_setspecific(key, value) {
      if (!(key in PTHREAD_SPECIFIC)) {
        return ERRNO_CODES.EINVAL;
      }PTHREAD_SPECIFIC[key] = value;return 0;
    }function __isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }function __arraySum(array, index) {
      var sum = 0;for (var i = 0; i <= index; sum += array[i++]) {}return sum;
    }var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];function __addDays(date, days) {
      var newDate = new Date(date.getTime());while (days > 0) {
        var leap = __isLeapYear(newDate.getFullYear());var currentMonth = newDate.getMonth();var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];if (days > daysInCurrentMonth - newDate.getDate()) {
          days -= daysInCurrentMonth - newDate.getDate() + 1;newDate.setDate(1);if (currentMonth < 11) {
            newDate.setMonth(currentMonth + 1);
          } else {
            newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear() + 1);
          }
        } else {
          newDate.setDate(newDate.getDate() + days);return newDate;
        }
      }return newDate;
    }function _strftime(s, maxsize, format, tm) {
      var tm_zone = HEAP32[tm + 40 >> 2];var date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? Pointer_stringify(tm_zone) : "" };var pattern = Pointer_stringify(format);var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S" };for (var rule in EXPANSION_RULES_1) {
        pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
      }var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];function leadingSomething(value, digits, character) {
        var str = typeof value === "number" ? value.toString() : value || "";while (str.length < digits) {
          str = character[0] + str;
        }return str;
      }function leadingNulls(value, digits) {
        return leadingSomething(value, digits, "0");
      }function compareByDay(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : value > 0 ? 1 : 0;
        }var compare;if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
          if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
            compare = sgn(date1.getDate() - date2.getDate());
          }
        }return compare;
      }function getFirstWeekStartDate(janFourth) {
        switch (janFourth.getDay()) {case 0:
            return new Date(janFourth.getFullYear() - 1, 11, 29);case 1:
            return janFourth;case 2:
            return new Date(janFourth.getFullYear(), 0, 3);case 3:
            return new Date(janFourth.getFullYear(), 0, 2);case 4:
            return new Date(janFourth.getFullYear(), 0, 1);case 5:
            return new Date(janFourth.getFullYear() - 1, 11, 31);case 6:
            return new Date(janFourth.getFullYear() - 1, 11, 30);}
      }function getWeekBasedYear(date) {
        var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
          if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
            return thisDate.getFullYear() + 1;
          } else {
            return thisDate.getFullYear();
          }
        } else {
          return thisDate.getFullYear() - 1;
        }
      }var EXPANSION_RULES_2 = { "%a": function a(date) {
          return WEEKDAYS[date.tm_wday].substring(0, 3);
        }, "%A": function A(date) {
          return WEEKDAYS[date.tm_wday];
        }, "%b": function b(date) {
          return MONTHS[date.tm_mon].substring(0, 3);
        }, "%B": function B(date) {
          return MONTHS[date.tm_mon];
        }, "%C": function C(date) {
          var year = date.tm_year + 1900;return leadingNulls(year / 100 | 0, 2);
        }, "%d": function d(date) {
          return leadingNulls(date.tm_mday, 2);
        }, "%e": function e(date) {
          return leadingSomething(date.tm_mday, 2, " ");
        }, "%g": function g(date) {
          return getWeekBasedYear(date).toString().substring(2);
        }, "%G": function G(date) {
          return getWeekBasedYear(date);
        }, "%H": function H(date) {
          return leadingNulls(date.tm_hour, 2);
        }, "%I": function I(date) {
          var twelveHour = date.tm_hour;if (twelveHour == 0) twelveHour = 12;else if (twelveHour > 12) twelveHour -= 12;return leadingNulls(twelveHour, 2);
        }, "%j": function j(date) {
          return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3);
        }, "%m": function m(date) {
          return leadingNulls(date.tm_mon + 1, 2);
        }, "%M": function M(date) {
          return leadingNulls(date.tm_min, 2);
        }, "%n": function n() {
          return "\n";
        }, "%p": function p(date) {
          if (date.tm_hour >= 0 && date.tm_hour < 12) {
            return "AM";
          } else {
            return "PM";
          }
        }, "%S": function S(date) {
          return leadingNulls(date.tm_sec, 2);
        }, "%t": function t() {
          return "\t";
        }, "%u": function u(date) {
          var day = new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0);return day.getDay() || 7;
        }, "%U": function U(date) {
          var janFirst = new Date(date.tm_year + 1900, 0, 1);var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);if (compareByDay(firstSunday, endDate) < 0) {
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();return leadingNulls(Math.ceil(days / 7), 2);
          }return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
        }, "%V": function V(date) {
          var janFourthThisYear = new Date(date.tm_year + 1900, 0, 4);var janFourthNextYear = new Date(date.tm_year + 1901, 0, 4);var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);var endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
            return "53";
          }if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
            return "01";
          }var daysDifference;if (firstWeekStartThisYear.getFullYear() < date.tm_year + 1900) {
            daysDifference = date.tm_yday + 32 - firstWeekStartThisYear.getDate();
          } else {
            daysDifference = date.tm_yday + 1 - firstWeekStartThisYear.getDate();
          }return leadingNulls(Math.ceil(daysDifference / 7), 2);
        }, "%w": function w(date) {
          var day = new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0);return day.getDay();
        }, "%W": function W(date) {
          var janFirst = new Date(date.tm_year, 0, 1);var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);var endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday);if (compareByDay(firstMonday, endDate) < 0) {
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();return leadingNulls(Math.ceil(days / 7), 2);
          }return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
        }, "%y": function y(date) {
          return (date.tm_year + 1900).toString().substring(2);
        }, "%Y": function Y(date) {
          return date.tm_year + 1900;
        }, "%z": function z(date) {
          var off = date.tm_gmtoff;var ahead = off >= 0;off = Math.abs(off) / 60;off = off / 60 * 100 + off % 60;return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
        }, "%Z": function Z(date) {
          return date.tm_zone;
        }, "%%": function _() {
          return "%";
        } };for (var rule in EXPANSION_RULES_2) {
        if (pattern.indexOf(rule) >= 0) {
          pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
        }
      }var bytes = intArrayFromString(pattern, false);if (bytes.length > maxsize) {
        return 0;
      }writeArrayToMemory(bytes, s);return bytes.length - 1;
    }function _strftime_l(s, maxsize, format, tm) {
      return _strftime(s, maxsize, format, tm);
    }embind_init_charCodes();BindingError = Module["BindingError"] = extendError(Error, "BindingError");InternalError = Module["InternalError"] = extendError(Error, "InternalError");init_ClassHandle();init_RegisteredPointer();init_embind();UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");init_emval();DYNAMICTOP_PTR = staticAlloc(4);STACK_BASE = STACKTOP = alignMemory(STATICTOP);STACK_MAX = STACK_BASE + TOTAL_STACK;DYNAMIC_BASE = alignMemory(STACK_MAX);HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;staticSealed = true;var ASSERTIONS = false;function intArrayFromString(stringy, dontAddNull, length) {
      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;var u8array = new Array(len);var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);if (dontAddNull) u8array.length = numBytesWritten;return u8array;
    }function intArrayToString(array) {
      var ret = [];for (var i = 0; i < array.length; i++) {
        var chr = array[i];if (chr > 255) {
          if (ASSERTIONS) {
            assert(false, "Character code " + chr + " (" + String.fromCharCode(chr) + ")  at offset " + i + " not in 0x00-0xFF.");
          }chr &= 255;
        }ret.push(String.fromCharCode(chr));
      }return ret.join("");
    }var decodeBase64 = typeof atob === "function" ? atob : function (input) {
      var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output = "";var chr1, chr2, chr3;var enc1, enc2, enc3, enc4;var i = 0;input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");do {
        enc1 = keyStr.indexOf(input.charAt(i++));enc2 = keyStr.indexOf(input.charAt(i++));enc3 = keyStr.indexOf(input.charAt(i++));enc4 = keyStr.indexOf(input.charAt(i++));chr1 = enc1 << 2 | enc2 >> 4;chr2 = (enc2 & 15) << 4 | enc3 >> 2;chr3 = (enc3 & 3) << 6 | enc4;output = output + String.fromCharCode(chr1);if (enc3 !== 64) {
          output = output + String.fromCharCode(chr2);
        }if (enc4 !== 64) {
          output = output + String.fromCharCode(chr3);
        }
      } while (i < input.length);return output;
    };function intArrayFromBase64(s) {
      if (typeof ENVIRONMENT_IS_NODE === "boolean" && ENVIRONMENT_IS_NODE) {
        var buf;try {
          buf = Buffer.from(s, "base64");
        } catch (_) {
          buf = new Buffer(s, "base64");
        }return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      }try {
        var decoded = decodeBase64(s);var bytes = new Uint8Array(decoded.length);for (var i = 0; i < decoded.length; ++i) {
          bytes[i] = decoded.charCodeAt(i);
        }return bytes;
      } catch (_) {
        throw new Error("Converting base64 string to bytes failed.");
      }
    }function tryParseAsDataURI(filename) {
      if (!isDataURI(filename)) {
        return;
      }return intArrayFromBase64(filename.slice(dataURIPrefix.length));
    }Module["wasmTableSize"] = 666;Module["wasmMaxTableSize"] = 666;function invoke_fii(index, a1, a2) {
      var sp = _stackSave();try {
        return Module["dynCall_fii"](index, a1, a2);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_i(index) {
      var sp = _stackSave();try {
        return Module["dynCall_i"](index);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_ii(index, a1) {
      var sp = _stackSave();try {
        return Module["dynCall_ii"](index, a1);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iii(index, a1, a2) {
      var sp = _stackSave();try {
        return Module["dynCall_iii"](index, a1, a2);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiifii(index, a1, a2, a3, a4, a5) {
      var sp = _stackSave();try {
        return Module["dynCall_iiifii"](index, a1, a2, a3, a4, a5);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiii(index, a1, a2, a3) {
      var sp = _stackSave();try {
        return Module["dynCall_iiii"](index, a1, a2, a3);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiifii(index, a1, a2, a3, a4, a5, a6) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiifii"](index, a1, a2, a3, a4, a5, a6);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiii(index, a1, a2, a3, a4) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiii"](index, a1, a2, a3, a4);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiid(index, a1, a2, a3, a4, a5) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiid"](index, a1, a2, a3, a4, a5);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiii(index, a1, a2, a3, a4, a5) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiii"](index, a1, a2, a3, a4, a5);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiid(index, a1, a2, a3, a4, a5, a6) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiid"](index, a1, a2, a3, a4, a5, a6);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiii(index, a1, a2, a3, a4, a5, a6) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiii"](index, a1, a2, a3, a4, a5, a6);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiiii(index, a1, a2, a3, a4, a5, a6, a7) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiiiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiiiiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiiiiiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiiiiiiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiiiiiiiiiiiiiii(index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiiiiiiiiiiiiiii"](index, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_iiiiij(index, a1, a2, a3, a4, a5, a6) {
      var sp = _stackSave();try {
        return Module["dynCall_iiiiij"](index, a1, a2, a3, a4, a5, a6);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_v(index) {
      var sp = _stackSave();try {
        Module["dynCall_v"](index);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_vi(index, a1) {
      var sp = _stackSave();try {
        Module["dynCall_vi"](index, a1);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_vii(index, a1, a2) {
      var sp = _stackSave();try {
        Module["dynCall_vii"](index, a1, a2);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_viif(index, a1, a2, a3) {
      var sp = _stackSave();try {
        Module["dynCall_viif"](index, a1, a2, a3);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_viii(index, a1, a2, a3) {
      var sp = _stackSave();try {
        Module["dynCall_viii"](index, a1, a2, a3);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_viiii(index, a1, a2, a3, a4) {
      var sp = _stackSave();try {
        Module["dynCall_viiii"](index, a1, a2, a3, a4);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_viiiii(index, a1, a2, a3, a4, a5) {
      var sp = _stackSave();try {
        Module["dynCall_viiiii"](index, a1, a2, a3, a4, a5);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_viiiiii(index, a1, a2, a3, a4, a5, a6) {
      var sp = _stackSave();try {
        Module["dynCall_viiiiii"](index, a1, a2, a3, a4, a5, a6);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }function invoke_viijii(index, a1, a2, a3, a4, a5, a6) {
      var sp = _stackSave();try {
        Module["dynCall_viijii"](index, a1, a2, a3, a4, a5, a6);
      } catch (e) {
        _stackRestore(sp);if (typeof e !== "number" && e !== "longjmp") throw e;Module["setThrew"](1, 0);
      }
    }Module.asmGlobalArg = {};Module.asmLibraryArg = { "abort": abort, "assert": assert, "enlargeMemory": enlargeMemory, "getTotalMemory": getTotalMemory, "abortOnCannotGrowMemory": abortOnCannotGrowMemory, "invoke_fii": invoke_fii, "invoke_i": invoke_i, "invoke_ii": invoke_ii, "invoke_iii": invoke_iii, "invoke_iiifii": invoke_iiifii, "invoke_iiii": invoke_iiii, "invoke_iiiifii": invoke_iiiifii, "invoke_iiiii": invoke_iiiii, "invoke_iiiiid": invoke_iiiiid, "invoke_iiiiii": invoke_iiiiii, "invoke_iiiiiid": invoke_iiiiiid, "invoke_iiiiiii": invoke_iiiiiii, "invoke_iiiiiiii": invoke_iiiiiiii, "invoke_iiiiiiiii": invoke_iiiiiiiii, "invoke_iiiiiiiiiii": invoke_iiiiiiiiiii, "invoke_iiiiiiiiiiii": invoke_iiiiiiiiiiii, "invoke_iiiiiiiiiiiiii": invoke_iiiiiiiiiiiiii, "invoke_iiiiiiiiiiiiiii": invoke_iiiiiiiiiiiiiii, "invoke_iiiiiiiiiiiiiiii": invoke_iiiiiiiiiiiiiiii, "invoke_iiiiiiiiiiiiiiiii": invoke_iiiiiiiiiiiiiiiii, "invoke_iiiiiiiiiiiiiiiiii": invoke_iiiiiiiiiiiiiiiiii, "invoke_iiiiij": invoke_iiiiij, "invoke_v": invoke_v, "invoke_vi": invoke_vi, "invoke_vii": invoke_vii, "invoke_viif": invoke_viif, "invoke_viii": invoke_viii, "invoke_viiii": invoke_viiii, "invoke_viiiii": invoke_viiiii, "invoke_viiiiii": invoke_viiiiii, "invoke_viijii": invoke_viijii, "ClassHandle": ClassHandle, "ClassHandle_clone": ClassHandle_clone, "ClassHandle_delete": ClassHandle_delete, "ClassHandle_deleteLater": ClassHandle_deleteLater, "ClassHandle_isAliasOf": ClassHandle_isAliasOf, "ClassHandle_isDeleted": ClassHandle_isDeleted, "RegisteredClass": RegisteredClass, "RegisteredPointer": RegisteredPointer, "RegisteredPointer_deleteObject": RegisteredPointer_deleteObject, "RegisteredPointer_destructor": RegisteredPointer_destructor, "RegisteredPointer_fromWireType": RegisteredPointer_fromWireType, "RegisteredPointer_getPointee": RegisteredPointer_getPointee, "___cxa_allocate_exception": ___cxa_allocate_exception, "___cxa_begin_catch": ___cxa_begin_catch, "___cxa_find_matching_catch": ___cxa_find_matching_catch, "___cxa_throw": ___cxa_throw, "___cxa_uncaught_exception": ___cxa_uncaught_exception, "___gxx_personality_v0": ___gxx_personality_v0, "___lock": ___lock, "___map_file": ___map_file, "___resumeException": ___resumeException, "___setErrNo": ___setErrNo, "___syscall140": ___syscall140, "___syscall145": ___syscall145, "___syscall146": ___syscall146, "___syscall54": ___syscall54, "___syscall6": ___syscall6, "___syscall91": ___syscall91, "___unlock": ___unlock, "__addDays": __addDays, "__arraySum": __arraySum, "__embind_register_bool": __embind_register_bool, "__embind_register_class": __embind_register_class, "__embind_register_class_constructor": __embind_register_class_constructor, "__embind_register_class_function": __embind_register_class_function, "__embind_register_class_property": __embind_register_class_property, "__embind_register_constant": __embind_register_constant, "__embind_register_emval": __embind_register_emval, "__embind_register_float": __embind_register_float, "__embind_register_function": __embind_register_function, "__embind_register_integer": __embind_register_integer, "__embind_register_memory_view": __embind_register_memory_view, "__embind_register_std_string": __embind_register_std_string, "__embind_register_std_wstring": __embind_register_std_wstring, "__embind_register_void": __embind_register_void, "__emval_addMethodCaller": __emval_addMethodCaller, "__emval_allocateDestructors": __emval_allocateDestructors, "__emval_as": __emval_as, "__emval_call_void_method": __emval_call_void_method, "__emval_decref": __emval_decref, "__emval_get_method_caller": __emval_get_method_caller, "__emval_get_property": __emval_get_property, "__emval_incref": __emval_incref, "__emval_lookupTypes": __emval_lookupTypes, "__emval_new_array": __emval_new_array, "__emval_new_cstring": __emval_new_cstring, "__emval_register": __emval_register, "__emval_run_destructors": __emval_run_destructors, "__emval_take_value": __emval_take_value, "__isLeapYear": __isLeapYear, "_abort": _abort, "_embind_repr": _embind_repr, "_emscripten_memcpy_big": _emscripten_memcpy_big, "_getenv": _getenv, "_llvm_floor_f32": _llvm_floor_f32, "_llvm_stackrestore": _llvm_stackrestore, "_llvm_stacksave": _llvm_stacksave, "_pthread_cond_wait": _pthread_cond_wait, "_pthread_getspecific": _pthread_getspecific, "_pthread_key_create": _pthread_key_create, "_pthread_once": _pthread_once, "_pthread_setspecific": _pthread_setspecific, "_strftime": _strftime, "_strftime_l": _strftime_l, "constNoSmartPtrRawPointerToWireType": constNoSmartPtrRawPointerToWireType, "count_emval_handles": count_emval_handles, "craftInvokerFunction": craftInvokerFunction, "createNamedFunction": createNamedFunction, "downcastPointer": downcastPointer, "embind__requireFunction": embind__requireFunction, "embind_init_charCodes": embind_init_charCodes, "ensureOverloadTable": ensureOverloadTable, "exposePublicSymbol": exposePublicSymbol, "extendError": extendError, "floatReadValueFromPointer": floatReadValueFromPointer, "flushPendingDeletes": flushPendingDeletes, "flush_NO_FILESYSTEM": flush_NO_FILESYSTEM, "genericPointerToWireType": genericPointerToWireType, "getBasestPointer": getBasestPointer, "getInheritedInstance": getInheritedInstance, "getInheritedInstanceCount": getInheritedInstanceCount, "getLiveInheritedInstances": getLiveInheritedInstances, "getShiftFromSize": getShiftFromSize, "getStringOrSymbol": getStringOrSymbol, "getTypeName": getTypeName, "get_first_emval": get_first_emval, "heap32VectorToArray": heap32VectorToArray, "init_ClassHandle": init_ClassHandle, "init_RegisteredPointer": init_RegisteredPointer, "init_embind": init_embind, "init_emval": init_emval, "integerReadValueFromPointer": integerReadValueFromPointer, "makeClassHandle": makeClassHandle, "makeLegalFunctionName": makeLegalFunctionName, "new_": new_, "nonConstNoSmartPtrRawPointerToWireType": nonConstNoSmartPtrRawPointerToWireType, "readLatin1String": readLatin1String, "registerType": registerType, "replacePublicSymbol": replacePublicSymbol, "requireHandle": requireHandle, "requireRegisteredType": requireRegisteredType, "runDestructor": runDestructor, "runDestructors": runDestructors, "setDelayFunction": setDelayFunction, "shallowCopyInternalPointer": shallowCopyInternalPointer, "simpleReadValueFromPointer": simpleReadValueFromPointer, "throwBindingError": throwBindingError, "throwInstanceAlreadyDeleted": throwInstanceAlreadyDeleted, "throwInternalError": throwInternalError, "throwUnboundTypeError": throwUnboundTypeError, "upcastPointer": upcastPointer, "validateThis": validateThis, "whenDependentTypesAreResolved": whenDependentTypesAreResolved, "DYNAMICTOP_PTR": DYNAMICTOP_PTR, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX };var asm = Module["asm"](Module.asmGlobalArg, Module.asmLibraryArg, buffer);Module["asm"] = asm;var __GLOBAL__I_000101 = Module["__GLOBAL__I_000101"] = function () {
      return Module["asm"]["__GLOBAL__I_000101"].apply(null, arguments);
    };var __GLOBAL__sub_I_bind_cpp = Module["__GLOBAL__sub_I_bind_cpp"] = function () {
      return Module["asm"]["__GLOBAL__sub_I_bind_cpp"].apply(null, arguments);
    };var __GLOBAL__sub_I_binding_cpp = Module["__GLOBAL__sub_I_binding_cpp"] = function () {
      return Module["asm"]["__GLOBAL__sub_I_binding_cpp"].apply(null, arguments);
    };var __GLOBAL__sub_I_iostream_cpp = Module["__GLOBAL__sub_I_iostream_cpp"] = function () {
      return Module["asm"]["__GLOBAL__sub_I_iostream_cpp"].apply(null, arguments);
    };var __ZSt18uncaught_exceptionv = Module["__ZSt18uncaught_exceptionv"] = function () {
      return Module["asm"]["__ZSt18uncaught_exceptionv"].apply(null, arguments);
    };var ___cxa_can_catch = Module["___cxa_can_catch"] = function () {
      return Module["asm"]["___cxa_can_catch"].apply(null, arguments);
    };var ___cxa_is_pointer_type = Module["___cxa_is_pointer_type"] = function () {
      return Module["asm"]["___cxa_is_pointer_type"].apply(null, arguments);
    };var ___getTypeName = Module["___getTypeName"] = function () {
      return Module["asm"]["___getTypeName"].apply(null, arguments);
    };var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = function () {
      return Module["asm"]["_emscripten_replace_memory"].apply(null, arguments);
    };var _free = Module["_free"] = function () {
      return Module["asm"]["_free"].apply(null, arguments);
    };var _llvm_bswap_i32 = Module["_llvm_bswap_i32"] = function () {
      return Module["asm"]["_llvm_bswap_i32"].apply(null, arguments);
    };var _malloc = Module["_malloc"] = function () {
      return Module["asm"]["_malloc"].apply(null, arguments);
    };var _memcpy = Module["_memcpy"] = function () {
      return Module["asm"]["_memcpy"].apply(null, arguments);
    };var _memmove = Module["_memmove"] = function () {
      return Module["asm"]["_memmove"].apply(null, arguments);
    };var _memset = Module["_memset"] = function () {
      return Module["asm"]["_memset"].apply(null, arguments);
    };var _pthread_cond_broadcast = Module["_pthread_cond_broadcast"] = function () {
      return Module["asm"]["_pthread_cond_broadcast"].apply(null, arguments);
    };var _pthread_mutex_lock = Module["_pthread_mutex_lock"] = function () {
      return Module["asm"]["_pthread_mutex_lock"].apply(null, arguments);
    };var _pthread_mutex_unlock = Module["_pthread_mutex_unlock"] = function () {
      return Module["asm"]["_pthread_mutex_unlock"].apply(null, arguments);
    };var _sbrk = Module["_sbrk"] = function () {
      return Module["asm"]["_sbrk"].apply(null, arguments);
    };var establishStackSpace = Module["establishStackSpace"] = function () {
      return Module["asm"]["establishStackSpace"].apply(null, arguments);
    };var getTempRet0 = Module["getTempRet0"] = function () {
      return Module["asm"]["getTempRet0"].apply(null, arguments);
    };var runPostSets = Module["runPostSets"] = function () {
      return Module["asm"]["runPostSets"].apply(null, arguments);
    };var setTempRet0 = Module["setTempRet0"] = function () {
      return Module["asm"]["setTempRet0"].apply(null, arguments);
    };var setThrew = Module["setThrew"] = function () {
      return Module["asm"]["setThrew"].apply(null, arguments);
    };var stackAlloc = Module["stackAlloc"] = function () {
      return Module["asm"]["stackAlloc"].apply(null, arguments);
    };var _stackRestore = Module["stackRestore"] = function () {
      return Module["asm"]["stackRestore"].apply(null, arguments);
    };var _stackSave = Module["stackSave"] = function () {
      return Module["asm"]["stackSave"].apply(null, arguments);
    };var dynCall_fii = Module["dynCall_fii"] = function () {
      return Module["asm"]["dynCall_fii"].apply(null, arguments);
    };var dynCall_i = Module["dynCall_i"] = function () {
      return Module["asm"]["dynCall_i"].apply(null, arguments);
    };var dynCall_ii = Module["dynCall_ii"] = function () {
      return Module["asm"]["dynCall_ii"].apply(null, arguments);
    };var dynCall_iii = Module["dynCall_iii"] = function () {
      return Module["asm"]["dynCall_iii"].apply(null, arguments);
    };var dynCall_iiifii = Module["dynCall_iiifii"] = function () {
      return Module["asm"]["dynCall_iiifii"].apply(null, arguments);
    };var dynCall_iiii = Module["dynCall_iiii"] = function () {
      return Module["asm"]["dynCall_iiii"].apply(null, arguments);
    };var dynCall_iiiifii = Module["dynCall_iiiifii"] = function () {
      return Module["asm"]["dynCall_iiiifii"].apply(null, arguments);
    };var dynCall_iiiii = Module["dynCall_iiiii"] = function () {
      return Module["asm"]["dynCall_iiiii"].apply(null, arguments);
    };var dynCall_iiiiid = Module["dynCall_iiiiid"] = function () {
      return Module["asm"]["dynCall_iiiiid"].apply(null, arguments);
    };var dynCall_iiiiii = Module["dynCall_iiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiii"].apply(null, arguments);
    };var dynCall_iiiiiid = Module["dynCall_iiiiiid"] = function () {
      return Module["asm"]["dynCall_iiiiiid"].apply(null, arguments);
    };var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiii"].apply(null, arguments);
    };var dynCall_iiiiiiii = Module["dynCall_iiiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiiii"].apply(null, arguments);
    };var dynCall_iiiiiiiii = Module["dynCall_iiiiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiiiii"].apply(null, arguments);
    };var dynCall_iiiiiiiiiii = Module["dynCall_iiiiiiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiiiiiii"].apply(null, arguments);
    };var dynCall_iiiiiiiiiiii = Module["dynCall_iiiiiiiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiiiiiiii"].apply(null, arguments);
    };var dynCall_iiiiiiiiiiiiii = Module["dynCall_iiiiiiiiiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiiiiiiiiii"].apply(null, arguments);
    };var dynCall_iiiiiiiiiiiiiii = Module["dynCall_iiiiiiiiiiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiiiiiiiiiii"].apply(null, arguments);
    };var dynCall_iiiiiiiiiiiiiiii = Module["dynCall_iiiiiiiiiiiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiiiiiiiiiiii"].apply(null, arguments);
    };var dynCall_iiiiiiiiiiiiiiiii = Module["dynCall_iiiiiiiiiiiiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiiiiiiiiiiiii"].apply(null, arguments);
    };var dynCall_iiiiiiiiiiiiiiiiii = Module["dynCall_iiiiiiiiiiiiiiiiii"] = function () {
      return Module["asm"]["dynCall_iiiiiiiiiiiiiiiiii"].apply(null, arguments);
    };var dynCall_iiiiij = Module["dynCall_iiiiij"] = function () {
      return Module["asm"]["dynCall_iiiiij"].apply(null, arguments);
    };var dynCall_v = Module["dynCall_v"] = function () {
      return Module["asm"]["dynCall_v"].apply(null, arguments);
    };var dynCall_vi = Module["dynCall_vi"] = function () {
      return Module["asm"]["dynCall_vi"].apply(null, arguments);
    };var dynCall_vii = Module["dynCall_vii"] = function () {
      return Module["asm"]["dynCall_vii"].apply(null, arguments);
    };var dynCall_viif = Module["dynCall_viif"] = function () {
      return Module["asm"]["dynCall_viif"].apply(null, arguments);
    };var dynCall_viii = Module["dynCall_viii"] = function () {
      return Module["asm"]["dynCall_viii"].apply(null, arguments);
    };var dynCall_viiii = Module["dynCall_viiii"] = function () {
      return Module["asm"]["dynCall_viiii"].apply(null, arguments);
    };var dynCall_viiiii = Module["dynCall_viiiii"] = function () {
      return Module["asm"]["dynCall_viiiii"].apply(null, arguments);
    };var dynCall_viiiiii = Module["dynCall_viiiiii"] = function () {
      return Module["asm"]["dynCall_viiiiii"].apply(null, arguments);
    };var dynCall_viijii = Module["dynCall_viijii"] = function () {
      return Module["asm"]["dynCall_viijii"].apply(null, arguments);
    };Module["asm"] = asm;Module["then"] = function (func) {
      if (Module["calledRun"]) {
        func(Module);
      } else {
        var old = Module["onRuntimeInitialized"];Module["onRuntimeInitialized"] = function () {
          if (old) old();func(Module);
        };
      }return Module;
    };function ExitStatus(status) {
      this.name = "ExitStatus";this.message = "Program terminated with exit(" + status + ")";this.status = status;
    }ExitStatus.prototype = new Error();ExitStatus.prototype.constructor = ExitStatus;var initialStackTop;dependenciesFulfilled = function runCaller() {
      if (!Module["calledRun"]) run();if (!Module["calledRun"]) dependenciesFulfilled = runCaller;
    };function run(args) {
      args = args || Module["arguments"];if (runDependencies > 0) {
        return;
      }preRun();if (runDependencies > 0) return;if (Module["calledRun"]) return;function doRun() {
        if (Module["calledRun"]) return;Module["calledRun"] = true;if (ABORT) return;ensureInitRuntime();preMain();if (Module["onRuntimeInitialized"]) Module["onRuntimeInitialized"]();postRun();
      }if (Module["setStatus"]) {
        Module["setStatus"]("Running...");setTimeout(function () {
          setTimeout(function () {
            Module["setStatus"]("");
          }, 1);doRun();
        }, 1);
      } else {
        doRun();
      }
    }Module["run"] = run;function abort(what) {
      if (Module["onAbort"]) {
        Module["onAbort"](what);
      }if (what !== undefined) {
        out(what);err(what);what = JSON.stringify(what);
      } else {
        what = "";
      }ABORT = true;EXITSTATUS = 1;throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
    }Module["abort"] = abort;if (Module["preInit"]) {
      if (typeof Module["preInit"] == "function") Module["preInit"] = [Module["preInit"]];while (Module["preInit"].length > 0) {
        Module["preInit"].pop()();
      }
    }Module["noExitRuntime"] = true;run();

    return Module;
  };
}();
if (( false ? "undefined" : _typeof(exports)) === 'object' && ( false ? "undefined" : _typeof(module)) === 'object') module.exports = Module;else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
  return Module;
}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === 'object') exports["Module"] = Module;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(103), "/", __webpack_require__(163).Buffer, __webpack_require__(167)(module)))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(164)
var ieee754 = __webpack_require__(165)
var isArray = __webpack_require__(166)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(57)))

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 165 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 166 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 168 */
/***/ (function(module, exports) {

module.exports = fs;

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(103)))

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(171);

__webpack_require__(368);

__webpack_require__(369);

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(57)))

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(172);
__webpack_require__(174);
__webpack_require__(175);
__webpack_require__(176);
__webpack_require__(177);
__webpack_require__(178);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(181);
__webpack_require__(182);
__webpack_require__(183);
__webpack_require__(184);
__webpack_require__(185);
__webpack_require__(186);
__webpack_require__(187);
__webpack_require__(188);
__webpack_require__(190);
__webpack_require__(191);
__webpack_require__(192);
__webpack_require__(193);
__webpack_require__(194);
__webpack_require__(195);
__webpack_require__(196);
__webpack_require__(197);
__webpack_require__(198);
__webpack_require__(199);
__webpack_require__(200);
__webpack_require__(201);
__webpack_require__(202);
__webpack_require__(203);
__webpack_require__(204);
__webpack_require__(205);
__webpack_require__(206);
__webpack_require__(207);
__webpack_require__(208);
__webpack_require__(209);
__webpack_require__(210);
__webpack_require__(211);
__webpack_require__(212);
__webpack_require__(213);
__webpack_require__(214);
__webpack_require__(215);
__webpack_require__(216);
__webpack_require__(217);
__webpack_require__(218);
__webpack_require__(219);
__webpack_require__(220);
__webpack_require__(221);
__webpack_require__(222);
__webpack_require__(223);
__webpack_require__(224);
__webpack_require__(225);
__webpack_require__(226);
__webpack_require__(227);
__webpack_require__(228);
__webpack_require__(229);
__webpack_require__(230);
__webpack_require__(231);
__webpack_require__(232);
__webpack_require__(233);
__webpack_require__(234);
__webpack_require__(235);
__webpack_require__(236);
__webpack_require__(237);
__webpack_require__(238);
__webpack_require__(239);
__webpack_require__(240);
__webpack_require__(241);
__webpack_require__(242);
__webpack_require__(243);
__webpack_require__(244);
__webpack_require__(245);
__webpack_require__(246);
__webpack_require__(247);
__webpack_require__(248);
__webpack_require__(249);
__webpack_require__(250);
__webpack_require__(252);
__webpack_require__(253);
__webpack_require__(255);
__webpack_require__(256);
__webpack_require__(257);
__webpack_require__(258);
__webpack_require__(259);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(263);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
__webpack_require__(268);
__webpack_require__(269);
__webpack_require__(270);
__webpack_require__(271);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(96);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(122);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(125);
__webpack_require__(127);
__webpack_require__(128);
__webpack_require__(283);
__webpack_require__(284);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(289);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(299);
__webpack_require__(300);
__webpack_require__(301);
__webpack_require__(302);
__webpack_require__(303);
__webpack_require__(304);
__webpack_require__(305);
__webpack_require__(306);
__webpack_require__(307);
__webpack_require__(308);
__webpack_require__(309);
__webpack_require__(310);
__webpack_require__(311);
__webpack_require__(312);
__webpack_require__(313);
__webpack_require__(314);
__webpack_require__(315);
__webpack_require__(316);
__webpack_require__(317);
__webpack_require__(318);
__webpack_require__(319);
__webpack_require__(320);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(324);
__webpack_require__(325);
__webpack_require__(326);
__webpack_require__(327);
__webpack_require__(328);
__webpack_require__(329);
__webpack_require__(330);
__webpack_require__(331);
__webpack_require__(332);
__webpack_require__(333);
__webpack_require__(334);
__webpack_require__(335);
__webpack_require__(336);
__webpack_require__(337);
__webpack_require__(338);
__webpack_require__(339);
__webpack_require__(340);
__webpack_require__(341);
__webpack_require__(342);
__webpack_require__(343);
__webpack_require__(344);
__webpack_require__(345);
__webpack_require__(346);
__webpack_require__(347);
__webpack_require__(348);
__webpack_require__(349);
__webpack_require__(350);
__webpack_require__(351);
__webpack_require__(352);
__webpack_require__(353);
__webpack_require__(354);
__webpack_require__(355);
__webpack_require__(356);
__webpack_require__(357);
__webpack_require__(358);
__webpack_require__(359);
__webpack_require__(360);
__webpack_require__(361);
__webpack_require__(362);
__webpack_require__(363);
__webpack_require__(364);
__webpack_require__(365);
__webpack_require__(366);
__webpack_require__(367);
module.exports = __webpack_require__(21);


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(2);
var has = __webpack_require__(17);
var DESCRIPTORS = __webpack_require__(6);
var $export = __webpack_require__(0);
var redefine = __webpack_require__(15);
var META = __webpack_require__(32).KEY;
var $fails = __webpack_require__(3);
var shared = __webpack_require__(58);
var setToStringTag = __webpack_require__(48);
var uid = __webpack_require__(39);
var wks = __webpack_require__(5);
var wksExt = __webpack_require__(105);
var wksDefine = __webpack_require__(76);
var enumKeys = __webpack_require__(173);
var isArray = __webpack_require__(61);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var toIObject = __webpack_require__(18);
var toPrimitive = __webpack_require__(25);
var createDesc = __webpack_require__(38);
var _create = __webpack_require__(42);
var gOPNExt = __webpack_require__(108);
var $GOPD = __webpack_require__(19);
var $DP = __webpack_require__(7);
var $keys = __webpack_require__(40);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(43).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(53).f = $propertyIsEnumerable;
  __webpack_require__(60).f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(33)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(14)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(40);
var gOPS = __webpack_require__(60);
var pIE = __webpack_require__(53);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(42) });


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(6), 'Object', { defineProperty: __webpack_require__(7).f });


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(6), 'Object', { defineProperties: __webpack_require__(107) });


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(18);
var $getOwnPropertyDescriptor = __webpack_require__(19).f;

__webpack_require__(28)('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(9);
var $getPrototypeOf = __webpack_require__(20);

__webpack_require__(28)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(9);
var $keys = __webpack_require__(40);

__webpack_require__(28)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(28)('getOwnPropertyNames', function () {
  return __webpack_require__(108).f;
});


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(32).onFreeze;

__webpack_require__(28)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(32).onFreeze;

__webpack_require__(28)('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(4);
var meta = __webpack_require__(32).onFreeze;

__webpack_require__(28)('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(4);

__webpack_require__(28)('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(4);

__webpack_require__(28)('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(4);

__webpack_require__(28)('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});


/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(109) });


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { is: __webpack_require__(189) });


/***/ }),
/* 189 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(80).set });


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(54);
var test = {};
test[__webpack_require__(5)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(15)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', { bind: __webpack_require__(110) });


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(7).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(6) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(4);
var getPrototypeOf = __webpack_require__(20);
var HAS_INSTANCE = __webpack_require__(5)('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(7).f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(112);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(113);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(2);
var has = __webpack_require__(17);
var cof = __webpack_require__(23);
var inheritIfRequired = __webpack_require__(82);
var toPrimitive = __webpack_require__(25);
var fails = __webpack_require__(3);
var gOPN = __webpack_require__(43).f;
var gOPD = __webpack_require__(19).f;
var dP = __webpack_require__(7).f;
var $trim = __webpack_require__(49).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(42)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(6) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(15)(global, NUMBER, $Number);
}


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toInteger = __webpack_require__(27);
var aNumberValue = __webpack_require__(114);
var repeat = __webpack_require__(83);
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(3)(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $fails = __webpack_require__(3);
var aNumberValue = __webpack_require__(114);
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(0);
var _isFinite = __webpack_require__(2).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', { isInteger: __webpack_require__(115) });


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(0);
var isInteger = __webpack_require__(115);
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseFloat = __webpack_require__(113);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $parseInt = __webpack_require__(112);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0);
var log1p = __webpack_require__(116);
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0);
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0);
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0);
var sign = __webpack_require__(84);

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0);
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0);
var $expm1 = __webpack_require__(85);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { fround: __webpack_require__(117) });


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = __webpack_require__(0);
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0);
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { log1p: __webpack_require__(116) });


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', { sign: __webpack_require__(84) });


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(85);
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(3)(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0);
var expm1 = __webpack_require__(85);
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toAbsoluteIndex = __webpack_require__(41);
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(18);
var toLength = __webpack_require__(8);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(49)('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(86)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(87)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $at = __webpack_require__(86)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(8);
var context = __webpack_require__(89);
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(90)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export = __webpack_require__(0);
var context = __webpack_require__(89);
var INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(90)(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(83)
});


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export = __webpack_require__(0);
var toLength = __webpack_require__(8);
var context = __webpack_require__(89);
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(90)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(16)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(16)('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(16)('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(16)('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(16)('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(16)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(16)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(16)('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(16)('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(16)('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(16)('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(16)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(16)('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(25);

$export($export.P + $export.F * __webpack_require__(3)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0);
var toISOString = __webpack_require__(251);

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = __webpack_require__(3);
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(15)(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}


/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(5)('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) __webpack_require__(14)(proto, TO_PRIMITIVE, __webpack_require__(254));


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(25);
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};


/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', { isArray: __webpack_require__(61) });


/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(22);
var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var call = __webpack_require__(118);
var isArrayIter = __webpack_require__(91);
var toLength = __webpack_require__(8);
var createProperty = __webpack_require__(92);
var getIterFn = __webpack_require__(93);

$export($export.S + $export.F * !__webpack_require__(63)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var createProperty = __webpack_require__(92);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(3)(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export = __webpack_require__(0);
var toIObject = __webpack_require__(18);
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(52) != Object || !__webpack_require__(24)(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var html = __webpack_require__(79);
var cof = __webpack_require__(23);
var toAbsoluteIndex = __webpack_require__(41);
var toLength = __webpack_require__(8);
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(3)(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var toObject = __webpack_require__(9);
var fails = __webpack_require__(3);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(24)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $forEach = __webpack_require__(29)(0);
var STRICT = __webpack_require__(24)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(4);
var isArray = __webpack_require__(61);
var SPECIES = __webpack_require__(5)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $map = __webpack_require__(29)(1);

$export($export.P + $export.F * !__webpack_require__(24)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $filter = __webpack_require__(29)(2);

$export($export.P + $export.F * !__webpack_require__(24)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $some = __webpack_require__(29)(3);

$export($export.P + $export.F * !__webpack_require__(24)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $every = __webpack_require__(29)(4);

$export($export.P + $export.F * !__webpack_require__(24)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $reduce = __webpack_require__(119);

$export($export.P + $export.F * !__webpack_require__(24)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $reduce = __webpack_require__(119);

$export($export.P + $export.F * !__webpack_require__(24)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $indexOf = __webpack_require__(59)(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(24)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});


/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toIObject = __webpack_require__(18);
var toInteger = __webpack_require__(27);
var toLength = __webpack_require__(8);
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(24)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { copyWithin: __webpack_require__(120) });

__webpack_require__(34)('copyWithin');


/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', { fill: __webpack_require__(95) });

__webpack_require__(34)('fill');


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(29)(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(34)(KEY);


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0);
var $find = __webpack_require__(29)(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(34)(KEY);


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(44)('Array');


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(2);
var inheritIfRequired = __webpack_require__(82);
var dP = __webpack_require__(7).f;
var gOPN = __webpack_require__(43).f;
var isRegExp = __webpack_require__(62);
var $flags = __webpack_require__(64);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(6) && (!CORRECT_NEW || __webpack_require__(3)(function () {
  re2[__webpack_require__(5)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(15)(global, 'RegExp', $RegExp);
}

__webpack_require__(44)('RegExp');


/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(122);
var anObject = __webpack_require__(1);
var $flags = __webpack_require__(64);
var DESCRIPTORS = __webpack_require__(6);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(15)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(3)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(65)('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(65)('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});


/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(65)('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(65)('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = __webpack_require__(62);
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});


/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(33);
var global = __webpack_require__(2);
var ctx = __webpack_require__(22);
var classof = __webpack_require__(54);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var aFunction = __webpack_require__(10);
var anInstance = __webpack_require__(45);
var forOf = __webpack_require__(46);
var speciesConstructor = __webpack_require__(66);
var task = __webpack_require__(97).set;
var microtask = __webpack_require__(98)();
var newPromiseCapabilityModule = __webpack_require__(99);
var perform = __webpack_require__(123);
var userAgent = __webpack_require__(67);
var promiseResolve = __webpack_require__(124);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(5)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(47)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(48)($Promise, PROMISE);
__webpack_require__(44)(PROMISE);
Wrapper = __webpack_require__(21)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(63)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(129);
var validate = __webpack_require__(51);
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
__webpack_require__(68)(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);


/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var $typed = __webpack_require__(69);
var buffer = __webpack_require__(100);
var anObject = __webpack_require__(1);
var toAbsoluteIndex = __webpack_require__(41);
var toLength = __webpack_require__(8);
var isObject = __webpack_require__(4);
var ArrayBuffer = __webpack_require__(2).ArrayBuffer;
var speciesConstructor = __webpack_require__(66);
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(3)(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(44)(ARRAY_BUFFER);


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(69).ABV, {
  DataView: __webpack_require__(100).DataView
});


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(30)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(0);
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var rApply = (__webpack_require__(2).Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(3)(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(0);
var create = __webpack_require__(42);
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);
var fails = __webpack_require__(3);
var bind = __webpack_require__(110);
var rConstruct = (__webpack_require__(2).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(7);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var toPrimitive = __webpack_require__(25);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(3)(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(0);
var gOPD = __webpack_require__(19).f;
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
__webpack_require__(88)(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(19);
var getPrototypeOf = __webpack_require__(20);
var has = __webpack_require__(17);
var $export = __webpack_require__(0);
var isObject = __webpack_require__(4);
var anObject = __webpack_require__(1);

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(19);
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(0);
var getProto = __webpack_require__(20);
var anObject = __webpack_require__(1);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', { ownKeys: __webpack_require__(131) });


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(0);
var anObject = __webpack_require__(1);
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(7);
var gOPD = __webpack_require__(19);
var getPrototypeOf = __webpack_require__(20);
var has = __webpack_require__(17);
var $export = __webpack_require__(0);
var createDesc = __webpack_require__(38);
var anObject = __webpack_require__(1);
var isObject = __webpack_require__(4);

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(0);
var setProto = __webpack_require__(80);

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export = __webpack_require__(0);
var $includes = __webpack_require__(59)(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(34)('includes');


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(132);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(8);
var aFunction = __webpack_require__(10);
var arraySpeciesCreate = __webpack_require__(94);

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(34)('flatMap');


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = __webpack_require__(0);
var flattenIntoArray = __webpack_require__(132);
var toObject = __webpack_require__(9);
var toLength = __webpack_require__(8);
var toInteger = __webpack_require__(27);
var arraySpeciesCreate = __webpack_require__(94);

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

__webpack_require__(34)('flatten');


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(0);
var $at = __webpack_require__(86)(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(133);
var userAgent = __webpack_require__(67);

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0);
var $pad = __webpack_require__(133);
var userAgent = __webpack_require__(67);

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(49)('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(49)('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/
var $export = __webpack_require__(0);
var defined = __webpack_require__(26);
var toLength = __webpack_require__(8);
var isRegExp = __webpack_require__(62);
var getFlags = __webpack_require__(64);
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

__webpack_require__(88)($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(76)('asyncIterator');


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(76)('observable');


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(0);
var ownKeys = __webpack_require__(131);
var toIObject = __webpack_require__(18);
var gOPD = __webpack_require__(19);
var createProperty = __webpack_require__(92);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $values = __webpack_require__(134)(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0);
var $entries = __webpack_require__(134)(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var aFunction = __webpack_require__(10);
var $defineProperty = __webpack_require__(7);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(6) && $export($export.P + __webpack_require__(70), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var aFunction = __webpack_require__(10);
var $defineProperty = __webpack_require__(7);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(6) && $export($export.P + __webpack_require__(70), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(25);
var getPrototypeOf = __webpack_require__(20);
var getOwnPropertyDescriptor = __webpack_require__(19).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(6) && $export($export.P + __webpack_require__(70), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0);
var toObject = __webpack_require__(9);
var toPrimitive = __webpack_require__(25);
var getPrototypeOf = __webpack_require__(20);
var getOwnPropertyDescriptor = __webpack_require__(19).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(6) && $export($export.P + __webpack_require__(70), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(135)('Map') });


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(0);

$export($export.P + $export.R, 'Set', { toJSON: __webpack_require__(135)('Set') });


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(71)('Map');


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
__webpack_require__(71)('Set');


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(71)('WeakMap');


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
__webpack_require__(71)('WeakSet');


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(72)('Map');


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
__webpack_require__(72)('Set');


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(72)('WeakMap');


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
__webpack_require__(72)('WeakSet');


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.G, { global: __webpack_require__(2) });


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', { global: __webpack_require__(2) });


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0);
var cof = __webpack_require__(23);

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var scale = __webpack_require__(137);
var fround = __webpack_require__(117);

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

// https://rwaldron.github.io/proposal-math-extensions/
var $export = __webpack_require__(0);

$export($export.S, 'Math', { scale: __webpack_require__(137) });


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

// http://jfbastien.github.io/papers/Math.signbit.html
var $export = __webpack_require__(0);

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(0);
var core = __webpack_require__(21);
var global = __webpack_require__(2);
var speciesConstructor = __webpack_require__(66);
var promiseResolve = __webpack_require__(124);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(0);
var newPromiseCapability = __webpack_require__(99);
var perform = __webpack_require__(123);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(20);
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

var Set = __webpack_require__(127);
var from = __webpack_require__(136);
var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(20);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var getPrototypeOf = __webpack_require__(20);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

var metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

var $metadata = __webpack_require__(31);
var anObject = __webpack_require__(1);
var aFunction = __webpack_require__(10);
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = __webpack_require__(0);
var microtask = __webpack_require__(98)();
var process = __webpack_require__(2).process;
var isNode = __webpack_require__(23)(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable
var $export = __webpack_require__(0);
var global = __webpack_require__(2);
var core = __webpack_require__(21);
var microtask = __webpack_require__(98)();
var OBSERVABLE = __webpack_require__(5)('observable');
var aFunction = __webpack_require__(10);
var anObject = __webpack_require__(1);
var anInstance = __webpack_require__(45);
var redefineAll = __webpack_require__(47);
var hide = __webpack_require__(14);
var forOf = __webpack_require__(46);
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

__webpack_require__(44)('Observable');


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(2);
var $export = __webpack_require__(0);
var userAgent = __webpack_require__(67);
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
var $task = __webpack_require__(97);
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(96);
var getKeys = __webpack_require__(40);
var redefine = __webpack_require__(15);
var global = __webpack_require__(2);
var hide = __webpack_require__(14);
var Iterators = __webpack_require__(50);
var wks = __webpack_require__(5);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(57)))

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(370);
module.exports = __webpack_require__(21).RegExp.escape;


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(0);
var $re = __webpack_require__(371)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });


/***/ }),
/* 371 */
/***/ (function(module, exports) {

module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};


/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebGL2SpecialLayers = exports.OperationCodeAttrsMap = exports.OperationCodeToLayersMap = undefined;

var _layers = __webpack_require__(140);

var layers = _interopRequireWildcard(_layers);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _Enums = __webpack_require__(37);

var _Layer = __webpack_require__(12);

var _Layer2 = _interopRequireDefault(_Layer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var OperandCodeMap = new Map([[_Enums.OperandCode.TENSOR_FLOAT32, Float32Array], [_Enums.OperandCode.TENSOR_INT32, Int32Array]]);

var PaddingCodeMap = new Map([[_Enums.PaddingCode.SAME, 'SAME'], [_Enums.PaddingCode.VALID, 'VALID']]);

var FuseCodeMap = new Map([[_Enums.FuseCode.NONE, 'NONE'], [_Enums.FuseCode.RELU, 'RELU'], [_Enums.FuseCode.RELU1, 'RELU1'], [_Enums.FuseCode.RELU6, 'RELU6']]);

/**
 * Get add attributes.
 * 
 * @param {Object[]} nnOperands - An array of operands.
 * @param {number[]} inputs - [input0Code, input1Code, fuseCode].
 * @param {number[]} outputs - [outputCode].
 */
function GetAddAttrs(nnOperands, inputs, outputs) {
  var attrs = {
    inputs: inputs.slice(0, 2),
    outputs: outputs,
    activation: FuseCodeMap.get(nnOperands[inputs[2]].value[0])
  };
  return attrs;
}

/**
 * Get mul attributes.
 * 
 * @param {Object[]} nnOperands - An array of operands.
 * @param {number[]} inputs - [input0Code, input1Code, fuseCode].
 * @param {number[]} outputs - [outputCode].
 */
function GetMulAttrs(nnOperands, inputs, outputs) {
  var attrs = {
    inputs: inputs.slice(0, 2),
    outputs: outputs,
    activation: FuseCodeMap.get(nnOperands[inputs[2]].value[0])
  };
  return attrs;
}

/**
 * Get conv2D attributes.
 * 
 * @param {Object[]} nnOperands - An array of operands.
 * @param {number[]} inputs - [inputCode, kernelCode, biasCode, 
 *                             paddingCodeCode, strideWCode, strideHCode, fuseCode]
 *                             or 
 *                            [inputCode, kernelCode, biasCode, 
 *                             paddingWidthBeginCode, paddingWidthEndCode, paddingHeightBeginCode, paddingHeightEndCode, 
 *                             strideXCode, strideYCode, fuseCode]
 * @param {number[]} outputs - [outputCode].
 */
function GetConv2DAttrs(nnOperands, inputs, outputs) {
  var kernel = nnOperands[inputs[1]];
  var use_bias = false;
  var biasTensor = null;

  if (true) {
    use_bias = true;
    var bias = nnOperands[inputs[2]];
    biasTensor = new _Tensor2.default(bias.value, bias.dimensions, OperandCodeMap.get(bias.type));
  }
  var kernelTensor = new _Tensor2.default(kernel.value, kernel.dimensions, OperandCodeMap.get(kernel.type));
  var strideHW = void 0;
  var padding = void 0;
  var activation = void 0;
  if (inputs.length === 7) {
    padding = PaddingCodeMap.get(nnOperands[inputs[3]].value[0]);
    strideHW = [nnOperands[inputs[5]].value[0], nnOperands[inputs[4]].value[0]];
    activation = FuseCodeMap.get(nnOperands[inputs[6]].value[0]);
  } else if (inputs.length === 10) {
    var pad1 = nnOperands[inputs[3]].value[0];
    var pad2 = nnOperands[inputs[4]].value[0];
    var pad3 = nnOperands[inputs[5]].value[0];
    var pad4 = nnOperands[inputs[6]].value[0];
    padding = [pad3, pad4, pad1, pad2];
    // console.log(padding)
    strideHW = [nnOperands[inputs[7]].value[0], nnOperands[inputs[8]].value[0]];
    activation = FuseCodeMap.get(nnOperands[inputs[9]].value[0]);
  } else {
    throw new Error('[GetConv2DAttrs] Wrong inputs length: ' + inputs.length);
  }

  var weights = [kernelTensor].concat(_toConsumableArray(use_bias ? [biasTensor] : []));
  var attrs = {
    inputs: [inputs[0]],
    outputs: outputs,
    filters: kernel.dimensions[0],
    kernel_size: kernel.dimensions.slice(1, 3),
    strides: strideHW,
    padding: padding,
    activation: activation,
    use_bias: use_bias,
    weights: weights
  };
  // console.log(attrs);
  return attrs;
}

/**
 * Get depthwiseConv2D attributes.
 * 
 * @param {Object[]} nnOperands - An array of operands.
 * @param {number[]} inputs - [inputCode, kernelCode, biasCode, paddingCodeCode,  
 *                             strideWCode, strideHCode, depthMultiplierCode, fuseCode].
 * @param {number[]} outputs - [outputCode].
 */
function GetDepthwiseConv2DAttrs(nnOperands, inputs, outputs) {
  var kernel = nnOperands[inputs[1]];
  var use_bias = false;
  var biasTensor = null;

  if (true) {
    use_bias = true;
    var bias = nnOperands[inputs[2]];
    biasTensor = new _Tensor2.default(bias.value, bias.dimensions, OperandCodeMap.get(bias.type));
  }

  var kernelTensor = new _Tensor2.default(kernel.value, kernel.dimensions, OperandCodeMap.get(kernel.type));
  var strideHW = void 0;
  var padding = void 0;
  var activation = void 0;
  var depthMultiplier = void 0;
  if (inputs.length === 8) {
    padding = PaddingCodeMap.get(nnOperands[inputs[3]].value[0]);
    strideHW = [nnOperands[inputs[5]].value[0], nnOperands[inputs[4]].value[0]];
    depthMultiplier = nnOperands[inputs[6]].value[0];
    activation = FuseCodeMap.get(nnOperands[inputs[7]].value[0]);
  } else if (inputs.length === 11) {
    var pad1 = nnOperands[inputs[3]].value[0];
    var pad2 = nnOperands[inputs[4]].value[0];
    var pad3 = nnOperands[inputs[5]].value[0];
    var pad4 = nnOperands[inputs[6]].value[0];
    padding = [pad3, pad4, pad1, pad2];
    // console.log(padding)
    strideHW = [nnOperands[inputs[8]].value[0], nnOperands[inputs[7]].value[0]];
    depthMultiplier = nnOperands[inputs[9]].value[0];
    activation = FuseCodeMap.get(nnOperands[inputs[10]].value[0]);
  } else {
    throw new Error('[GetDepthwiseConv2DAttrs] Wrong inputs length: ' + inputs.length);
  }

  var weights = [kernelTensor].concat(_toConsumableArray(use_bias ? [biasTensor] : []));
  var attrs = {
    inputs: [inputs[0]],
    outputs: outputs,
    filters: kernel.dimensions[0],
    kernel_size: kernel.dimensions.slice(1, 3),
    strides: strideHW,
    padding: padding,
    depthMultiplier: depthMultiplier,
    activation: activation,
    use_bias: use_bias,
    weights: weights
  };
  // console.log(attrs);
  return attrs;
}

/**
 * Get MaxPool2D attributes.
 * 
 * @param {Object[]} nnOperands - An array of operands.
 * @param {number[]} inputs - 
 *                             [inputCode, paddingCodeCode, strideWCode, strideHCode, 
 *                             kernelWidthCode, kernelHeightCode, fuseCode].
 *                             or
 *                             [inputCode, paddingWidthBeginCode, paddingWidthEndCode, 
 *                             paddingHeightBeginCode, paddingHeightEnd, strideWCode, strideHCode,
 *                             kernelWidthCode, kernelHeightCode, fuseCode].
 * @param {number[]} outputs - [outputCode].
 */
function GetPool2DAttrs(nnOperands, inputs, outputs) {
  var padding = void 0;
  var strideHW = void 0;
  var kernelShapeHW = void 0;
  var activation = void 0;

  if (inputs.length === 7) {
    padding = PaddingCodeMap.get(nnOperands[inputs[1]].value[0]);
    strideHW = [nnOperands[inputs[3]].value[0], nnOperands[inputs[2]].value[0]];
    kernelShapeHW = [nnOperands[inputs[5]].value[0], nnOperands[inputs[4]].value[0]];
    activation = FuseCodeMap.get(nnOperands[inputs[6]].value[0]);
  } else if (inputs.length === 10) {
    var pad1 = nnOperands[inputs[1]].value[0];
    var pad2 = nnOperands[inputs[2]].value[0];
    var pad3 = nnOperands[inputs[3]].value[0];
    var pad4 = nnOperands[inputs[4]].value[0];
    padding = [pad3, pad4, pad1, pad2];
    strideHW = [nnOperands[inputs[6]].value[0], nnOperands[inputs[5]].value[0]];
    kernelShapeHW = [nnOperands[inputs[8]].value[0], nnOperands[inputs[7]].value[0]];
    activation = FuseCodeMap.get(nnOperands[inputs[9]].value[0]);
  } else {
    throw new Error('[GetConv2DAttrs] Wrong inputs length: ' + inputs.length);
  }

  var attrs = {
    inputs: [inputs[0]],
    outputs: outputs,
    kernel_size: kernelShapeHW,
    strides: strideHW,
    padding: padding,
    activation: activation
  };
  // console.log(attrs);
  return attrs;
}

/**
 * Get softmax attributes.
 * 
 * @param {Object[]} nnOperands - An array of operands.
 * @param {number[]} inputs - [inputCode, betaCode].
 * @param {number[]} outputs - [outputCode].
 */
function GetSoftmaxAttrs(nnOperands, inputs, outputs) {
  var attrs = {
    inputs: [inputs[0]],
    outputs: outputs,
    beta: nnOperands[inputs[1]].value[0],
    activation: 'softmax'
  };
  // console.log(attrs);
  return attrs;
}

/**
 * Get reshape attributes.
 * 
 * @param {Object[]} nnOperands - An array of operands.
 * @param {number[]} inputs - [inputCode].
 * @param {number[]} outputs - [outputCode].
 */
function GetReshapeAttrs(nnOperands, inputs, outputs) {
  var attrs = {
    inputs: [inputs[0]],
    outputs: outputs,
    target_shape: []
  };
  // console.log(attrs);
  return attrs;
}

/**
 * Get Concatenation attributes.
 * 
 * @param {Object[]} nnOperands - An array of operands.
 * @param {number[]} inputs - [inputCode].
 * @param {number[]} outputs - [outputCode].
 */
function GetConcatenationAttrs(nnOperands, inputs, outputs) {
  var attrs = {
    inputs: inputs.slice(0, inputs.length - 1),
    outputs: outputs,
    axis: nnOperands[inputs[inputs.length - 1]].value[0]
  };
  // console.log(attrs);
  return attrs;
}

var OperationCodeToLayersMap = exports.OperationCodeToLayersMap = new Map([[_Enums.OperationCode.ADD, layers.Add], [_Enums.OperationCode.MUL, layers.Mul], [_Enums.OperationCode.CONV_2D, layers.Conv2D], [_Enums.OperationCode.DEPTHWISE_CONV_2D, layers.DepthwiseConv2D], [_Enums.OperationCode.MAX_POOL_2D, layers.MaxPool2D], [_Enums.OperationCode.AVERAGE_POOL_2D, layers.AveragePool2D], [_Enums.OperationCode.SOFTMAX, layers.Activation], [_Enums.OperationCode.RESHAPE, layers.Reshape], [_Enums.OperationCode.CONCATENATION, layers.Concatenation]]);

var OperationCodeAttrsMap = exports.OperationCodeAttrsMap = new Map([[_Enums.OperationCode.ADD, GetAddAttrs], [_Enums.OperationCode.MUL, GetMulAttrs], [_Enums.OperationCode.CONV_2D, GetConv2DAttrs], [_Enums.OperationCode.DEPTHWISE_CONV_2D, GetDepthwiseConv2DAttrs], [_Enums.OperationCode.MAX_POOL_2D, GetPool2DAttrs], [_Enums.OperationCode.AVERAGE_POOL_2D, GetPool2DAttrs], [_Enums.OperationCode.SOFTMAX, GetSoftmaxAttrs], [_Enums.OperationCode.RESHAPE, GetReshapeAttrs], [_Enums.OperationCode.CONCATENATION, GetConcatenationAttrs]]);

var WebGL2SpecialLayers = exports.WebGL2SpecialLayers = {
  Input: layers.Input,
  TopClasses: layers.TopClasses,
  FeatureMapConcate: layers.FeatureMapConcate
};

// webgl2 operation test

// let inputShape = [100, 50, 3]
// let inputShapeLen = inputShape.reduce((i, j) => i * j);
// let inputValue = [];
// for (let i =  0; i < inputShapeLen; ++i) {
//   inputValue.push(1/10000);
// }
// let inputTensor = new Tensor(inputValue, inputShape, Float32Array);
// inputTensor.reshapeTo2D();
// inputTensor.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });

// let max = new layers.MaxPool2D({
//   inputs: [0],
//   outputs: [0],
//   kernel_size: [3, 3],
//   strides: [1, 1],
//   padding: [1,1,1,1]
// })

// let kernelValue = [];
// let kernelShape = [1, 3, 3, inputShape[2]];
// let kernelValueLen = kernelShape.reduce((i, j) => i * j);
// for (let i =  0; i < kernelValueLen; ++i) {
//   kernelValue.push(i);
// }

// let biasValue = [];
// let biasValueLen = kernelShape[0];
// for (let i =  0; i < biasValueLen; ++i) {
//   biasValue.push(i);
// }

// let use_bias = false;
// let biasTensor = new Tensor(biasValue, [biasValueLen], Float32Array);
// let kernelTensor = new Tensor(kernelValue, kernelShape, Float32Array);
// let weights = [kernelTensor, ...(use_bias? [biasTensor] : [])];

// let conv = new layers.Conv2D({
//   inputs: [0],
//   outputs: [0],
//   filters: kernelShape[0],
//   kernel_size: kernelShape.slice(1,3),
//   strides: [1, 1],
//   padding: 'VALID',
//   activation: 'RELU',
//   use_bias: use_bias,
//   weights: weights
// })

// console.log(inputTensor)
// let maxOutput = max.call(inputTensor);
// maxOutput.transferFromGLTexture();
// console.log('max', maxOutput.tensor)

// let conOutput = conv.call(inputTensor);
// conOutput.transferFromGLTexture();
// console.log('conv', conOutput)

// conOutput = conv.call(conOutput);
// conOutput.transferFromGLTexture();
// console.log('conv', conOutput)

// let input1Shape = [100, 100, 2]
// let input1ShapeLen = input1Shape.reduce((i, j) => i * j);
// let input1Value = [];
// for (let i =  0; i < input1ShapeLen; ++i) {
//   input1Value.push(i/100);
// }
// let input1Tensor = new Tensor(input1Value, input1Shape, Float32Array);
// input1Tensor.reshapeTo2D();
// input1Tensor.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });

// let input2Shape = [100, 100, 2]
// let input2ShapeLen = input2Shape.reduce((i, j) => i * j);
// let input2Value = [];
// for (let i =  0; i < input2ShapeLen; ++i) {
//   input2Value.push(i/100);
// }
// let input2Tensor = new Tensor(input2Value, input2Shape, Float32Array);
// input2Tensor.reshapeTo2D();
// input2Tensor.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });

// let concate = new layers.Concatenation({
//   inputs: [0],
//   outputs: [0]
// })

// let output1 = concate.call([input1Tensor, input2Tensor]);
// output1.transferFromGLTexture();
// console.log('concate', output1)

// let inputLayer1 = new layers.Input()
// let inputLayer2 = new layers.Input()
// let out1 = inputLayer1.call(input1Value, input1Shape, Float32Array)
// let out2 = inputLayer2.call(input2Value, input2Shape, Float32Array)
// let concatetest = new layers.Concatenation({
//   inputs: [0],
//   outputs: [0]
// })

// let output2 = concate.call([out1, out2]);
// output2.transferFromGLTexture();
// console.log('inputLayer concate', output2)

// let output3 = new Tensor(output2.tensor.data, [100, 100, 4], Float32Array);
// // output2.is2DReshaped = false;
// let conOutput = conv.call(output2);
// conOutput.transferFromGLTexture();
// console.log('conv', conOutput)

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DepthwiseConv2D = exports.Conv2D = undefined;

var _Conv2D = __webpack_require__(374);

var _Conv2D2 = _interopRequireDefault(_Conv2D);

var _DepthwiseConv2D = __webpack_require__(385);

var _DepthwiseConv2D2 = _interopRequireDefault(_DepthwiseConv2D);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Conv2D = _Conv2D2.default;
exports.DepthwiseConv2D = _DepthwiseConv2D2.default;

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _activation = __webpack_require__(55);

var activations = _interopRequireWildcard(_activation);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _tensorUtils = __webpack_require__(35);

var tensorUtils = _interopRequireWildcard(_tensorUtils);

var _ndarrayOps = __webpack_require__(36);

var _ndarrayOps2 = _interopRequireDefault(_ndarrayOps);

var _matMul = __webpack_require__(143);

var _matMul2 = _interopRequireDefault(_matMul);

var _conv2d = __webpack_require__(144);

var _conv2d2 = _interopRequireDefault(_conv2d);

var _fuse = __webpack_require__(56);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Conv2D layer class
 */
var Conv2D = function (_Layer) {
  _inherits(Conv2D, _Layer);

  /**
   * Creates a Conv2D layer
   *
   * @param {Object} [attrs] - layer config attributes
   * @param {number} [attrs.filters] - Number of convolution filters to use
   * @param {number|number[]} [attrs.kernel_size] - Size of the convolution kernel
   */
  function Conv2D() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Conv2D);

    var _this = _possibleConstructorReturn(this, (Conv2D.__proto__ || Object.getPrototypeOf(Conv2D)).call(this, attrs));

    _this.name = 'Conv2D';

    var _attrs$filters = attrs.filters,
        filters = _attrs$filters === undefined ? 1 : _attrs$filters,
        _attrs$kernel_size = attrs.kernel_size,
        kernel_size = _attrs$kernel_size === undefined ? [3, 3] : _attrs$kernel_size,
        _attrs$strides = attrs.strides,
        strides = _attrs$strides === undefined ? [1, 1] : _attrs$strides,
        _attrs$padding = attrs.padding,
        padding = _attrs$padding === undefined ? 'VALID' : _attrs$padding,
        _attrs$data_format = attrs.data_format,
        data_format = _attrs$data_format === undefined ? 'NHWC' : _attrs$data_format,
        _attrs$dilation_rate = attrs.dilation_rate,
        dilation_rate = _attrs$dilation_rate === undefined ? [1, 1] : _attrs$dilation_rate,
        _attrs$activation = attrs.activation,
        activation = _attrs$activation === undefined ? 'NONE' : _attrs$activation,
        _attrs$use_bias = attrs.use_bias,
        use_bias = _attrs$use_bias === undefined ? true : _attrs$use_bias,
        _attrs$weights = attrs.weights,
        weights = _attrs$weights === undefined ? [] : _attrs$weights;


    if (Array.isArray(kernel_size)) {
      _this.kernelShape = [filters].concat(_toConsumableArray(kernel_size));
    } else {
      _this.kernelShape = [filters, kernel_size, kernel_size];
    }

    if (Array.isArray(strides)) {
      _this.strides = strides;
    } else {
      _this.strides = [strides, strides];
    }

    if (Array.isArray(padding)) {
      if (padding.length !== 4) {
        _this.throwError('Invalid padding.');
        // If all numbers in padding are 0, use padding = 'VALID'
      } else if (padding.every(function (x) {
        return !x;
      })) {
        _this.padding = 'VALID';
      } else {
        _this.padding = padding;
      }
    } else if (padding === 'VALID' || padding === 'SAME') {
      _this.padding = padding;
    } else {
      _this.throwError('Invalid padding.');
    }

    _this.pointwise = false;
    if (_this.kernelShape[1] === 1 && _this.kernelShape[2] === 1 && _this.strides[0] === 1 && _this.strides[1] === 1 && (padding === 'VALID' || padding === 'SAME')) {
      _this.pointwise = true;
    }

    if (data_format === 'NHWC' || data_format === 'NCHW') {
      _this.dataFormat = data_format;
    } else {
      _this.throwError('Only NHWC and NCHW data formats are allowed.');
    }

    if (Array.isArray(dilation_rate)) {
      _this.dilationRate = dilation_rate;
    } else {
      _this.dilationRate = [dilation_rate, dilation_rate];
    }
    if ((_this.dilationRate[0] !== 1 || _this.dilationRate[1] !== 1) && (_this.strides[0] !== 1 || _this.strides[1] !== 1)) {
      // Currently, specifying any dilation_rate value != 1 is incompatible with specifying any stride value != 1
      _this.throwError('Incompatible combination of dilation_rate with strides.');
    }

    _this.activation = activation;
    _this.fuseActivation = _fuse.fuseShaderSource[_this.activation];

    _this.useBias = use_bias;
    _this._setWeights(weights);
    return _this;
  }

  /**
   * Method for setting layer weights. Extends `super` method.
   *
   * @param {Tensor[]} weightsArr - array of weights which are instances of Tensor
   */


  _createClass(Conv2D, [{
    key: '_setWeights',
    value: function _setWeights(weightsArr) {
      var params = this.useBias ? ['kernel', 'bias'] : ['kernel'];

      if (this.dataFormat === 'NCHW') {
        weightsArr[0].tensor = weightsArr[0].tensor.transpose(0, 2, 3, 1);
      }

      _get(Conv2D.prototype.__proto__ || Object.getPrototypeOf(Conv2D.prototype), 'setWeights', this).call(this, params, weightsArr, false);
      this._w2row();
      this.weights['kernel'] = this.wRowsMat;
      this.weights['kernel'].createGLTexture({ type: '2d', format: 'float' });
      // console.log(`webgl2.MAX_TEXTURE_SIZE: ${webgl2.MAX_TEXTURE_SIZE}`)
      // console.log(this.weights['kernel'])
      if (this.useBias) {
        this.weights['bias'].createGLTexture({ type: '2d', format: 'float' });
      }
    }

    /**
     * Method for computing output dimensions and padding, 
     * based on input dimensions, kernel size, and padding mode.
     *
     * @param {number[]} inputShape
     */

  }, {
    key: '_calcOutputShape',
    value: function _calcOutputShape(inputShape) {
      if (this.outputShape && this.inputPadding) {
        return;
      }

      var inputHeight = inputShape[0];
      var inputWidth = inputShape[1];

      var _kernelShape = _slicedToArray(this.kernelShape, 3),
          filter = _kernelShape[0],
          kernelH = _kernelShape[1],
          kernelW = _kernelShape[2];

      // effective shape after filter dilation


      var kernelHDilated = kernelH + (kernelH - 1) * (this.dilationRate[0] - 1);
      var kernelWDilated = kernelW + (kernelW - 1) * (this.dilationRate[1] - 1);

      if (Array.isArray(this.padding)) {
        var outputHeight = (inputHeight - kernelHDilated + this.padding[0] + this.padding[1] + this.strides[0]) / this.strides[0];
        var outputWidth = (inputWidth - kernelWDilated + this.padding[2] + this.padding[3] + this.strides[1]) / this.strides[1];
        this.outputShape = [outputHeight, outputWidth, filter];
        this.inputPadding = this.padding;
      } else {
        var _outputHeight = this.padding === 'SAME' ? Math.floor((inputHeight + this.strides[0] - 1) / this.strides[0]) : Math.floor((inputHeight - kernelHDilated + this.strides[0]) / this.strides[0]);
        var _outputWidth = this.padding === 'SAME' ? Math.floor((inputWidth + this.strides[1] - 1) / this.strides[1]) : Math.floor((inputWidth - kernelWDilated + this.strides[1]) / this.strides[1]);

        var paddingHeight = this.padding === 'SAME' ? Math.max(0, Math.floor((_outputHeight - 1) * this.strides[0] + kernelHDilated - inputHeight)) : 0;
        var paddingWidth = this.padding === 'SAME' ? Math.max(0, Math.floor((_outputWidth - 1) * this.strides[1] + kernelWDilated - inputWidth)) : 0;

        var paddingHeightBefore = Math.floor(paddingHeight / 2);
        var paddingHeightAfter = paddingHeight - paddingHeightBefore;
        var paddingWidthBefore = Math.floor(paddingWidth / 2);
        var paddingWidthAfter = paddingWidth - paddingWidthBefore;
        this.outputShape = [_outputHeight, _outputWidth, filter];
        this.inputPadding = [paddingHeightBefore, paddingHeightAfter, paddingWidthBefore, paddingWidthAfter];
      }
    }

    /**
     * Pad input tensor if necessary, for padding='SAME'. See above for notes on calculating padding.
     *
     * @param {Tensor} x
     * @param {number} [padValue]
     * @returns {Tensor}
     */

  }, {
    key: '_padInput',
    value: function _padInput(x) {
      var padValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (this.padding === 'SAME' || Array.isArray(this.padding)) {
        // Test all 0.
        if (this.inputPadding.every(function (x) {
          return !x;
        })) {
          return x;
        }

        var _x$tensor$shape = _slicedToArray(x.tensor.shape, 3),
            inputHeight = _x$tensor$shape[0],
            inputWidth = _x$tensor$shape[1],
            inputChannels = _x$tensor$shape[2];

        var _inputPadding = _slicedToArray(this.inputPadding, 4),
            paddingHeightBefore = _inputPadding[0],
            paddingHeightAfter = _inputPadding[1],
            paddingWidthBefore = _inputPadding[2],
            paddingWidthAfter = _inputPadding[3];

        var newHeight = inputHeight + paddingHeightBefore + paddingHeightAfter;
        var newWidth = inputWidth + paddingWidthBefore + paddingWidthAfter;
        var _x = new _Tensor2.default([], [newHeight, newWidth, inputChannels]);
        if (padValue !== 0) {
          _ndarrayOps2.default.assigns(_x.tensor, padValue);
        }
        _ndarrayOps2.default.assign(_x.tensor.hi(inputHeight + paddingHeightBefore, inputWidth + paddingWidthBefore, inputChannels).lo(paddingHeightBefore, paddingWidthBefore, 0), x.tensor);
        return _x;
      }
      return x;
    }

    /**
     * Convert input tensor to column matrix
     *
     * @param {Tensor} x
     * @returns {Tensor}
     */

  }, {
    key: '_im2col',
    value: function _im2col(x) {
      var _x$tensor$shape2 = _slicedToArray(x.tensor.shape, 3),
          inputHeight = _x$tensor$shape2[0],
          inputWidth = _x$tensor$shape2[1],
          inputChannels = _x$tensor$shape2[2];

      var kernelH = this.kernelShape[1];
      var kernelW = this.kernelShape[2];
      var outputHeight = this.outputShape[0];
      var outputWidth = this.outputShape[1];
      var nbPatches = outputHeight * outputWidth;
      var patchLen = kernelH * kernelW * inputChannels;

      // effective shape after filter dilation
      var kernelHDilated = kernelH + (kernelH - 1) * (this.dilationRate[0] - 1);
      var kernelWDilated = kernelW + (kernelW - 1) * (this.dilationRate[1] - 1);

      if (!this.imColsMat) {
        this.imColsMat = new _Tensor2.default([], [nbPatches, patchLen]);
      }

      // if Pointwise Convolution
      if (kernelHDilated === 1 && kernelWDilated === 1 && this.strides[0] === 1 && this.strides[1] === 1) {
        this.imColsMat.replaceTensorData(x.tensor.data);
        return this.imColsMat;
      }

      var patch = new _Tensor2.default([], [kernelH, kernelW, inputChannels]);
      var offset = 0;
      for (var i = 0, limit = inputHeight - kernelHDilated; i <= limit; i += this.strides[0]) {
        for (var j = 0, _limit = inputWidth - kernelWDilated; j <= _limit; j += this.strides[1]) {
          _ndarrayOps2.default.assign(patch.tensor, x.tensor.hi(i + kernelHDilated, j + kernelWDilated, inputChannels).lo(i, j, 0).step(this.dilationRate[0], this.dilationRate[1], 1));
          this.imColsMat.tensor.data.set(patch.tensor.data, offset);
          offset += patchLen;
        }
      }

      return this.imColsMat;
    }

    /**
     * Convert filter weights to row matrix
     *
     * @returns {Tensor}
     */

  }, {
    key: '_w2row',
    value: function _w2row() {
      var inputChannels = this.weights['kernel'].tensor.shape[3];

      var _kernelShape2 = _slicedToArray(this.kernelShape, 3),
          filter = _kernelShape2[0],
          kernelH = _kernelShape2[1],
          kernelW = _kernelShape2[2];

      var patchLen = kernelH * kernelW * inputChannels;

      this.wRowsMat = new _Tensor2.default([], [patchLen, filter]);

      var patch = new _Tensor2.default([], [kernelH, kernelW, inputChannels]);
      var patchRaveled = new _Tensor2.default([], [patchLen]);
      for (var n = 0; n < filter; n++) {
        _ndarrayOps2.default.assign(patch.tensor, this.weights['kernel'].tensor.pick(n, null, null, null));
        patchRaveled.replaceTensorData(patch.tensor.data);
        _ndarrayOps2.default.assign(this.wRowsMat.tensor.pick(null, n), patchRaveled.tensor);
      }

      return this.wRowsMat;
    }

    /**
     * Creates a index mapping from the 2D-reshaped input tensor with associated 3D tensor shape to the representation
     * required prior to the matrix multiply. This allows us to work directly on the 2D tensor representations rather
     * than needing to reshape to the 3D reprentation and calling im2col.
     *
     * @param {Object} indicesForReshaped
     */

  }, {
    key: '_createIndexMap',
    value: function _createIndexMap(indicesForReshaped) {
      if (this.indexMap) {
        return;
      }

      var _inputShape = _slicedToArray(this.inputShape, 3),
          inputHeight = _inputShape[0],
          inputWidth = _inputShape[1],
          inputChannels = _inputShape[2];

      var indices = new _Tensor2.default(indicesForReshaped.data, indicesForReshaped.shape, Int32Array);

      // padding
      if (this.padding === 'SAME' || Array.isArray(this.padding)) {
        var _inputPadding2 = _slicedToArray(this.inputPadding, 4),
            paddingHeightBefore = _inputPadding2[0],
            paddingHeightAfter = _inputPadding2[1],
            paddingWidthBefore = _inputPadding2[2],
            paddingWidthAfter = _inputPadding2[3];

        inputHeight = inputHeight + paddingHeightBefore + paddingHeightAfter;
        inputWidth = inputWidth + paddingWidthBefore + paddingWidthAfter;
        var padValue = -1;
        indices = this._padInput(indices, padValue);
      }

      var kernelH = this.kernelShape[1];
      var kernelW = this.kernelShape[2];
      var outputHeight = this.outputShape[0];
      var outputWidth = this.outputShape[1];
      var nbPatches = outputHeight * outputWidth;
      var patchLen = kernelH * kernelW * inputChannels;

      // effective shape after filter dilation
      var kernelHDilated = kernelH + (kernelH - 1) * (this.dilationRate[0] - 1);
      var kernelWDilated = kernelW + (kernelW - 1) * (this.dilationRate[1] - 1);
      // console.log(nbPatches, patchLen);
      this.indexMap = new _Tensor2.default([], [nbPatches, patchLen], Int32Array);

      // if Pointwise Convolution
      if (kernelHDilated === 1 && kernelWDilated === 1 && this.strides[0] === 1 && this.strides[1] === 1) {
        this.indexMap.replaceTensorData(indices.tensor.data);
      } else {
        var indicesPatch = new _Tensor2.default([], [kernelH, kernelW, inputChannels]);
        var offset = 0;
        for (var i = 0, limit = inputHeight - kernelHDilated; i <= limit; i += this.strides[0]) {
          for (var j = 0, _limit2 = inputWidth - kernelWDilated; j <= _limit2; j += this.strides[1]) {
            _ndarrayOps2.default.assign(indicesPatch.tensor, indices.tensor.hi(i + kernelHDilated, j + kernelWDilated, inputChannels).lo(i, j, 0).step(this.dilationRate[0], this.dilationRate[1], 1));
            this.indexMap.tensor.data.set(indicesPatch.tensor.data, offset);
            offset += patchLen;
          }
        }
      }
      this.indexMap.createGLTexture({ type: '2d', format: 'int', supportSliceTexture: true });
    }

    /**
     * call
     *
     * @param {Tensor} x
     */

  }, {
    key: 'call',
    value: function call(x) {
      var outputTextureShape = void 0;
      if (this.pointwise) {
        // console.log('[Conv2D] use pointwise!');
        this.inputShape = x.originalShape;
        this.outputShape = [x.originalShape[0], x.originalShape[1], this.kernelShape[0]];
        outputTextureShape = [this.outputShape[0] * this.outputShape[1], this.outputShape[2]];
      } else if (x.is2DReshaped) {
        this.inputShape = x.originalShape;
        this._calcOutputShape(this.inputShape);
        this._createIndexMap(x.indicesForReshaped);
        outputTextureShape = [this.indexMap.textureShape[0], this.weights['kernel'].textureShape[1]];
      } else {
        // console.log('[Conv2D] x is not 2DReshaped!');
        this.inputShape = x.tensor.shape;
        this._calcOutputShape(this.inputShape);
        x = this._padInput(x);
        this._im2col(x);
        if (!this.imColsMat.textureShape) {
          this.imColsMat.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
        } else {
          this.imColsMat.replaceTensorData(this.imColsMat.tensor.data);
        }
        outputTextureShape = [this.imColsMat.textureShape[0], this.weights['kernel'].textureShape[1]];
      }

      // create output textures if doesn't already exist
      if (!this.output) {
        this.output = new _Tensor2.default([], outputTextureShape);
        this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
        this.output.is2DReshaped = true;
        this.output.originalShape = this.outputShape;
        this.output.indicesForReshaped = tensorUtils.createIndicesFor2DReshaped(this.outputShape, false, -1);
      }

      if (this.pointwise) {
        // run 1x1 pointwise conv
        var matMulInputs = [{ input: x, name: 'A' }, { input: this.weights['kernel'], name: 'B' }];
        if (this.useBias) {
          matMulInputs.push({ input: this.weights['bias'], name: 'C' });
        }
        if (!this.matMulProgram) {
          this.matMulProgram = _WebGL2.default.createProgram((0, _matMul2.default)(this.fuseActivation));
        }
        _WebGL2.default.runProgram({
          program: this.matMulProgram,
          output: this.output,
          inputs: matMulInputs,
          uniforms: [{ value: this.useBias ? 1 : 0, type: 'bool', name: 'addC' }],
          supportSliceTexture: true
        });
      } else if (x.is2DReshaped) {
        // run conv2d program, which involves mapping the input using indexMap, and matrix multiply with weights
        var hasFragments = Boolean(x.textureSlices);
        if (hasFragments) {
          x.convertTextureSlicesToColStackTexture();
        }
        if (!this.conv2dProgram) {
          var conv2dProgramSource = (0, _conv2d2.default)(this.output.textureSliceShape ? this.output.textureSliceShape : this.output.textureShape, x.textureSliceShape ? x.textureSliceShape : x.textureShape, this.indexMap.textureSliceShape ? this.indexMap.textureSliceShape : this.indexMap.textureShape, this.useBias, hasFragments, this.fuseActivation);
          this.conv2dProgram = _WebGL2.default.createProgram(conv2dProgramSource);
        }
        _WebGL2.default.runProgram({
          program: this.conv2dProgram,
          output: this.output,
          inputs: [{ input: x, name: 'x' }, { input: this.indexMap, name: 'indexMap' }, { input: this.weights['kernel'], name: 'kernel' }].concat(_toConsumableArray(this.useBias ? [{ input: this.weights['bias'], name: 'bias' }] : [])),
          supportSliceTexture: true
        });
      } else {
        // run matrix multiply on result of im2col
        var _matMulInputs = [{ input: this.imColsMat, name: 'A' }, { input: this.weights['kernel'], name: 'B' }];
        if (this.useBias) {
          _matMulInputs.push({ input: this.weights['bias'], name: 'C' });
        }
        if (!this.matMulProgram) {
          this.matMulProgram = _WebGL2.default.createProgram((0, _matMul2.default)(this.fuseActivation));
        }
        _WebGL2.default.runProgram({
          program: this.matMulProgram,
          output: this.output,
          inputs: _matMulInputs,
          uniforms: [{ value: this.useBias ? 1 : 0, type: 'bool', name: 'addC' }],
          supportSliceTexture: true
        });
      }

      // convert back to channels_first ordering if necessary
      if (this.dataFormat === 'NCHW') {
        weightsArr[0].tensor = weightsArr[0].tensor.transpose(0, 3, 1, 2);
      }
      return this.output;
    }
  }]);

  return Conv2D;
}(_Layer3.default);

exports.default = Conv2D;

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota

/***/ }),
/* 376 */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createThunk = __webpack_require__(378)

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.arrayBlockIndices = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
      proc.argTypes[i] = "array"
      proc.arrayArgs.push(i)
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise


/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = __webpack_require__(379)

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
  var shapeLengthConditions = [], shapeConditions = []
  // Process array arguments
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
    code.push("}")
  }
  // Process scalar arguments
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk


/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var uniq = __webpack_require__(380)

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) { // Iteration variables
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }  
  //Scan loop
  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
    code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
          if(carg.count === 1) { // Argument/array used only once(?)
            if(dtypes[arrNum] === "generic") {
              if(carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                code = code.replace(re, localStr)
                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
            }
          } else if(dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
            }
          }
        } else { // Argument to body is a "block"
          var reStrArr = [carg.name], ptrStrArr = [ptrStr]
          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]")
            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
          }
          re = new RegExp(reStrArr.join(""), "g")
          ptrStr = ptrStrArr.join("+")
          if(dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
  }
  
  //Determine where block and loop indices start and end
  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
  var loopBegin = [], loopEnd = [] // These indices are iterated over
  var loopOrders = [] // orders restricted to the loop indices
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i]<0) {
      loopBegin.push(0)
      loopEnd.push(dimension)
      blockBegin.push(dimension)
      blockEnd.push(dimension+proc.arrayBlockIndices[i])
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
      loopEnd.push(proc.arrayBlockIndices[i]+dimension)
      blockBegin.push(0)
      blockEnd.push(proc.arrayBlockIndices[i])
    }
    var newOrder = []
    for(var j=0; j<orders[i].length; j++) {
      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }
    loopOrders.push(newOrder)
  }

  //First create arguments for procedure
  var arglist = ["SS"] // SS is the overall shape over which we iterate
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i) // Actual data array
    arglist.push("t"+i) // Strides
    arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
    
    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
    }
    
    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }
  if(proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(loopOrders)
  if(matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp


/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique


/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var RELU = exports.RELU = "#version 300 es\nprecision highp float;\nprecision highp sampler2D;\n\nin vec2 outTex;\nuniform sampler2D x;\nout vec4 outColor;\n\nvoid main() {\n  vec4 v = texture(x, vec2(outTex.x, outTex.y));\n  outColor = max(v, 0.0);\n}";

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var RELU1 = exports.RELU1 = "#version 300 es\nprecision highp float;\nprecision highp sampler2D;\n\nin vec2 outTex;\nuniform sampler2D x;\nout vec4 outColor;\n\nvoid main() {\n  vec4 v = texture(x, vec2(outTex.x, outTex.y));\n  outColor = min(max(v, -1.0), 1.0);\n}";

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var RELU6 = exports.RELU6 = "#version 300 es\nprecision highp float;\nprecision highp sampler2D;\n\nin vec2 outTex;\nuniform sampler2D x;\nout vec4 outColor;\n\nvoid main() {\n  vec4 v = texture(x, vec2(outTex.x, outTex.y));\n  outColor = min(max(v, 0.0), 6.0);\n}";

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = softmax;
function softmax(beta) {
  var source = "#version 300 es\n  precision highp float;\n  precision highp sampler2D;\n\n  in vec2 outTex;\n  uniform sampler2D x;\n  out vec4 outColor;\n\n  void main() {\n    ivec2 size = textureSize(x, 0);\n    int out_x = int(float(size[0]) * outTex.x);\n    int out_y = int(float(size[1]) * outTex.y);\n\n    float maxval = 0.0;\n    for (int i = 0; i < int(size[0]); ++i) {\n      float val = texelFetch(x, ivec2(i, out_y), 0).r;\n      if (i == 0 || val > maxval) {\n        maxval = val;\n      }\n    }\n\n    float sum = 0.0;\n    for (int i = 0; i < int(size[0]); ++i) {\n      float val = texelFetch(x, ivec2(i, out_y), 0).r;\n      sum += exp((val - maxval) * float(" + beta + "));\n    }\n\n    outColor = exp((texture(x, vec2(outTex.x, outTex.y)) - maxval) * float(" + beta + ")) / sum;\n  }";
  return source;
}

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _activation = __webpack_require__(55);

var activations = _interopRequireWildcard(_activation);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _tensorUtils = __webpack_require__(35);

var tensorUtils = _interopRequireWildcard(_tensorUtils);

var _ndarrayOps = __webpack_require__(36);

var _ndarrayOps2 = _interopRequireDefault(_ndarrayOps);

var _matMulDepthwise = __webpack_require__(145);

var _matMulDepthwise2 = _interopRequireDefault(_matMulDepthwise);

var _depthwiseConv2D = __webpack_require__(146);

var _depthwiseConv2D2 = _interopRequireDefault(_depthwiseConv2D);

var _fuse = __webpack_require__(56);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * DepthwiseConv2D layer class
 */
var DepthwiseConv2D = function (_Layer) {
  _inherits(DepthwiseConv2D, _Layer);

  /**
   * Creates a DepthwiseConv2D layer
   *
   * @param {Object} [attrs] - layer config attributes
   * @param {number} [attrs.filters] - Number of convolution filters to use
   * @param {number|number[]} [attrs.kernel_size] - Size of the convolution kernel
   */
  function DepthwiseConv2D() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, DepthwiseConv2D);

    var _this = _possibleConstructorReturn(this, (DepthwiseConv2D.__proto__ || Object.getPrototypeOf(DepthwiseConv2D)).call(this, attrs));

    _this.name = 'DepthwiseConv2D';
    var _attrs$filters = attrs.filters,
        filters = _attrs$filters === undefined ? 1 : _attrs$filters,
        _attrs$kernel_size = attrs.kernel_size,
        kernel_size = _attrs$kernel_size === undefined ? [3, 3] : _attrs$kernel_size,
        _attrs$strides = attrs.strides,
        strides = _attrs$strides === undefined ? [1, 1] : _attrs$strides,
        _attrs$padding = attrs.padding,
        padding = _attrs$padding === undefined ? 'VALID' : _attrs$padding,
        _attrs$depthMultiplie = attrs.depthMultiplier,
        depthMultiplier = _attrs$depthMultiplie === undefined ? 1 : _attrs$depthMultiplie,
        _attrs$data_format = attrs.data_format,
        data_format = _attrs$data_format === undefined ? 'NHWC' : _attrs$data_format,
        _attrs$dilation_rate = attrs.dilation_rate,
        dilation_rate = _attrs$dilation_rate === undefined ? [1, 1] : _attrs$dilation_rate,
        _attrs$activation = attrs.activation,
        activation = _attrs$activation === undefined ? 'NONE' : _attrs$activation,
        _attrs$use_bias = attrs.use_bias,
        use_bias = _attrs$use_bias === undefined ? true : _attrs$use_bias,
        _attrs$weights = attrs.weights,
        weights = _attrs$weights === undefined ? [] : _attrs$weights;


    if (Array.isArray(kernel_size)) {
      _this.kernelShape = [filters].concat(_toConsumableArray(kernel_size));
    } else {
      _this.kernelShape = [filters, kernel_size, kernel_size];
    }

    if (Array.isArray(strides)) {
      _this.strides = strides;
    } else {
      _this.strides = [strides, strides];
    }

    if (Array.isArray(padding)) {
      if (padding.length !== 4) {
        _this.throwError('Invalid padding.');
        // If all numbers in padding are 0, use padding = 'VALID'
      } else if (padding.every(function (x) {
        return !x;
      })) {
        _this.padding = 'VALID';
      } else {
        _this.padding = padding;
      }
    } else if (padding === 'VALID' || padding === 'SAME') {
      _this.padding = padding;
    } else {
      _this.throwError('Invalid padding.');
    }

    if (data_format === 'NHWC' || data_format === 'NCHW') {
      _this.dataFormat = data_format;
    } else {
      _this.throwError('Only NHWC and NCHW data formats are allowed.');
    }

    if (Array.isArray(dilation_rate)) {
      _this.dilationRate = dilation_rate;
    } else {
      _this.dilationRate = [dilation_rate, dilation_rate];
    }
    if ((_this.dilationRate[0] !== 1 || _this.dilationRate[1] !== 1) && (_this.strides[0] !== 1 || _this.strides[1] !== 1)) {
      // Currently, specifying any dilation_rate value != 1 is incompatible with specifying any stride value != 1
      _this.throwError('Incompatible combination of dilation_rate with strides.');
    }

    _this.depthMultiplier = depthMultiplier;
    _this.activation = activation;
    _this.fuseActivation = _fuse.fuseShaderSource[_this.activation];

    _this.useBias = use_bias;
    _this._setWeights(weights);
    return _this;
  }

  /**
   * Method for setting layer weights. Extends `super` method.
   * 
   * @param {Tensor[]} weightsArr - array of weights which are instances of Tensor
   */


  _createClass(DepthwiseConv2D, [{
    key: '_setWeights',
    value: function _setWeights(weightsArr) {
      if (this.dataFormat === 'NCHW') {
        weightsArr[0].tensor = weightsArr[0].tensor.transpose(0, 2, 3, 1);
      }

      var params = this.useBias ? ['kernel', 'bias'] : ['kernel'];
      var inputChannels = weightsArr[0].tensor.shape[3];

      var _kernelShape = _slicedToArray(this.kernelShape, 3),
          filter = _kernelShape[0],
          kernelH = _kernelShape[1],
          kernelW = _kernelShape[2];

      _get(DepthwiseConv2D.prototype.__proto__ || Object.getPrototypeOf(DepthwiseConv2D.prototype), 'setWeights', this).call(this, params, weightsArr, false);
      this.weights['kernel'].tensor.shape = [kernelH * kernelW, inputChannels];
      this.weights['kernel'].createGLTexture({ type: '2d', format: 'float' });
      if (this.useBias) {
        this.weights['bias'].createGLTexture({ type: '2d', format: 'float' });
      }
    }

    /**
     * Method for computing output dimensions and padding, 
     * based on input dimensions, kernel size, and padding mode.
     *
     * @param {number[]} inputShape
     */

  }, {
    key: '_calcOutputShape',
    value: function _calcOutputShape(inputShape) {
      if (this.outputShape && this.inputPadding) {
        return;
      }

      var inputHeight = inputShape[0];
      var inputWidth = inputShape[1];
      var inputChannels = inputShape[2];

      var _kernelShape2 = _slicedToArray(this.kernelShape, 3),
          filter = _kernelShape2[0],
          kernelH = _kernelShape2[1],
          kernelW = _kernelShape2[2];

      // effective shape after filter dilation


      var kernelHDilated = kernelH + (kernelH - 1) * (this.dilationRate[0] - 1);
      var kernelWDilated = kernelW + (kernelW - 1) * (this.dilationRate[1] - 1);

      if (Array.isArray(this.padding)) {
        var outputHeight = (inputHeight - kernelHDilated + this.padding[0] + this.padding[1] + this.strides[0]) / this.strides[0];
        var outputWidth = (inputWidth - kernelWDilated + this.padding[2] + this.padding[3] + this.strides[1]) / this.strides[1];
        this.outputShape = [outputHeight, outputWidth, this.weights['kernel'].tensor.shape[1]];
        this.inputPadding = this.padding;
      } else {
        var _outputHeight = this.padding === 'SAME' ? Math.floor((inputHeight + this.strides[0] - 1) / this.strides[0]) : Math.floor((inputHeight - kernelHDilated + this.strides[0]) / this.strides[0]);
        var _outputWidth = this.padding === 'SAME' ? Math.floor((inputWidth + this.strides[1] - 1) / this.strides[1]) : Math.floor((inputWidth - kernelWDilated + this.strides[1]) / this.strides[1]);

        var paddingHeight = this.padding === 'SAME' ? Math.max(0, Math.floor((_outputHeight - 1) * this.strides[0] + kernelHDilated - inputHeight)) : 0;
        var paddingWidth = this.padding === 'SAME' ? Math.max(0, Math.floor((_outputWidth - 1) * this.strides[1] + kernelWDilated - inputWidth)) : 0;

        var paddingHeightBefore = Math.floor(paddingHeight / 2);
        var paddingHeightAfter = paddingHeight - paddingHeightBefore;
        var paddingWidthBefore = Math.floor(paddingWidth / 2);
        var paddingWidthAfter = paddingWidth - paddingWidthBefore;
        this.outputShape = [_outputHeight, _outputWidth, this.weights['kernel'].tensor.shape[1]];
        this.inputPadding = [paddingHeightBefore, paddingHeightAfter, paddingWidthBefore, paddingWidthAfter];
      }
    }

    /**
     * Pad input tensor if necessary, for padding='SAME'. See above for notes on calculating padding.
     *
     * @param {Tensor} x
     * @param {number} [padValue]
     * @returns {Tensor}
     */

  }, {
    key: '_padInput',
    value: function _padInput(x) {
      var padValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      if (this.padding === 'SAME' || Array.isArray(this.padding)) {
        // Test all 0.
        if (this.inputPadding.every(function (x) {
          return !x;
        })) {
          return x;
        }

        var _x$tensor$shape = _slicedToArray(x.tensor.shape, 3),
            inputHeight = _x$tensor$shape[0],
            inputWidth = _x$tensor$shape[1],
            inputChannels = _x$tensor$shape[2];

        var _inputPadding = _slicedToArray(this.inputPadding, 4),
            paddingHeightBefore = _inputPadding[0],
            paddingHeightAfter = _inputPadding[1],
            paddingWidthBefore = _inputPadding[2],
            paddingWidthAfter = _inputPadding[3];

        var newHeight = inputHeight + paddingHeightBefore + paddingHeightAfter;
        var newWidth = inputWidth + paddingWidthBefore + paddingWidthAfter;
        var _x = new _Tensor2.default([], [newHeight, newWidth, inputChannels]);
        if (padValue !== 0) {
          _ndarrayOps2.default.assigns(_x.tensor, padValue);
        }
        _ndarrayOps2.default.assign(_x.tensor.hi(inputHeight + paddingHeightBefore, inputWidth + paddingWidthBefore, inputChannels).lo(paddingHeightBefore, paddingWidthBefore, 0), x.tensor);
        return _x;
      }
      return x;
    }

    /**
     * Convert input tensor to column matrix
     *
     * @param {Tensor} x
     * @returns {Tensor}
     */

  }, {
    key: '_im2col',
    value: function _im2col(x) {
      var _x$tensor$shape2 = _slicedToArray(x.tensor.shape, 3),
          inputHeight = _x$tensor$shape2[0],
          inputWidth = _x$tensor$shape2[1],
          inputChannels = _x$tensor$shape2[2];

      var kernelH = this.kernelShape[1];
      var kernelW = this.kernelShape[2];
      var outputHeight = this.outputShape[0];
      var outputWidth = this.outputShape[1];
      var nbPatches = outputHeight * outputWidth;
      var patchLen = inputChannels * kernelH * kernelW;
      var length = kernelH * kernelW;

      // effective shape after filter dilation
      var kernelHDilated = kernelH + (kernelH - 1) * (this.dilationRate[0] - 1);
      var kernelWDilated = kernelW + (kernelW - 1) * (this.dilationRate[1] - 1);

      if (!this.imColsMat) {
        this.imColsMat = new _Tensor2.default([], [nbPatches, patchLen]);
      }

      var patch = new _Tensor2.default([], [kernelH, kernelW, 1]);
      var offset = 0;
      for (var i = 0, limit = inputHeight - kernelHDilated; i <= limit; i += this.strides[0]) {
        for (var j = 0, _limit = inputWidth - kernelWDilated; j <= _limit; j += this.strides[1]) {
          for (var c = 0; c < inputChannels; ++c) {
            _ndarrayOps2.default.assign(patch.tensor, x.tensor.hi(i + kernelHDilated, j + kernelWDilated, c + 1).lo(i, j, c).step(this.dilationRate[0], this.dilationRate[1], 1));
            this.imColsMat.tensor.data.set(patch.tensor.data, offset);
            offset += length;
          }
        }
      }
      return this.imColsMat;
    }

    /**
     * Pre-compute index map for pooling function
     */

  }, {
    key: '_createIndexMap',
    value: function _createIndexMap() {
      if (this.indexMap) {
        return;
      }

      var _inputShape = _slicedToArray(this.inputShape, 3),
          inputHeight = _inputShape[0],
          inputWidth = _inputShape[1],
          inputChannels = _inputShape[2];

      var rowIndices = new _Tensor2.default([], [inputHeight, inputWidth]);
      var index = 0;
      for (var i = 0; i < inputHeight; i++) {
        for (var j = 0; j < inputWidth; j++) {
          rowIndices.tensor.set(i, j, index);
          index += 1;
        }
      }

      // padding
      if (this.padding === 'SAME' || Array.isArray(this.padding)) {
        var _inputPadding2 = _slicedToArray(this.inputPadding, 4),
            paddingHeightBefore = _inputPadding2[0],
            paddingHeightAfter = _inputPadding2[1],
            paddingWidthBefore = _inputPadding2[2],
            paddingWidthAfter = _inputPadding2[3];

        inputHeight = inputHeight + paddingHeightBefore + paddingHeightAfter;
        inputWidth = inputWidth + paddingWidthBefore + paddingWidthAfter;
        var _rowIndices = new _Tensor2.default([], [inputHeight, inputWidth]);
        _ndarrayOps2.default.assigns(_rowIndices.tensor, -1);
        _ndarrayOps2.default.assign(_rowIndices.tensor.hi(this.inputShape[0] + paddingHeightBefore, this.inputShape[1] + paddingWidthBefore).lo(paddingHeightBefore, paddingWidthBefore), rowIndices.tensor);
        rowIndices.tensor = _rowIndices.tensor;
      }

      var _kernelShape3 = _slicedToArray(this.kernelShape, 3),
          filters = _kernelShape3[0],
          kernelHeight = _kernelShape3[1],
          kernelWidth = _kernelShape3[2];

      var outputHeight = this.outputShape[0];
      var outputWidth = this.outputShape[1];

      this.indexMap = new _Tensor2.default([], [outputHeight * outputWidth, kernelHeight * kernelWidth], Int32Array);

      var patchRow = new _Tensor2.default([], [kernelHeight, kernelWidth]);
      var offset = 0;
      for (var _i = 0, limit = inputHeight - kernelHeight; _i <= limit; _i += this.strides[0]) {
        for (var _j = 0, _limit2 = inputWidth - kernelWidth; _j <= _limit2; _j += this.strides[1]) {
          _ndarrayOps2.default.assign(patchRow.tensor, rowIndices.tensor.hi(_i + kernelHeight, _j + kernelWidth).lo(_i, _j));
          this.indexMap.tensor.data.set(patchRow.tensor.data, offset);
          offset += kernelHeight * kernelWidth;
        }
      }
      this.indexMap.createGLTexture({ type: '2d', format: 'int', supportSliceTexture: true });
    }

    /**
     * call
     *
     * @param {Tensor} x
     */

  }, {
    key: 'call',
    value: function call(x) {
      var _kernelShape4 = _slicedToArray(this.kernelShape, 3),
          filter = _kernelShape4[0],
          kernelH = _kernelShape4[1],
          kernelW = _kernelShape4[2];

      var outputTextureShape = void 0;
      if (x.is2DReshaped) {
        this.inputShape = x.originalShape;
        this._calcOutputShape(this.inputShape);
        this._createIndexMap();
        outputTextureShape = [this.outputShape[0] * this.outputShape[1], this.outputShape[2]];
      } else {
        this.inputShape = x.tensor.shape;
        this._calcOutputShape(this.inputShape);
        x = this._padInput(x);
        this._im2col(x);
        this.imColsMat.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
        outputTextureShape = [this.imColsMat.textureShape[0], this.outputShape[2]];
      }

      // create output textures if doesn't already exist
      if (!this.output) {
        this.output = new _Tensor2.default([], outputTextureShape);
        this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
        this.output.is2DReshaped = true;
        this.output.originalShape = this.outputShape;
        this.output.indicesForReshaped = tensorUtils.createIndicesFor2DReshaped(this.outputShape, false, -1);
      }

      if (x.is2DReshaped) {
        var hasFragments = Boolean(x.textureSlices);
        if (hasFragments) {
          x.convertTextureSlicesToColStackTexture();
        }
        if (!this.depthwiseConv2DProgram) {
          var depthwiseConv2DShaderSource = (0, _depthwiseConv2D2.default)(this.inputShape[2], this.output.textureShape[1], this.depthMultiplier, this.useBias, hasFragments, this.fuseActivation);
          this.depthwiseConv2DProgram = _WebGL2.default.createProgram(depthwiseConv2DShaderSource);
        }
        _WebGL2.default.runProgram({
          program: this.depthwiseConv2DProgram,
          output: this.output,
          inputs: [{ input: x, name: 'x' }, { input: this.indexMap, name: 'indexMap' }, { input: this.weights['kernel'], name: 'kernel' }].concat(_toConsumableArray(this.useBias ? [{ input: this.weights['bias'], name: 'bias' }] : [])),
          supportSliceTexture: true
        });
      } else {
        // run matrix multiply on result of im2col
        var matMulInputs = [{ input: this.imColsMat, name: 'A' }, { input: this.weights['kernel'], name: 'B' }];
        if (this.useBias) {
          matMulInputs.push({ input: this.weights['bias'], name: 'C' });
        }
        if (!this.matMulDepthwiseProgram) {
          this.matMulDepthwiseProgram = _WebGL2.default.createProgram((0, _matMulDepthwise2.default)(this.fuseActivation));
        }
        _WebGL2.default.runProgram({
          program: this.matMulDepthwiseProgram,
          output: this.output,
          inputs: matMulInputs,
          uniforms: [{ value: this.useBias ? 1 : 0, type: 'bool', name: 'addC' }, { value: this.inputShape[2], type: 'int', name: 'inputChannels' }, { value: outputTextureShape[1], type: 'int', name: 'outputChannels' }, { value: this.depthMultiplier, type: 'int', name: 'depthMultiplier' }],
          supportSliceTexture: true
        });
      }

      // convert back to channels_first ordering if necessary
      if (this.dataFormat === 'NCHW') {
        weightsArr[0].tensor = weightsArr[0].tensor.transpose(0, 3, 1, 2);
      }
      return this.output;
    }
  }]);

  return DepthwiseConv2D;
}(_Layer3.default);

exports.default = DepthwiseConv2D;

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FeatureMapConcate = exports.Concatenation = exports.Reshape = exports.TopClasses = exports.Activation = exports.Mul = exports.Add = exports.Input = undefined;

var _Input = __webpack_require__(387);

var _Input2 = _interopRequireDefault(_Input);

var _Add = __webpack_require__(388);

var _Add2 = _interopRequireDefault(_Add);

var _Mul = __webpack_require__(389);

var _Mul2 = _interopRequireDefault(_Mul);

var _Activation = __webpack_require__(390);

var _Activation2 = _interopRequireDefault(_Activation);

var _TopClasses = __webpack_require__(391);

var _TopClasses2 = _interopRequireDefault(_TopClasses);

var _Reshape = __webpack_require__(392);

var _Reshape2 = _interopRequireDefault(_Reshape);

var _Concatenation = __webpack_require__(393);

var _Concatenation2 = _interopRequireDefault(_Concatenation);

var _FeatureMapConcate = __webpack_require__(394);

var _FeatureMapConcate2 = _interopRequireDefault(_FeatureMapConcate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.Input = _Input2.default;
exports.Add = _Add2.default;
exports.Mul = _Mul2.default;
exports.Activation = _Activation2.default;
exports.TopClasses = _TopClasses2.default;
exports.Reshape = _Reshape2.default;
exports.Concatenation = _Concatenation2.default;
exports.FeatureMapConcate = _FeatureMapConcate2.default;

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * InputLayer layer class
 */
var Input = function (_Layer) {
  _inherits(Input, _Layer);

  /**
   * Creates an InputLayer layer
   *
   * @param {Object} [attrs] - inputsNum: number of inputs
   */
  function Input() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Input);

    var _this = _possibleConstructorReturn(this, (Input.__proto__ || Object.getPrototypeOf(Input)).call(this, attrs));

    _this.name = 'Input';
    _this.inputsNum = attrs.inputsNum;
    _this.inputTensors = Array(_this.inputsNum);
    return _this;
  }

  /**
   * call
   *
   * @param {Map} inputs - input map with value: inputBuffers and indexes identifying the input operands.
   */


  _createClass(Input, [{
    key: 'call',
    value: function call(inputs, shape, type) {
      var _this2 = this;

      inputs.forEach(function (input, i) {
        if (!_this2.inputTensors[i]) {
          _this2.inputTensors[i] = new _Tensor2.default(input.buffer, shape, type);
          if (_this2.inputTensors[i].tensor.shape.length <= 2) {
            _this2.inputTensors[i].createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
          } else if (_this2.inputTensors[i].tensor.shape.length > 2) {
            _this2.inputTensors[i].reshapeTo2D();
            _this2.inputTensors[i].createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
          }
        } else {
          if (type !== _this2.inputTensors[i].arrayType) {
            _this2.throwError('Invalid data type in InputLayer.');
          }
          if (shape.reduce(function (a, b) {
            return a * b;
          }) !== _this2.inputTensors[i].tensor.shape.reduce(function (a, b) {
            return a * b;
          })) {
            _this2.throwError('Invalid data shape in InputLayer.');
          }
          _this2.inputTensors[i].replaceTensorData(input.buffer);
        }
      });
      return this.inputTensors;
    }
  }]);

  return Input;
}(_Layer3.default);

exports.default = Input;

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _tensorUtils = __webpack_require__(35);

var tensorUtils = _interopRequireWildcard(_tensorUtils);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _add = __webpack_require__(147);

var _add2 = _interopRequireDefault(_add);

var _fuse = __webpack_require__(56);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* Add layer class
*/
var Add = function (_Layer) {
  _inherits(Add, _Layer);

  /**
   * Creates an add layer
   *
   * @param {Object} [attrs] - layer config attributes
   */
  function Add() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Add);

    var _this = _possibleConstructorReturn(this, (Add.__proto__ || Object.getPrototypeOf(Add)).call(this, attrs));

    _this.name = 'Add';
    var _attrs$activation = attrs.activation,
        activation = _attrs$activation === undefined ? 'NONE' : _attrs$activation;

    _this.activation = activation;
    _this.fuseActivation = _fuse.fuseShaderSource[_this.activation];
    return _this;
  }

  /**
   * GPU call
   *
   * @param {Tensor[]} inputs
   */


  _createClass(Add, [{
    key: 'call',
    value: function call(inputs) {
      if (!this.output) {
        if (inputs[0].is2DReshaped) {
          this.outputShape = inputs[0].originalShape;
          var outputTextureShape = inputs[0].textureShape;
          this.output = new _Tensor2.default([], outputTextureShape);
          this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
          this.output.is2DReshaped = true;
          this.output.originalShape = this.outputShape;
          this.output.indicesForReshaped = tensorUtils.createIndicesFor2DReshaped(this.output.originalShape);
        } else {
          var _outputTextureShape = inputs[0].textureShape;
          this.output = new _Tensor2.default([], _outputTextureShape);
          this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
          if (inputs[0].is1D) {
            this.output.is1D = true;
          }
        }
      }

      if (!this.addProgram) {
        var addShaderSource = (0, _add2.default)(this.fuseActivation);
        this.addProgram = _WebGL2.default.createProgram(addShaderSource);
      }
      _WebGL2.default.runProgram({
        program: this.addProgram,
        output: this.output,
        inputs: [{ input: inputs[0], name: 'A' }, { input: inputs[1], name: 'B' }],
        supportSliceTexture: true
      });

      return this.output;
    }
  }]);

  return Add;
}(_Layer3.default);

exports.default = Add;

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _tensorUtils = __webpack_require__(35);

var tensorUtils = _interopRequireWildcard(_tensorUtils);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _mul = __webpack_require__(148);

var _mul2 = _interopRequireDefault(_mul);

var _fuse = __webpack_require__(56);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* Mul layer class
*/
var Mul = function (_Layer) {
  _inherits(Mul, _Layer);

  /**
   * Creates an mul layer
   *
   * @param {Object} [attrs] - layer config attributes
   */
  function Mul() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Mul);

    var _this = _possibleConstructorReturn(this, (Mul.__proto__ || Object.getPrototypeOf(Mul)).call(this, attrs));

    _this.name = 'Mul';
    var _attrs$activation = attrs.activation,
        activation = _attrs$activation === undefined ? 'NONE' : _attrs$activation;

    _this.activation = activation;
    _this.fuseActivation = _fuse.fuseShaderSource[_this.activation];
    return _this;
  }

  /**
   * GPU call
   *
   * @param {Tensor[]} inputs
   */


  _createClass(Mul, [{
    key: 'call',
    value: function call(inputs) {
      if (!this.output) {
        if (inputs[0].is2DReshaped) {
          this.outputShape = inputs[0].originalShape;
          var outputTextureShape = inputs[0].textureShape;
          this.output = new _Tensor2.default([], outputTextureShape);
          this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
          this.output.is2DReshaped = true;
          this.output.originalShape = this.outputShape;
          this.output.indicesForReshaped = tensorUtils.createIndicesFor2DReshaped(this.output.originalShape);
        } else {
          var _outputTextureShape = inputs[0].textureShape;
          this.output = new _Tensor2.default([], _outputTextureShape);
          this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
          if (inputs[0].is1D) {
            this.output.is1D = true;
          }
        }
      }

      if (!this.mulProgram) {
        var mulShaderSource = (0, _mul2.default)(this.fuseActivation);
        this.mulProgram = _WebGL2.default.createProgram(mulShaderSource);
      }
      _WebGL2.default.runProgram({
        program: this.mulProgram,
        output: this.output,
        inputs: [{ input: inputs[0], name: 'A' }, { input: inputs[1], name: 'B' }],
        supportSliceTexture: true
      });

      return this.output;
    }
  }]);

  return Mul;
}(_Layer3.default);

exports.default = Mul;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _activation = __webpack_require__(55);

var activations = _interopRequireWildcard(_activation);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Activation layer class
 */
var Activation = function (_Layer) {
  _inherits(Activation, _Layer);

  /**
   * Creates a avtivation layer
    */
  function Activation() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Activation);

    var _this = _possibleConstructorReturn(this, (Activation.__proto__ || Object.getPrototypeOf(Activation)).call(this, attrs));

    var _attrs$activation = attrs.activation,
        activation = _attrs$activation === undefined ? 'NONE' : _attrs$activation;

    _this.name = activation;
    if (_this.name !== 'NONE' && !_WebGL2.default.activationProgram) {
      if (_this.name === 'softmax') {
        _this.activationProgram = _WebGL2.default.createProgram(activations['softmax'](attrs.beta));
      } else {
        _this.activationProgram = _WebGL2.default.createProgram(activations[_this.name]);
      }
    }
    return _this;
  }

  /**
   * call
   *
   * @param {Tensor} x
   */


  _createClass(Activation, [{
    key: 'call',
    value: function call(x) {
      if (this.name !== 'NONE') {
        if (!this.output) {
          this.output = new _Tensor2.default([], x.tensor.shape);
          this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
        }
        _WebGL2.default.runProgram({
          program: this.activationProgram,
          output: this.output,
          inputs: [{ input: x, name: 'x' }],
          supportSliceTexture: true
        });
        return this.output;
      } else {
        return x;
      }
    }
  }]);

  return Activation;
}(_Layer3.default);

exports.default = Activation;

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _topClasses = __webpack_require__(149);

var _topClasses2 = _interopRequireDefault(_topClasses);

var _reduceClasses = __webpack_require__(150);

var _reduceClasses2 = _interopRequireDefault(_reduceClasses);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * TopClasses layer class
 */
var TopClasses = function (_Layer) {
  _inherits(TopClasses, _Layer);

  /**
   * Creates a TopClasses layer
    */
  function TopClasses() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TopClasses);

    var _this = _possibleConstructorReturn(this, (TopClasses.__proto__ || Object.getPrototypeOf(TopClasses)).call(this, attrs));

    var _attrs$numTopClasses = attrs.numTopClasses,
        numTopClasses = _attrs$numTopClasses === undefined ? 1 : _attrs$numTopClasses,
        _attrs$reduceNums = attrs.reduceNums,
        reduceNums = _attrs$reduceNums === undefined ? 10 : _attrs$reduceNums;

    _this.name = 'TopClasses';
    _this.numTopClasses = numTopClasses;
    _this.output = null;
    _this.outArray = [];
    _this.programArray = [];
    _this.reduceNums = reduceNums;
    return _this;
  }

  /**
   * call
   *
   * @param {Tensor} x
   */


  _createClass(TopClasses, [{
    key: 'call',
    value: function call(x) {
      if (this.numTopClasses === 1) {
        var index = 0;
        var reduceLen = Math.ceil(x.tensor.shape[1] / this.reduceNums);
        var input = x;
        while (reduceLen > 0) {
          // console.log(`index: ${index}`);
          // console.log(`reduceLen: ${reduceLen}`);
          if (!this.outArray[index]) {
            this.outArray[index] = new _Tensor2.default([], [2, reduceLen]);
            this.outArray[index].createGLTexture({ type: '2d', format: 'float' });
          }
          if (!this.programArray[index]) {
            var reduceClassesShaderSource = (0, _reduceClasses2.default)(this.reduceNums, reduceLen, index, input.tensor.shape[1]);
            this.programArray[index] = _WebGL2.default.createProgram(reduceClassesShaderSource);
          }
          _WebGL2.default.runProgram({
            program: this.programArray[index],
            output: this.outArray[index],
            inputs: [{ input: input, name: 'x' }],
            supportSliceTexture: true
          });
          // let out = webgl2.readData([2, reduceLen]);
          // console.log(`out: ${out}`)
          if (reduceLen < 2) {
            break;
          }
          input = this.outArray[index];
          ++index;
          reduceLen = Math.ceil(reduceLen / this.reduceNums);
        }
        // let start = performance.now();
        var out = _WebGL2.default.readData([2, reduceLen]);
        // console.log('Read data from GPU time', (performance.now() - start).toFixed(2));
        // console.log(`out: ${out}`);
        return out;
      } else {
        if (!this.output) {
          // x.tensor.shape = [1, length]
          this.output = new _Tensor2.default([], x.tensor.shape);
          this.output.createGLTexture({ type: '2d', format: 'float' });
        }
        if (!this.topClassesProgram) {
          var topClassesShaderSource = (0, _topClasses2.default)(this.numTopClasses, x.tensor.shape[1]);
          this.topClassesProgram = _WebGL2.default.createProgram(topClassesShaderSource);
        }
        _WebGL2.default.runProgram({
          program: this.topClassesProgram,
          output: this.output,
          inputs: [{ input: x, name: 'x' }],
          supportSliceTexture: true
        });
        // let start = performance.now();
        var _out = _WebGL2.default.readData([1, this.numTopClasses * 2]);
        // console.log('Read data from GPU time', (performance.now() - start).toFixed(2));
        return _out;
      }
    }
  }]);

  return TopClasses;
}(_Layer3.default);

exports.default = TopClasses;

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Reshape layer class
 * Note there is no concept of batch size in these layers (single-batch).
 */
var Reshape = function (_Layer) {
  _inherits(Reshape, _Layer);

  /**
   * Creates a Reshape layer
   *
   * @param {Object} [attrs] - layer config attributes
   * @param {number[]} [attrs.target_shape]
   */
  function Reshape() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Reshape);

    var _this = _possibleConstructorReturn(this, (Reshape.__proto__ || Object.getPrototypeOf(Reshape)).call(this, attrs));

    _this.name = 'Reshape';

    var _attrs$target_shape = attrs.target_shape,
        target_shape = _attrs$target_shape === undefined ? [] : _attrs$target_shape;

    _this.targetShape = target_shape;
    return _this;
  }

  /**
   * call
   *
   * @param {Tensor} x
   */


  _createClass(Reshape, [{
    key: 'call',
    value: function call(x) {
      return x;
    }
  }]);

  return Reshape;
}(_Layer3.default);

exports.default = Reshape;

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _tensorUtils = __webpack_require__(35);

var tensorUtils = _interopRequireWildcard(_tensorUtils);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* Concatenation merge layer class, extends abstract _Merge class
*/
var Concatenation = function (_Layer) {
  _inherits(Concatenation, _Layer);

  /**
   * Creates a Concatenation merge layer
   *
   * @param {Object} [attrs] - layer config attributes
   */
  function Concatenation() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Concatenation);

    var _this = _possibleConstructorReturn(this, (Concatenation.__proto__ || Object.getPrototypeOf(Concatenation)).call(this, attrs));

    _this.name = 'Concatenation';
    // axis = -1 or 3 
    var _attrs$axis = attrs.axis,
        axis = _attrs$axis === undefined ? -1 : _attrs$axis;

    _this.axis = axis;
    return _this;
  }

  /**
   * GPU call
   *
   * @param {Tensor[]} inputs
   */


  _createClass(Concatenation, [{
    key: 'call',
    value: function call(inputs) {
      var _this2 = this;

      if (!this.output) {
        var _concatAxis = 0;
        if (!inputs[0].originalShape) {
          //for 2D shape
          this.concatAxis = this.axis;
          _concatAxis = this.axis;
        } else {
          // C axis is 3 in NHWC layout
          // no mini-batch axis here, so we subtract 1 if given axis > 0
          this.concatAxis = this.axis < 0 ? this.axis + inputs[0].originalShape.length : this.axis - 1;
          // _concatAxis = 1 for 2D Texture
          _concatAxis = 1;
        }
        inputs.forEach(function (input) {
          if (!input.texture && !input.textureSlices) {
            input.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
          }
        });

        var outputTextureShape = inputs[0].textureShape.slice();
        // create output textures if doesn't already exist
        outputTextureShape[_concatAxis] = inputs.map(function (input) {
          return input.textureShape[_concatAxis];
        }).reduce(function (i, j) {
          return i + j;
        });
        this.output = new _Tensor2.default([], outputTextureShape);
        this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
        if (inputs[0].is1D) {
          this.output.is1D = inputs[0].is1D;
        } else if (inputs[0].is2DReshaped) {
          this.output.is2DReshaped = inputs[0].is2DReshaped;
          this.output.originalShape = inputs[0].originalShape.slice();
          this.output.originalShape[this.concatAxis] = inputs.map(function (input) {
            return input.originalShape[_this2.concatAxis];
          }).reduce(function (i, j) {
            return i + j;
          });
          this.output.indicesForReshaped = tensorUtils.createIndicesFor2DReshaped(this.output.originalShape);
        }
      }

      var gl = _WebGL2.default.context;
      var textureOptions = _WebGL2.default.getTextureOptions(inputs[0].textureType, inputs[0].textureFormat);
      var textureTarget = textureOptions.textureTarget,
          textureInternalFormat = textureOptions.textureInternalFormat,
          textureFormat = textureOptions.textureFormat,
          textureType = textureOptions.textureType;


      if (!_WebGL2.default.concateFramebuffer) {
        _WebGL2.default.concateFramebuffer = gl.createFramebuffer();
        _WebGL2.default.toDelete.framebuffers.push(_WebGL2.default.concateFramebuffer);
      }

      if (this.output.textureSlices) {
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, _WebGL2.default.concateFramebuffer);

        var _loop = function _loop(i) {
          gl.bindTexture(textureTarget, _this2.output.textureSlices[i]);
          var offset = 0;
          inputs.forEach(function (input, k) {
            gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, input.textureSlices[i], 0);
            if (!inputs[0].originalShape && _concatAxis === 0) {
              //for 2D shape with axis = 0
              gl.copyTexSubImage2D(textureTarget, 0, 0, offset, 0, 0, input.textureSliceShape[1], input.textureSliceShape[0]);
              offset += input.textureShape[0];
            } else {
              gl.copyTexSubImage2D(textureTarget, 0, offset, 0, 0, 0, input.textureSliceShape[1], input.textureSliceShape[0]);
              offset += input.textureShape[1];
            }
          });
        };

        for (var i = 0; i < this.output.textureSlices.length; ++i) {
          _loop(i);
        }
      } else {
        // console.log(`concate texture`)
        gl.bindTexture(textureTarget, this.output.texture);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, _WebGL2.default.concateFramebuffer);
        var _offset = 0;
        inputs.forEach(function (input, k) {
          gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, input.texture, 0);
          if (!inputs[0].originalShape && _concatAxis === 0) {
            //for 2D shape with axis = 0
            gl.copyTexSubImage2D(textureTarget, 0, 0, _offset, 0, 0, input.textureShape[1], input.textureShape[0]);
            _offset += input.textureShape[0];
          } else {
            gl.copyTexSubImage2D(textureTarget, 0, _offset, 0, 0, 0, input.textureShape[1], input.textureShape[0]);
            _offset += input.textureShape[1];
          }
        });
      }
      return this.output;
    }
  }]);

  return Concatenation;
}(_Layer3.default);

exports.default = Concatenation;

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Layer2 = __webpack_require__(12);

var _Layer3 = _interopRequireDefault(_Layer2);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _tensorUtils = __webpack_require__(35);

var tensorUtils = _interopRequireWildcard(_tensorUtils);

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _ndarrayOps = __webpack_require__(36);

var _ndarrayOps2 = _interopRequireDefault(_ndarrayOps);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
* FeatureMapConcate merge layer class, extends abstract _Merge class
*/
var FeatureMapConcate = function (_Layer) {
  _inherits(FeatureMapConcate, _Layer);

  /**
   * Creates a FeatureMapConcate merge layer
   *
   * @param {Object} [attrs] - layer config attributes
   */
  function FeatureMapConcate() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, FeatureMapConcate);

    var _this = _possibleConstructorReturn(this, (FeatureMapConcate.__proto__ || Object.getPrototypeOf(FeatureMapConcate)).call(this, attrs));

    _this.name = 'FeatureMapConcate';
    _this.inputsShapeList = [];
    _this.outH = [];
    return _this;
  }

  /**
   * GPU call
   *
   * @param {Tensor[]} inputs
   */


  _createClass(FeatureMapConcate, [{
    key: 'call',
    value: function call(inputs, outputs) {
      var boxSize = inputs[inputs.length - 2].textureShape[1];
      var numClasses = inputs[inputs.length - 1].textureShape[1];

      if (this.outH.length === 0) {
        for (var i = 0; i < inputs.length; ++i) {
          if (i % 2 === 0) {
            this.outH.push(inputs[i].textureShape[0]);
          }
          this.inputsShapeList.push(inputs[i].textureShape);
        }
        if (this.inputsShapeList.length !== this.outH.length * 2) {
          this.throwError('Wrong input length.');
        }
      }

      if (!this.output) {
        var outputTextureShape = [this.outH.reduce(function (i, j) {
          return i + j;
        }), boxSize + numClasses];
        this.output = new _Tensor2.default([], outputTextureShape);
        this.output.createGLTexture({ type: '2d', format: 'float', supportSliceTexture: true });
      }
      var gl = _WebGL2.default.context;
      var textureOptions = _WebGL2.default.getTextureOptions(inputs[0].textureType, inputs[0].textureFormat);
      var textureTarget = textureOptions.textureTarget,
          textureInternalFormat = textureOptions.textureInternalFormat,
          textureFormat = textureOptions.textureFormat,
          textureType = textureOptions.textureType;


      if (!_WebGL2.default.featureMapFramebuffer) {
        _WebGL2.default.featureMapFramebuffer = gl.createFramebuffer();
        _WebGL2.default.toDelete.framebuffers.push(_WebGL2.default.featureMapFramebuffer);
      }

      gl.bindTexture(textureTarget, this.output.texture);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, _WebGL2.default.featureMapFramebuffer);

      var Yoffset = 0;
      var input = void 0;
      for (var _i = 0; _i < this.outH.length; ++_i) {
        input = inputs[_i * 2];
        gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, input.texture, 0);
        gl.copyTexSubImage2D(textureTarget, 0, 0, Yoffset, 0, 0, input.textureShape[1], input.textureShape[0]);
        input = inputs[_i * 2 + 1];
        gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, input.texture, 0);
        gl.copyTexSubImage2D(textureTarget, 0, boxSize, Yoffset, 0, 0, input.textureShape[1], input.textureShape[0]);
        Yoffset += this.outH[_i];
      }
      this.output.transferFromGLTexture();

      var Hoffset = 0;
      var outputBoxBuffer = void 0;
      var boxIndex = void 0;
      var outputClassBuffer = void 0;
      var classIndex = void 0;
      var H = void 0;
      for (var _i2 = 0; _i2 < this.inputsShapeList.length / 2; ++_i2) {
        boxIndex = _i2 * 2;
        outputBoxBuffer = new _Tensor2.default(outputs.get(boxIndex).buffer, this.inputsShapeList[boxIndex]);
        classIndex = boxIndex + 1;
        outputClassBuffer = new _Tensor2.default(outputs.get(boxIndex + 1).buffer, this.inputsShapeList[boxIndex + 1]);
        H = this.inputsShapeList[boxIndex][0];
        _ndarrayOps2.default.assign(outputBoxBuffer.tensor, this.output.tensor.hi(Hoffset + H, this.inputsShapeList[boxIndex][1]).lo(Hoffset, 0));
        _ndarrayOps2.default.assign(outputClassBuffer.tensor, this.output.tensor.hi(Hoffset + H, this.inputsShapeList[boxIndex][1] + this.inputsShapeList[classIndex][1]).lo(Hoffset, this.inputsShapeList[boxIndex][1]));
        Hoffset += H;
      }
    }
  }]);

  return FeatureMapConcate;
}(_Layer3.default);

exports.default = FeatureMapConcate;

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AveragePool2D = exports.MaxPool2D = exports.GlobalAveragePooling2D = exports.GlobalMaxPooling2D = undefined;

var _GlobalMaxPooling2D = __webpack_require__(396);

var _GlobalMaxPooling2D2 = _interopRequireDefault(_GlobalMaxPooling2D);

var _GlobalAveragePooling2D = __webpack_require__(397);

var _GlobalAveragePooling2D2 = _interopRequireDefault(_GlobalAveragePooling2D);

var _MaxPool2D = __webpack_require__(398);

var _MaxPool2D2 = _interopRequireDefault(_MaxPool2D);

var _AveragePool2D = __webpack_require__(399);

var _AveragePool2D2 = _interopRequireDefault(_AveragePool2D);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.GlobalMaxPooling2D = _GlobalMaxPooling2D2.default;
exports.GlobalAveragePooling2D = _GlobalAveragePooling2D2.default;
exports.MaxPool2D = _MaxPool2D2.default;
exports.AveragePool2D = _AveragePool2D2.default;

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _GlobalPooling2D3 = __webpack_require__(151);

var _GlobalPooling2D4 = _interopRequireDefault(_GlobalPooling2D3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * GlobalMaxPooling2D layer class, extends abstract _GlobalPooling2D class
 */
var GlobalMaxPooling2D = function (_GlobalPooling2D2) {
  _inherits(GlobalMaxPooling2D, _GlobalPooling2D2);

  /**
   * Creates a GlobalMaxPooling2D layer
   */
  function GlobalMaxPooling2D() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GlobalMaxPooling2D);

    var _this = _possibleConstructorReturn(this, (GlobalMaxPooling2D.__proto__ || Object.getPrototypeOf(GlobalMaxPooling2D)).call(this, attrs));

    _this.name = 'GlobalMaxPooling2D';
    _this.poolingFunc = 'max';
    return _this;
  }

  return GlobalMaxPooling2D;
}(_GlobalPooling2D4.default);

exports.default = GlobalMaxPooling2D;

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _GlobalPooling2D3 = __webpack_require__(151);

var _GlobalPooling2D4 = _interopRequireDefault(_GlobalPooling2D3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * GlobalAveragePooling2D layer class, extends abstract _GlobalPooling2D class
 */
var GlobalAveragePooling2D = function (_GlobalPooling2D2) {
  _inherits(GlobalAveragePooling2D, _GlobalPooling2D2);

  /**
   * Creates a GlobalAveragePooling2D layer
   */
  function GlobalAveragePooling2D() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GlobalAveragePooling2D);

    var _this = _possibleConstructorReturn(this, (GlobalAveragePooling2D.__proto__ || Object.getPrototypeOf(GlobalAveragePooling2D)).call(this, attrs));

    _this.name = 'GlobalAveragePooling2D';
    _this.poolingFunc = 'average';
    return _this;
  }

  return GlobalAveragePooling2D;
}(_GlobalPooling2D4.default);

exports.default = GlobalAveragePooling2D;

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Pool2D3 = __webpack_require__(153);

var _Pool2D4 = _interopRequireDefault(_Pool2D3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * MaxPool2D layer class, extends abstract _Pool2D class
 */
var MaxPool2D = function (_Pool2D2) {
  _inherits(MaxPool2D, _Pool2D2);

  /**
   * Creates a MaxPool2D layer
   */
  function MaxPool2D() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MaxPool2D);

    var _this = _possibleConstructorReturn(this, (MaxPool2D.__proto__ || Object.getPrototypeOf(MaxPool2D)).call(this, attrs));

    _this.name = 'MaxPool2D';
    _this.poolingFunc = 'max';
    return _this;
  }

  return MaxPool2D;
}(_Pool2D4.default);

exports.default = MaxPool2D;

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Pool2D3 = __webpack_require__(153);

var _Pool2D4 = _interopRequireDefault(_Pool2D3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * AveragePool2D layer class, extends abstract _Pool2D class
 */
var AveragePool2D = function (_Pool2D2) {
  _inherits(AveragePool2D, _Pool2D2);

  /**
   * Creates a AveragePool2D layer
   */
  function AveragePool2D() {
    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AveragePool2D);

    var _this = _possibleConstructorReturn(this, (AveragePool2D.__proto__ || Object.getPrototypeOf(AveragePool2D)).call(this, attrs));

    _this.name = 'AveragePool2D';
    _this.poolingFunc = 'average';
    return _this;
  }

  return AveragePool2D;
}(_Pool2D4.default);

exports.default = AveragePool2D;

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _WebGL = __webpack_require__(11);

var _WebGL2 = _interopRequireDefault(_WebGL);

var _Tensor = __webpack_require__(13);

var _Tensor2 = _interopRequireDefault(_Tensor);

var _Layer = __webpack_require__(12);

var _Layer2 = _interopRequireDefault(_Layer);

var _Model = __webpack_require__(139);

var _Model2 = _interopRequireDefault(_Model);

var _layers = __webpack_require__(140);

var _layers2 = _interopRequireDefault(_layers);

var _webgl = __webpack_require__(401);

var _webgl2 = _interopRequireDefault(_webgl);

var _ndarray = __webpack_require__(73);

var _ndarray2 = _interopRequireDefault(_ndarray);

var _ndarrayOps = __webpack_require__(36);

var _ndarrayOps2 = _interopRequireDefault(_ndarrayOps);

var _ndarraySqueeze = __webpack_require__(142);

var _ndarraySqueeze2 = _interopRequireDefault(_ndarraySqueeze);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var supportWebGL2 = _WebGL2.default.supportWebGL2;
// const webmlGL = { Tensor, Layer, webgl2, layer, shader, ndarray, ops, squeeze }
// export { webmlGL as default }

exports.default = supportWebGL2;

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.vertexShaderSource = exports.fragmentShader = undefined;

var _fragmentShader = __webpack_require__(402);

var fragmentShader = _interopRequireWildcard(_fragmentShader);

var _vertexShader = __webpack_require__(141);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.fragmentShader = fragmentShader;
exports.vertexShaderSource = _vertexShader.vertexShaderSource;

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _activation = __webpack_require__(55);

Object.keys(_activation).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _activation[key];
    }
  });
});

var _arithmetic = __webpack_require__(403);

Object.keys(_arithmetic).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _arithmetic[key];
    }
  });
});

var _convolution = __webpack_require__(404);

Object.keys(_convolution).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _convolution[key];
    }
  });
});

var _pooling = __webpack_require__(405);

Object.keys(_pooling).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _pooling[key];
    }
  });
});

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reduceClasses = exports.topClasses = exports.matMulDepthwiseShaderSource = exports.matMulShaderSource = exports.mulShaderSource = exports.addShaderSource = undefined;

var _add = __webpack_require__(147);

var _add2 = _interopRequireDefault(_add);

var _mul = __webpack_require__(148);

var _mul2 = _interopRequireDefault(_mul);

var _matMul = __webpack_require__(143);

var _matMul2 = _interopRequireDefault(_matMul);

var _matMulDepthwise = __webpack_require__(145);

var _matMulDepthwise2 = _interopRequireDefault(_matMulDepthwise);

var _topClasses = __webpack_require__(149);

var _topClasses2 = _interopRequireDefault(_topClasses);

var _reduceClasses = __webpack_require__(150);

var _reduceClasses2 = _interopRequireDefault(_reduceClasses);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.addShaderSource = _add2.default;
exports.mulShaderSource = _mul2.default;
exports.matMulShaderSource = _matMul2.default;
exports.matMulDepthwiseShaderSource = _matMulDepthwise2.default;
exports.topClasses = _topClasses2.default;
exports.reduceClasses = _reduceClasses2.default;

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.depthwiseConv2D = exports.conv2d = undefined;

var _conv2d = __webpack_require__(144);

var _conv2d2 = _interopRequireDefault(_conv2d);

var _depthwiseConv2D = __webpack_require__(146);

var _depthwiseConv2D2 = _interopRequireDefault(_depthwiseConv2D);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.conv2d = _conv2d2.default;
exports.depthwiseConv2D = _depthwiseConv2D2.default;

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pool2D = exports.globalPooling = undefined;

var _globalPooling = __webpack_require__(152);

var _pool2D = __webpack_require__(154);

var _pool2D2 = _interopRequireDefault(_pool2D);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.globalPooling = _globalPooling.globalPooling;
exports.pool2D = _pool2D2.default;

/***/ })
/******/ ]);