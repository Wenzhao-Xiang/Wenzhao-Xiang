<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: Performance Measurement and Improvement Techniques</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="tutorial-utils.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.1.1-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial_py_root.html">OpenCV-Python Tutorials</a></li><li class="navelem"><a class="el" href="tutorial_py_table_of_contents_core.html">Core Operations</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Performance Measurement and Improvement Techniques </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Goal </h2>
<p>In image processing, since you are dealing with large number of operations per second, it is mandatory that your code is not only providing the correct solution, but also in the fastest manner. So in this chapter, you will learn</p>
<ul>
<li>To measure the performance of your code.</li>
<li>Some tips to improve the performance of your code.</li>
<li>You will see these functions : <b><a class="el" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487" title="Returns the number of ticks. ">cv.getTickCount</a></b>, <b><a class="el" href="db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c" title="Returns the number of ticks per second. ">cv.getTickFrequency</a></b> etc.</li>
</ul>
<p>Apart from OpenCV, Python also provides a module <b>time</b> which is helpful in measuring the time of execution. Another module <b>profile</b> helps to get detailed report on the code, like how much time each function in the code took, how many times the function was called etc. But, if you are using IPython, all these features are integrated in an user-friendly manner. We will see some important ones, and for more details, check links in <b>Additional Resources</b> section.</p>
<h2>Measuring Performance with OpenCV </h2>
<p><b><a class="el" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487" title="Returns the number of ticks. ">cv.getTickCount</a></b> function returns the number of clock-cycles after a reference event (like the moment machine was switched ON) to the moment this function is called. So if you call it before and after the function execution, you get number of clock-cycles used to execute a function.</p>
<p><b><a class="el" href="db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c" title="Returns the number of ticks per second. ">cv.getTickFrequency</a></b> function returns the frequency of clock-cycles, or the number of clock-cycles per second. So to find the time of execution in seconds, you can do following: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;e1 = <a class="code" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">cv.getTickCount</a>()</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"># your code execution</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;e2 = <a class="code" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">cv.getTickCount</a>()</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;time = (e2 - e1)/ <a class="code" href="db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c">cv.getTickFrequency</a>()</div></div><!-- fragment --><p> We will demonstrate with following example. Following example apply median filtering with a kernel of odd size ranging from 5 to 49. (Don't worry about what will the result look like, that is not our goal): </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;img1 = <a class="code" href="d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56">cv.imread</a>(<span class="stringliteral">&#39;messi5.jpg&#39;</span>)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;e1 = <a class="code" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">cv.getTickCount</a>()</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keywordflow">for</span> i <span class="keywordflow">in</span> xrange(5,49,2):</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    img1 = <a class="code" href="d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9">cv.medianBlur</a>(img1,i)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;e2 = <a class="code" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">cv.getTickCount</a>()</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;t = (e2 - e1)/<a class="code" href="db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c">cv.getTickFrequency</a>()</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<a class="code" href="df/d57/namespacecv_1_1dnn.html#a701210a0203f2786cbfd04b2bd56da47">print</a>( t )</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"># Result I got is 0.521107655 seconds</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You can do the same with time module. Instead of <a class="el" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487" title="Returns the number of ticks. ">cv.getTickCount</a>, use time.time() function. Then take the difference of two times.</dd></dl>
<h2>Default Optimization in OpenCV </h2>
<p>Many of the OpenCV functions are optimized using SSE2, AVX etc. It contains unoptimized code also. So if our system support these features, we should exploit them (almost all modern day processors support them). It is enabled by default while compiling. So OpenCV runs the optimized code if it is enabled, else it runs the unoptimized code. You can use <b><a class="el" href="db/de0/group__core__utils.html#gafa6d5d04eff341825573ec6c0aa6519f" title="Returns the status of optimized code usage. ">cv.useOptimized()</a></b> to check if it is enabled/disabled and <b><a class="el" href="db/de0/group__core__utils.html#ga3c8487ea4449e550bc39575ede094c7a" title="Enables or disables the optimized code. ">cv.setUseOptimized()</a></b> to enable/disable it. Let's see a simple example. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment"># check if optimization is enabled</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;In [5]: <a class="code" href="db/de0/group__core__utils.html#gafa6d5d04eff341825573ec6c0aa6519f">cv.useOptimized</a>()</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Out[5]: <span class="keyword">True</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;In [6]: %timeit res = <a class="code" href="d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9">cv.medianBlur</a>(img,49)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;10 loops, best of 3: 34.9 ms per loop</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"># Disable it</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;In [7]: <a class="code" href="db/de0/group__core__utils.html#ga3c8487ea4449e550bc39575ede094c7a">cv.setUseOptimized</a>(<span class="keyword">False</span>)</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;In [8]: <a class="code" href="db/de0/group__core__utils.html#gafa6d5d04eff341825573ec6c0aa6519f">cv.useOptimized</a>()</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;Out[8]: <span class="keyword">False</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;In [9]: %timeit res = <a class="code" href="d4/d86/group__imgproc__filter.html#ga564869aa33e58769b4469101aac458f9">cv.medianBlur</a>(img,49)</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;10 loops, best of 3: 64.1 ms per loop</div></div><!-- fragment --><p> See, optimized median filtering is2x faster than unoptimized version. If you check its source, you can see median filtering is SIMD optimized. So you can use this to enable optimization at the top of your code (remember it is enabled by default).</p>
<h2>Measuring Performance in IPython </h2>
<p>Sometimes you may need to compare the performance of two similar operations. IPython gives you a magic command timeit to perform this. It runs the code several times to get more accurate results. Once again, they are suitable to measure single line codes.</p>
<p>For example, do you know which of the following addition operation is better, x = 5; y = x**2, x = 5; y = x*x, x = np.uint8([5]); y = x*x or y = np.square(x) ? We will find it with timeit in IPython shell. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;In [10]: x = 5</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;In [11]: %timeit y=x**2</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;10000000 loops, best of 3: 73 ns per loop</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;In [12]: %timeit y=x*x</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;10000000 loops, best of 3: 58.3 ns per loop</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;In [15]: z = np.uint8([5])</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;In [17]: %timeit y=z*z</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;1000000 loops, best of 3: 1.25 us per loop</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;In [19]: %timeit y=np.square(z)</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;1000000 loops, best of 3: 1.16 us per loop</div></div><!-- fragment --><p> You can see that, x = 5 ; y = x*x is fastest and it is around 20x faster compared to Numpy. If you consider the array creation also, it may reach upto 100x faster. Cool, right? *(Numpy devs are working on this issue)*</p>
<dl class="section note"><dt>Note</dt><dd>Python scalar operations are faster than Numpy scalar operations. So for operations including one or two elements, Python scalar is better than Numpy arrays. Numpy takes advantage when size of array is a little bit bigger.</dd></dl>
<p>We will try one more example. This time, we will compare the performance of <b><a class="el" href="d2/de8/group__core__array.html#gaa4b89393263bb4d604e0fe5986723914" title="Counts non-zero array elements. ">cv.countNonZero()</a></b> and <b>np.count_nonzero()</b> for same image.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;In [35]: %timeit z = <a class="code" href="d2/de8/group__core__array.html#gaa4b89393263bb4d604e0fe5986723914">cv.countNonZero</a>(img)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;100000 loops, best of 3: 15.8 us per loop</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;In [36]: %timeit z = np.count_nonzero(img)</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;1000 loops, best of 3: 370 us per loop</div></div><!-- fragment --><p> See, OpenCV function is nearly 25x faster than Numpy function.</p>
<dl class="section note"><dt>Note</dt><dd>Normally, OpenCV functions are faster than Numpy functions. So for same operation, OpenCV functions are preferred. But, there can be exceptions, especially when Numpy works with views instead of copies.</dd></dl>
<h2>More IPython magic commands </h2>
<p>There are several other magic commands to measure the performance, profiling, line profiling, memory measurement etc. They all are well documented. So only links to those docs are provided here. Interested readers are recommended to try them out.</p>
<h2>Performance Optimization Techniques </h2>
<p>There are several techniques and coding methods to exploit maximum performance of Python and Numpy. Only relevant ones are noted here and links are given to important sources. The main thing to be noted here is that, first try to implement the algorithm in a simple manner. Once it is working, profile it, find the bottlenecks and optimize them.</p>
<ol type="1">
<li>Avoid using loops in Python as far as possible, especially double/triple loops etc. They are inherently slow.</li>
<li>Vectorize the algorithm/code to the maximum possible extent because Numpy and OpenCV are optimized for vector operations.</li>
<li>Exploit the cache coherence.</li>
<li>Never make copies of array unless it is needed. Try to use views instead. Array copying is a costly operation.</li>
</ol>
<p>Even after doing all these operations, if your code is still slow, or use of large loops are inevitable, use additional libraries like Cython to make it faster.</p>
<h2>Additional Resources </h2>
<ol type="1">
<li><a href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">Python Optimization Techniques</a></li>
<li>Scipy Lecture Notes - <a href="http://scipy-lectures.github.io/advanced/advanced_numpy/index.html#advanced-numpy">Advanced Numpy</a></li>
<li><a href="http://pynash.org/2013/03/06/timing-and-profiling/">Timing and Profiling in IPython</a></li>
</ol>
<h2>Exercises </h2>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 22 2019 16:32:40 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
