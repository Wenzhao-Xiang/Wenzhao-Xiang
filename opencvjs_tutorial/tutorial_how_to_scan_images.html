<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: How to scan images, lookup tables and time measurement with OpenCV</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="tutorial-utils.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.1.1-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial_root.html">OpenCV Tutorials</a></li><li class="navelem"><a class="el" href="tutorial_table_of_content_core.html">The Core Functionality (core module)</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to scan images, lookup tables and time measurement with OpenCV </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Prev Tutorial:</b> <a class="el" href="tutorial_mat_the_basic_image_container.html">Mat - The Basic Image Container</a></p>
<p><b>Next Tutorial:</b> <a class="el" href="tutorial_mat_mask_operations.html">Mask operations on matrices</a></p>
<h2>Goal </h2>
<p>We'll seek answers for the following questions:</p>
<ul>
<li>How to go through each and every pixel of an image?</li>
<li>How is OpenCV matrix values stored?</li>
<li>How to measure the performance of our algorithm?</li>
<li>What are lookup tables and why use them?</li>
</ul>
<h2>Our test case </h2>
<p>Let us consider a simple color reduction method. By using the unsigned char C and C++ type for matrix item storing, a channel of pixel may have up to 256 different values. For a three channel image this can allow the formation of way too many colors (16 million to be exact). Working with so many color shades may give a heavy blow to our algorithm performance. However, sometimes it is enough to work with a lot less of them to get the same final result.</p>
<p>In this cases it's common that we make a <em>color space reduction</em>. This means that we divide the color space current value with a new input value to end up with fewer colors. For instance every value between zero and nine takes the new value zero, every value between ten and nineteen the value ten and so on.</p>
<p>When you divide an <em>uchar</em> (unsigned char - aka values between zero and 255) value with an <em>int</em> value the result will be also <em>char</em>. These values may only be char values. Therefore, any fraction will be rounded down. Taking advantage of this fact the upper operation in the <em>uchar</em> domain may be expressed as:</p>
<p class="formulaDsp">
\[I_{new} = (\frac{I_{old}}{10}) * 10\]
</p>
<p>A simple color space reduction algorithm would consist of just passing through every pixel of an image matrix and applying this formula. It's worth noting that we do a divide and a multiplication operation. These operations are bloody expensive for a system. If possible it's worth avoiding them by using cheaper operations such as a few subtractions, addition or in best case a simple assignment. Furthermore, note that we only have a limited number of input values for the upper operation. In case of the <em>uchar</em> system this is 256 to be exact.</p>
<p>Therefore, for larger images it would be wise to calculate all possible values beforehand and during the assignment just make the assignment, by using a lookup table. Lookup tables are simple arrays (having one or more dimensions) that for a given input value variation holds the final output value. Its strength lies that we do not need to make the calculation, we just need to read the result.</p>
<p>Our test case program (and the sample presented here) will do the following: read in a console line argument image (that may be either color or gray scale - console line argument too) and apply the reduction with the given console line argument integer value. In OpenCV, at the moment there are three major ways of going through an image pixel by pixel. To make things a little more interesting will make the scanning for each image using all of these methods, and print out how long it took.</p>
<p>You can download the full source code <a href="https://github.com/opencv/opencv/tree/master/samples/cpp/tutorial_code/core/how_to_scan_images/how_to_scan_images.cpp">here</a> or look it up in the samples directory of OpenCV at the cpp tutorial code for the core section. Its basic usage is: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;how_to_scan_images imageName.jpg intValueToReduce [G]</div></div><!-- fragment --><p> The final argument is optional. If given the image will be loaded in gray scale format, otherwise the BGR color space is used. The first thing is to calculate the lookup table.</p>
<div class="fragment"><div class="line">    <span class="keywordtype">int</span> divideWith = 0; <span class="comment">// convert our input string to number - C++ style</span></div><div class="line">    stringstream s;</div><div class="line">    s &lt;&lt; argv[2];</div><div class="line">    s &gt;&gt; divideWith;</div><div class="line">    <span class="keywordflow">if</span> (!s || !divideWith)</div><div class="line">    {</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot;Invalid number entered for dividing. &quot;</span> &lt;&lt; endl;</div><div class="line">        <span class="keywordflow">return</span> -1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> table[256];</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 256; ++i)</div><div class="line">       table[i] = (<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>)(divideWith * (i/divideWith));</div></div><!-- fragment --><p> Here we first use the C++ <em>stringstream</em> class to convert the third command line argument from text to an integer format. Then we use a simple look and the upper formula to calculate the lookup table. No OpenCV specific stuff here.</p>
<p>Another issue is how do we measure time? Well OpenCV offers two simple functions to achieve this <a class="el" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487" title="Returns the number of ticks. ">cv::getTickCount()</a> and <a class="el" href="db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c" title="Returns the number of ticks per second. ">cv::getTickFrequency()</a> . The first returns the number of ticks of your systems CPU from a certain event (like since you booted your system). The second returns how many times your CPU emits a tick during a second. So to measure in seconds the number of time elapsed between two operations is easy as: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> t = (double)<a class="code" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">getTickCount</a>();</div><div class="line"><span class="comment">// do something ...</span></div><div class="line">t = ((double)<a class="code" href="db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">getTickCount</a>() - t)/<a class="code" href="db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c">getTickFrequency</a>();</div><div class="line">cout &lt;&lt; <span class="stringliteral">&quot;Times passed in seconds: &quot;</span> &lt;&lt; t &lt;&lt; endl;</div></div><!-- fragment --><p><a class="anchor" id="tutorial_how_to_scan_images_storing"></a></p><h2>How is the image matrix stored in memory? </h2>
<p>As you could already read in my <a class="el" href="tutorial_mat_the_basic_image_container.html">Mat - The Basic Image Container</a> tutorial the size of the matrix depends on the color system used. More accurately, it depends from the number of channels used. In case of a gray scale image we have something like:</p>
<div class="image">
<img src="tutorial_how_matrix_stored_1.png" alt="tutorial_how_matrix_stored_1.png"/>
</div>
<p>For multichannel images the columns contain as many sub columns as the number of channels. For example in case of an BGR color system:</p>
<div class="image">
<img src="tutorial_how_matrix_stored_2.png" alt="tutorial_how_matrix_stored_2.png"/>
</div>
<p>Note that the order of the channels is inverse: BGR instead of RGB. Because in many cases the memory is large enough to store the rows in a successive fashion the rows may follow one after another, creating a single long row. Because everything is in a single place following one after another this may help to speed up the scanning process. We can use the <a class="el" href="d3/d63/classcv_1_1Mat.html#aff83775c7fc1479de5f4a8c4e67fe361" title="Reports whether the matrix is continuous or not. ">cv::Mat::isContinuous()</a> function to <em>ask</em> the matrix if this is the case. Continue on to the next section to find an example.</p>
<h2>The efficient way </h2>
<p>When it comes to performance you cannot beat the classic C style operator[] (pointer) access. Therefore, the most efficient method we can recommend for making the assignment is:</p>
<div class="fragment"><div class="line">Mat&amp; ScanImageAndReduceC(Mat&amp; I, <span class="keyword">const</span> <a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <span class="keyword">const</span> table)</div><div class="line">{</div><div class="line">    <span class="comment">// accept only char type matrices</span></div><div class="line">    <a class="code" href="db/de0/group__core__utils.html#gaf62bcd90f70e275191ab95136d85906b">CV_Assert</a>(I.depth() == <a class="code" href="d1/d1b/group__core__hal__interface.html#ga32b18d904ee2b1731a9416a8eef67d06">CV_8U</a>);</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> channels = I.channels();</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> nRows = I.rows;</div><div class="line">    <span class="keywordtype">int</span> nCols = I.cols * channels;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (I.isContinuous())</div><div class="line">    {</div><div class="line">        nCols *= nRows;</div><div class="line">        nRows = 1;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> i,j;</div><div class="line">    <a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* p;</div><div class="line">    <span class="keywordflow">for</span>( i = 0; i &lt; nRows; ++i)</div><div class="line">    {</div><div class="line">        p = I.ptr&lt;<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(i);</div><div class="line">        <span class="keywordflow">for</span> ( j = 0; j &lt; nCols; ++j)</div><div class="line">        {</div><div class="line">            p[j] = table[p[j]];</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> I;</div><div class="line">}</div></div><!-- fragment --><p> Here we basically just acquire a pointer to the start of each row and go through it until it ends. In the special case that the matrix is stored in a continuous manner we only need to request the pointer a single time and go all the way to the end. We need to look out for color images: we have three channels so we need to pass through three times more items in each row.</p>
<p>There's another way of this. The <em>data</em> data member of a <em>Mat</em> object returns the pointer to the first row, first column. If this pointer is null you have no valid input in that object. Checking this is the simplest method to check if your image loading was a success. In case the storage is continuous we can use this to go through the whole data pointer. In case of a gray scale image this would look like: </p><div class="fragment"><div class="line"><a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* p = I.data;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =0; i &lt; ncol*nrows; ++i)</div><div class="line">    *p++ = table[*p];</div></div><!-- fragment --><p> You would get the same result. However, this code is a lot harder to read later on. It gets even harder if you have some more advanced technique there. Moreover, in practice I've observed you'll get the same performance result (as most of the modern compilers will probably make this small optimization trick automatically for you).</p>
<h2>The iterator (safe) method </h2>
<p>In case of the efficient way making sure that you pass through the right amount of <em>uchar</em> fields and to skip the gaps that may occur between the rows was your responsibility. The iterator method is considered a safer way as it takes over these tasks from the user. All you need to do is ask the begin and the end of the image matrix and then just increase the begin iterator until you reach the end. To acquire the value <em>pointed</em> by the iterator use the * operator (add it before it).</p>
<div class="fragment"><div class="line">Mat&amp; ScanImageAndReduceIterator(Mat&amp; I, <span class="keyword">const</span> <a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <span class="keyword">const</span> table)</div><div class="line">{</div><div class="line">    <span class="comment">// accept only char type matrices</span></div><div class="line">    <a class="code" href="db/de0/group__core__utils.html#gaf62bcd90f70e275191ab95136d85906b">CV_Assert</a>(I.depth() == <a class="code" href="d1/d1b/group__core__hal__interface.html#ga32b18d904ee2b1731a9416a8eef67d06">CV_8U</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> channels = I.channels();</div><div class="line">    <span class="keywordflow">switch</span>(channels)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> 1:</div><div class="line">        {</div><div class="line">            MatIterator_&lt;uchar&gt; it, end;</div><div class="line">            <span class="keywordflow">for</span>( it = I.begin&lt;<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(), end = I.end&lt;<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(); it != end; ++it)</div><div class="line">                *it = table[*it];</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    <span class="keywordflow">case</span> 3:</div><div class="line">        {</div><div class="line">            MatIterator_&lt;Vec3b&gt; it, end;</div><div class="line">            <span class="keywordflow">for</span>( it = I.begin&lt;<a class="code" href="dc/d84/group__core__basic.html#ga7e6060c0b8d48459964df6e1eb524c03">Vec3b</a>&gt;(), end = I.end&lt;<a class="code" href="dc/d84/group__core__basic.html#ga7e6060c0b8d48459964df6e1eb524c03">Vec3b</a>&gt;(); it != end; ++it)</div><div class="line">            {</div><div class="line">                (*it)[0] = table[(*it)[0]];</div><div class="line">                (*it)[1] = table[(*it)[1]];</div><div class="line">                (*it)[2] = table[(*it)[2]];</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> I;</div><div class="line">}</div></div><!-- fragment --><p> In case of color images we have three uchar items per column. This may be considered a short vector of uchar items, that has been baptized in OpenCV with the <em>Vec3b</em> name. To access the n-th sub column we use simple operator[] access. It's important to remember that OpenCV iterators go through the columns and automatically skip to the next row. Therefore in case of color images if you use a simple <em>uchar</em> iterator you'll be able to access only the blue channel values.</p>
<h2>On-the-fly address calculation with reference returning </h2>
<p>The final method isn't recommended for scanning. It was made to acquire or modify somehow random elements in the image. Its basic usage is to specify the row and column number of the item you want to access. During our earlier scanning methods you could already observe that is important through what type we are looking at the image. It's no different here as you need to manually specify what type to use at the automatic lookup. You can observe this in case of the gray scale images for the following source code (the usage of the + <a class="el" href="d3/d63/classcv_1_1Mat.html#aa5d20fc86d41d59e4d71ae93daee9726" title="Returns a reference to the specified array element. ">cv::Mat::at()</a> function):</p>
<div class="fragment"><div class="line">Mat&amp; ScanImageAndReduceRandomAccess(Mat&amp; I, <span class="keyword">const</span> <a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* <span class="keyword">const</span> table)</div><div class="line">{</div><div class="line">    <span class="comment">// accept only char type matrices</span></div><div class="line">    <a class="code" href="db/de0/group__core__utils.html#gaf62bcd90f70e275191ab95136d85906b">CV_Assert</a>(I.depth() == <a class="code" href="d1/d1b/group__core__hal__interface.html#ga32b18d904ee2b1731a9416a8eef67d06">CV_8U</a>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> channels = I.channels();</div><div class="line">    <span class="keywordflow">switch</span>(channels)</div><div class="line">    {</div><div class="line">    <span class="keywordflow">case</span> 1:</div><div class="line">        {</div><div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; I.rows; ++i)</div><div class="line">                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = 0; j &lt; I.cols; ++j )</div><div class="line">                    I.at&lt;<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(i,j) = table[I.at&lt;<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(i,j)];</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    <span class="keywordflow">case</span> 3:</div><div class="line">        {</div><div class="line">         Mat_&lt;Vec3b&gt; _I = I;</div><div class="line"></div><div class="line">         <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; I.rows; ++i)</div><div class="line">            <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = 0; j &lt; I.cols; ++j )</div><div class="line">               {</div><div class="line">                   _I(i,j)[0] = table[_I(i,j)[0]];</div><div class="line">                   _I(i,j)[1] = table[_I(i,j)[1]];</div><div class="line">                   _I(i,j)[2] = table[_I(i,j)[2]];</div><div class="line">            }</div><div class="line">         I = _I;</div><div class="line">         <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> I;</div><div class="line">}</div></div><!-- fragment --><p> The functions takes your input type and coordinates and calculates on the fly the address of the queried item. Then returns a reference to that. This may be a constant when you <em>get</em> the value and non-constant when you <em>set</em> the value. As a safety step in <b>debug mode only</b>* there is performed a check that your input coordinates are valid and does exist. If this isn't the case you'll get a nice output message of this on the standard error output stream. Compared to the efficient way in release mode the only difference in using this is that for every element of the image you'll get a new row pointer for what we use the C operator[] to acquire the column element.</p>
<p>If you need to do multiple lookups using this method for an image it may be troublesome and time consuming to enter the type and the at keyword for each of the accesses. To solve this problem OpenCV has a <a class="el" href="df/dfc/classcv_1_1Mat__.html" title="Template matrix class derived from Mat. ">cv::Mat_</a> data type. It's the same as Mat with the extra need that at definition you need to specify the data type through what to look at the data matrix, however in return you can use the operator() for fast access of items. To make things even better this is easily convertible from and to the usual <a class="el" href="d3/d63/classcv_1_1Mat.html" title="n-dimensional dense array class ">cv::Mat</a> data type. A sample usage of this you can see in case of the color images of the upper function. Nevertheless, it's important to note that the same operation (with the same runtime speed) could have been done with the <a class="el" href="d3/d63/classcv_1_1Mat.html#aa5d20fc86d41d59e4d71ae93daee9726" title="Returns a reference to the specified array element. ">cv::Mat::at</a> function. It's just a less to write for the lazy programmer trick.</p>
<h2>The Core Function </h2>
<p>This is a bonus method of achieving lookup table modification in an image. In image processing it's quite common that you want to modify all of a given image values to some other value. OpenCV provides a function for modifying image values, without the need to write the scanning logic of the image. We use the <a class="el" href="d2/de8/group__core__array.html#gab55b8d062b7f5587720ede032d34156f" title="Performs a look-up table transform of an array. ">cv::LUT()</a> function of the core module. First we build a Mat type of the lookup table:</p>
<div class="fragment"><div class="line">    Mat lookUpTable(1, 256, <a class="code" href="d1/d1b/group__core__hal__interface.html#ga32b18d904ee2b1731a9416a8eef67d06">CV_8U</a>);</div><div class="line">    <a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>* p = lookUpTable.ptr();</div><div class="line">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; 256; ++i)</div><div class="line">        p[i] = table[i];</div></div><!-- fragment --><p> Finally call the function (I is our input image and J the output one):</p>
<div class="fragment"><div class="line">        <a class="code" href="d2/de8/group__core__array.html#gab55b8d062b7f5587720ede032d34156f">LUT</a>(I, lookUpTable, J);</div></div><!-- fragment --> <h2>Performance Difference </h2>
<p>For the best result compile the program and run it on your own speed. To make the differences more clear, I've used a quite large (2560 X 1600) image. The performance presented here are for color images. For a more accurate value I've averaged the value I got from the call of the function for hundred times.</p>
<table class="doxtable">
<tr>
<th>Method </th><th>Time  </th></tr>
<tr>
<td>Efficient Way </td><td>79.4717 milliseconds </td></tr>
<tr>
<td>Iterator </td><td>83.7201 milliseconds </td></tr>
<tr>
<td>On-The-Fly RA </td><td>93.7878 milliseconds </td></tr>
<tr>
<td>LUT function </td><td>32.5759 milliseconds </td></tr>
</table>
<p>We can conclude a couple of things. If possible, use the already made functions of OpenCV (instead of reinventing these). The fastest method turns out to be the LUT function. This is because the OpenCV library is multi-thread enabled via Intel Threaded Building Blocks. However, if you need to write a simple image scan prefer the pointer method. The iterator is a safer bet, however quite slower. Using the on-the-fly reference access method for full image scan is the most costly in debug mode. In the release mode it may beat the iterator approach or not, however it surely sacrifices for this the safety trait of iterators.</p>
<p>Finally, you may watch a sample run of the program on the <a href="https://www.youtube.com/watch?v=fB3AN5fjgwc">video posted</a> on our YouTube channel.</p>
<div align='center'><iframe title='Video' width='560' height='349' src='https://www.youtube.com/embed/fB3AN5fjgwc?rel=0' frameborder='0' align='middle' allowfullscreen></iframe></div> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 22 2019 16:32:37 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
