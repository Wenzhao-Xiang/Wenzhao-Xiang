<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: How to use the OpenCV parallel_for_ to parallelize your code</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="tutorial-utils.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.1.1-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="tutorial_root.html">OpenCV Tutorials</a></li><li class="navelem"><a class="el" href="tutorial_table_of_content_core.html">The Core Functionality (core module)</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to use the OpenCV parallel_for_ to parallelize your code </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>Prev Tutorial:</b> <a class="el" href="tutorial_file_input_output_with_xml_yml.html">File Input and Output using XML and YAML files</a></p>
<h2>Goal </h2>
<p>The goal of this tutorial is to show you how to use the OpenCV <code>parallel_for_</code> framework to easily parallelize your code. To illustrate the concept, we will write a program to draw a Mandelbrot set exploiting almost all the CPU load available. The full tutorial code is <a href="https://github.com/opencv/opencv/blob/master/samples/cpp/tutorial_code/core/how_to_use_OpenCV_parallel_for_/how_to_use_OpenCV_parallel_for_.cpp">here</a>. If you want more information about multithreading, you will have to refer to a reference book or course as this tutorial is intended to remain simple.</p>
<h2>Precondition </h2>
<p>The first precondition is to have OpenCV built with a parallel framework. In OpenCV 3.2, the following parallel frameworks are available in that order:</p><ol type="1">
<li>Intel Threading Building Blocks (3rdparty library, should be explicitly enabled)</li>
<li>C= Parallel C/C++ Programming Language Extension (3rdparty library, should be explicitly enabled)</li>
<li>OpenMP (integrated to compiler, should be explicitly enabled)</li>
<li>APPLE GCD (system wide, used automatically (APPLE only))</li>
<li>Windows RT concurrency (system wide, used automatically (Windows RT only))</li>
<li>Windows concurrency (part of runtime, used automatically (Windows only - MSVC++ &gt;= 10))</li>
<li>Pthreads (if available)</li>
</ol>
<p>As you can see, several parallel frameworks can be used in the OpenCV library. Some parallel libraries are third party libraries and have to be explicitly built and enabled in CMake (e.g. TBB, C=), others are automatically available with the platform (e.g. APPLE GCD) but chances are that you should be enable to have access to a parallel framework either directly or by enabling the option in CMake and rebuild the library.</p>
<p>The second (weak) precondition is more related to the task you want to achieve as not all computations are suitable / can be adatapted to be run in a parallel way. To remain simple, tasks that can be split into multiple elementary operations with no memory dependency (no possible race condition) are easily parallelizable. Computer vision processing are often easily parallelizable as most of the time the processing of one pixel does not depend to the state of other pixels.</p>
<h2>Simple example: drawing a Mandelbrot set </h2>
<p>We will use the example of drawing a Mandelbrot set to show how from a regular sequential code you can easily adapt the code to parallelize the computation.</p>
<h2>Theory </h2>
<p>The Mandelbrot set definition has been named in tribute to the mathematician Benoit Mandelbrot by the mathematician Adrien Douady. It has been famous outside of the mathematics field as the image representation is an example of a class of fractals, a mathematical set that exhibits a repeating pattern displayed at every scale (even more, a Mandelbrot set is self-similar as the whole shape can be repeatedly seen at different scale). For a more in-depth introduction, you can look at the corresponding <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Wikipedia article</a>. Here, we will just introduce the formula to draw the Mandelbrot set (from the mentioned Wikipedia article).</p>
<blockquote class="doxtable">
<p>The Mandelbrot set is the set of values of \( c \) in the complex plane for which the orbit of 0 under iteration of the quadratic map </p><p class="formulaDsp">
\[\begin{cases} z_0 = 0 \\ z_{n+1} = z_n^2 + c \end{cases}\]
</p>
<p> remains bounded. That is, a complex number \( c \) is part of the Mandelbrot set if, when starting with \( z_0 = 0 \) and applying the iteration repeatedly, the absolute value of \( z_n \) remains bounded however large \( n \) gets. This can also be represented as </p><p class="formulaDsp">
\[\limsup_{n\to\infty}|z_{n+1}|\leqslant2\]
</p>
 </blockquote>
<h2>Pseudocode </h2>
<p>A simple algorithm to generate a representation of the Mandelbrot set is called the <a href="https://en.wikipedia.org/wiki/Mandelbrot_set#Escape_time_algorithm">"escape time algorithm"</a>. For each pixel in the rendered image, we test using the recurrence relation if the complex number is bounded or not under a maximum number of iterations. Pixels that do not belong to the Mandelbrot set will escape quickly whereas we assume that the pixel is in the set after a fixed maximum number of iterations. A high value of iterations will produce a more detailed image but the computation time will increase accordingly. We use the number of iterations needed to "escape" to depict the pixel value in the image.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;For each pixel (Px, Py) on the screen, do:</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;  x0 = scaled x coordinate of pixel (scaled to lie in the Mandelbrot X scale (-2, 1))</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;  y0 = scaled y coordinate of pixel (scaled to lie in the Mandelbrot Y scale (-1, 1))</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  x = 0.0</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  y = 0.0</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  iteration = 0</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;  max_iteration = 1000</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  while (x*x + y*y &lt; 2*2  AND  iteration &lt; max_iteration) {</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    xtemp = x*x - y*y + x0</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    y = 2*x*y + y0</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    x = xtemp</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    iteration = iteration + 1</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;  }</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;  color = palette[iteration]</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;  plot(Px, Py, color)</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div></div><!-- fragment --><p>To relate between the pseudocode and the theory, we have:</p><ul>
<li>\( z = x + iy \)</li>
<li>\( z^2 = x^2 + i2xy - y^2 \)</li>
<li>\( c = x_0 + iy_0 \)</li>
</ul>
<div class="image">
<img src="how_to_use_OpenCV_parallel_for_640px-Mandelset_hires.png" alt="how_to_use_OpenCV_parallel_for_640px-Mandelset_hires.png"/>
</div>
<p>On this figure, we recall that the real part of a complex number is on the x-axis and the imaginary part on the y-axis. You can see that the whole shape can be repeatedly visible if we zoom at particular locations.</p>
<h2>Implementation </h2>
<h2>Escape time algorithm implementation </h2>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> mandelbrot(<span class="keyword">const</span> complex&lt;float&gt; &amp;z0, <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="d1/d10/classcv_1_1MatExpr.html#a6dff8b6e9105b6d817b493e7be157c90">max</a>)</div><div class="line">{</div><div class="line">    complex&lt;float&gt; z = z0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t = 0; t &lt; <a class="code" href="d1/d10/classcv_1_1MatExpr.html#a6dff8b6e9105b6d817b493e7be157c90">max</a>; t++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (z.real()*z.real() + z.imag()*z.imag() &gt; 4.0f) <span class="keywordflow">return</span> t;</div><div class="line">        z = z*z + z0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="d1/d10/classcv_1_1MatExpr.html#a6dff8b6e9105b6d817b493e7be157c90">max</a>;</div><div class="line">}</div></div><!-- fragment --><p> Here, we used the <a href="http://en.cppreference.com/w/cpp/numeric/complex"><code>std::complex</code></a> template class to represent a complex number. This function performs the test to check if the pixel is in set or not and returns the "escaped" iteration.</p>
<h2>Sequential Mandelbrot implementation </h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> sequentialMandelbrot(Mat &amp;img, <span class="keyword">const</span> <span class="keywordtype">float</span> x1, <span class="keyword">const</span> <span class="keywordtype">float</span> y1, <span class="keyword">const</span> <span class="keywordtype">float</span> scaleX, <span class="keyword">const</span> <span class="keywordtype">float</span> scaleY)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; img.rows; i++)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; img.cols; j++)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">float</span> x0 = j / scaleX + x1;</div><div class="line">            <span class="keywordtype">float</span> y0 = i / scaleY + y1;</div><div class="line"></div><div class="line">            complex&lt;float&gt; z0(x0, y0);</div><div class="line">            <a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> value = (<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>) mandelbrotFormula(z0);</div><div class="line">            img.ptr&lt;<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(i)[j] = value;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> In this implementation, we sequentially iterate over the pixels in the rendered image to perform the test to check if the pixel is likely to belong to the Mandelbrot set or not.</p>
<p>Another thing to do is to transform the pixel coordinate into the Mandelbrot set space with:</p>
<div class="fragment"><div class="line">    Mat mandelbrotImg(4800, 5400, <a class="code" href="d1/d1b/group__core__hal__interface.html#ga32b18d904ee2b1731a9416a8eef67d06">CV_8U</a>);</div><div class="line">    <span class="keywordtype">float</span> x1 = -2.1f, x2 = 0.6f;</div><div class="line">    <span class="keywordtype">float</span> y1 = -1.2f, y2 = 1.2f;</div><div class="line">    <span class="keywordtype">float</span> scaleX = mandelbrotImg.cols / (x2 - x1);</div><div class="line">    <span class="keywordtype">float</span> scaleY = mandelbrotImg.rows / (y2 - y1);</div></div><!-- fragment --><p> Finally, to assign the grayscale value to the pixels, we use the following rule:</p><ul>
<li>a pixel is black if it reaches the maximum number of iterations (pixel is assumed to be in the Mandelbrot set),</li>
<li>otherwise we assign a grayscale value depending on the escaped iteration and scaled to fit the grayscale range.</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> mandelbrotFormula(<span class="keyword">const</span> complex&lt;float&gt; &amp;z0, <span class="keyword">const</span> <span class="keywordtype">int</span> maxIter=500) {</div><div class="line">    <span class="keywordtype">int</span> value = mandelbrot(z0, maxIter);</div><div class="line">    <span class="keywordflow">if</span>(maxIter - value == 0)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="db/de0/group__core__utils.html#ga085eca238176984a0b72df2818598d85">cvRound</a>(<a class="code" href="d7/dcc/group__core__utils__softfloat.html#ga682082a1892db64a2856403ec17ba297">sqrt</a>(value / (<span class="keywordtype">float</span>) maxIter) * 255);</div><div class="line">}</div></div><!-- fragment --><p> Using a linear scale transformation is not enough to perceive the grayscale variation. To overcome this, we will boost the perception by using a square root scale transformation (borrowed from Jeremy D. Frens in his <a href="http://www.programming-during-recess.net/2016/06/26/color-schemes-for-mandelbrot-sets/">blog post</a>): \( f \left( x \right) = \sqrt{\frac{x}{\text{maxIter}}} \times 255 \)</p>
<div class="image">
<img src="how_to_use_OpenCV_parallel_for_sqrt_scale_transformation.png" alt="how_to_use_OpenCV_parallel_for_sqrt_scale_transformation.png"/>
</div>
<p>The green curve corresponds to a simple linear scale transformation, the blue one to a square root scale transformation and you can observe how the lowest values will be boosted when looking at the slope at these positions.</p>
<h2>Parallel Mandelbrot implementation </h2>
<p>When looking at the sequential implementation, we can notice that each pixel is computed independently. To optimize the computation, we can perform multiple pixel calculations in parallel, by exploiting the multi-core architecture of modern processor. To achieve this easily, we will use the OpenCV <a class="el" href="db/de0/group__core__utils.html#gaa42ec9937b847cb52a97c613fc894c4a">cv::parallel_for_</a> framework.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ParallelMandelbrot : <span class="keyword">public</span> ParallelLoopBody</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ParallelMandelbrot (Mat &amp;img, <span class="keyword">const</span> <span class="keywordtype">float</span> x1, <span class="keyword">const</span> <span class="keywordtype">float</span> y1, <span class="keyword">const</span> <span class="keywordtype">float</span> scaleX, <span class="keyword">const</span> <span class="keywordtype">float</span> scaleY)</div><div class="line">        : m_img(img), m_x1(x1), m_y1(y1), m_scaleX(scaleX), m_scaleY(scaleY)</div><div class="line">    {</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> operator ()(<span class="keyword">const</span> Range&amp; range) <span class="keyword">const</span> <a class="code" href="db/de0/group__core__utils.html#ga4d89d63e402ef9ddc48e18e21180fe4a">CV_OVERRIDE</a></div><div class="line">    {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> r = range.start; r &lt; range.end; r++)</div><div class="line">        {</div><div class="line">            <span class="keywordtype">int</span> i = r / m_img.cols;</div><div class="line">            <span class="keywordtype">int</span> j = r % m_img.cols;</div><div class="line"></div><div class="line">            <span class="keywordtype">float</span> x0 = j / m_scaleX + m_x1;</div><div class="line">            <span class="keywordtype">float</span> y0 = i / m_scaleY + m_y1;</div><div class="line"></div><div class="line">            complex&lt;float&gt; z0(x0, y0);</div><div class="line">            <a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a> value = (<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>) mandelbrotFormula(z0);</div><div class="line">            m_img.ptr&lt;<a class="code" href="d1/d1b/group__core__hal__interface.html#ga65f85814a8290f9797005d3b28e7e5fc">uchar</a>&gt;(i)[j] = value;</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    ParallelMandelbrot&amp; operator=(<span class="keyword">const</span> ParallelMandelbrot &amp;) {</div><div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">    };</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Mat &amp;m_img;</div><div class="line">    <span class="keywordtype">float</span> m_x1;</div><div class="line">    <span class="keywordtype">float</span> m_y1;</div><div class="line">    <span class="keywordtype">float</span> m_scaleX;</div><div class="line">    <span class="keywordtype">float</span> m_scaleY;</div><div class="line">};</div></div><!-- fragment --><p> The first thing is to declare a custom class that inherits from <a class="el" href="d2/d74/classcv_1_1ParallelLoopBody.html">cv::ParallelLoopBody</a> and to override the <code>virtual void operator ()(const cv::Range&amp; range) const</code>.</p>
<p>The range in the <code>operator ()</code> represents the subset of pixels that will be treated by an individual thread. This splitting is done automatically to distribute equally the computation load. We have to convert the pixel index coordinate to a 2D <code>[row, col]</code> coordinate. Also note that we have to keep a reference on the mat image to be able to modify in-place the image.</p>
<p>The parallel execution is called with:</p>
<div class="fragment"><div class="line">    ParallelMandelbrot parallelMandelbrot(mandelbrotImg, x1, y1, scaleX, scaleY);</div><div class="line">    <a class="code" href="db/de0/group__core__utils.html#gaa42ec9937b847cb52a97c613fc894c4a">parallel_for_</a>(Range(0, mandelbrotImg.rows*mandelbrotImg.cols), parallelMandelbrot);</div></div><!-- fragment --><p> Here, the range represents the total number of operations to be executed, so the total number of pixels in the image. To set the number of threads, you can use: <a class="el" href="db/de0/group__core__utils.html#gae78625c3c2aa9e0b83ed31b73c6549c0">cv::setNumThreads</a>. You can also specify the number of splitting using the nstripes parameter in <a class="el" href="db/de0/group__core__utils.html#gaa42ec9937b847cb52a97c613fc894c4a">cv::parallel_for_</a>. For instance, if your processor has 4 threads, setting <code>cv::setNumThreads(2)</code> or setting <code>nstripes=2</code> should be the same as by default it will use all the processor threads available but will split the workload only on two threads.</p>
<dl class="section note"><dt>Note</dt><dd>C++ 11 standard allows to simplify the parallel implementation by get rid of the <code>ParallelMandelbrot</code> class and replacing it with lambda expression:</dd></dl>
<div class="fragment"><div class="line">    <a class="code" href="db/de0/group__core__utils.html#gaa42ec9937b847cb52a97c613fc894c4a">parallel_for_</a>(Range(0, mandelbrotImg.rows*mandelbrotImg.cols), [&amp;](<span class="keyword">const</span> Range&amp; range){</div><div class="line">        for (int r = range.start; r &lt; range.end; r++)</div><div class="line">        {</div><div class="line">            int i = r / mandelbrotImg.cols;</div><div class="line">            int j = r % mandelbrotImg.cols;</div><div class="line"></div><div class="line">            float x0 = j / scaleX + x1;</div><div class="line">            float y0 = i / scaleY + y1;</div><div class="line"></div><div class="line">            complex&lt;float&gt; z0(x0, y0);</div><div class="line">            uchar value = (uchar) mandelbrotFormula(z0);</div><div class="line">            mandelbrotImg.ptr&lt;uchar&gt;(i)[j] = value;</div><div class="line">        }</div><div class="line">    });</div></div><!-- fragment --> <h2>Results </h2>
<p>You can find the full tutorial code <a href="https://github.com/opencv/opencv/blob/master/samples/cpp/tutorial_code/core/how_to_use_OpenCV_parallel_for_/how_to_use_OpenCV_parallel_for_.cpp">here</a>. The performance of the parallel implementation depends of the type of CPU you have. For instance, on 4 cores / 8 threads CPU, you can expect a speed-up of around 6.9X. There are many factors to explain why we do not achieve a speed-up of almost 8X. Main reasons should be mostly due to:</p><ul>
<li>the overhead to create and manage the threads,</li>
<li>background processes running in parallel,</li>
<li>the difference between 4 hardware cores with 2 logical threads for each core and 8 hardware cores.</li>
</ul>
<p>The resulting image produced by the tutorial code (you can modify the code to use more iterations and assign a pixel color depending on the escaped iteration and using a color palette to get more aesthetic images): </p><div class="image">
<img src="how_to_use_OpenCV_parallel_for_Mandelbrot.png" alt="how_to_use_OpenCV_parallel_for_Mandelbrot.png"/>
<div class="caption">
Mandelbrot set with xMin=-2.1, xMax=0.6, yMin=-1.2, yMax=1.2, maxIterations=500</div></div>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 22 2019 16:32:37 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
