<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenCV: Why Graph API?</title>
<link href="opencv.ico" rel="shortcut icon" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="tutorial-utils.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          matTT: [ "\\[ \\left|\\begin{array}{ccc} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{array}\\right| \\]", 9],
          fork: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ \\end{array} \\right.", 4],
          forkthree: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ \\end{array} \\right.", 6],
          forkfour: ["\\left\\{ \\begin{array}{l l} #1 & \\mbox{#2}\\\\ #3 & \\mbox{#4}\\\\ #5 & \\mbox{#6}\\\\ #7 & \\mbox{#8}\\\\ \\end{array} \\right.", 8],
          vecthree: ["\\begin{bmatrix} #1\\\\ #2\\\\ #3 \\end{bmatrix}", 3],
          vecthreethree: ["\\begin{bmatrix} #1 & #2 & #3\\\\ #4 & #5 & #6\\\\ #7 & #8 & #9 \\end{bmatrix}", 9],
          hdotsfor: ["\\dots", 1],
          mathbbm: ["\\mathbb{#1}", 1],
          bordermatrix: ["\\matrix{#1}", 1]
      }
  }
}
);
//]]>
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<!--#include virtual="/google-search.html"-->
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="opencv-logo-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">OpenCV
   &#160;<span id="projectnumber">4.1.1-dev</span>
   </div>
   <div id="projectbrief">Open Source Computer Vision</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="gapi.html">Graph API</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Why Graph API? </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="gapi_intro_why"></a>
Motivation behind G-API</h1>
<p>G-API module brings graph-based model of execution to OpenCV. This chapter briefly describes how this new model can help software developers in two aspects: optimizing and porting image processing algorithms.</p>
<h2><a class="anchor" id="gapi_intro_opt"></a>
Optimizing with Graph API</h2>
<p>Traditionally OpenCV provided a lot of stand-alone image processing functions (see modules <code>core</code> and <code>imgproc</code>). Many of that functions are well-optimized (e.g. vectorized for specific CPUs, parallel, etc) but still the out-of-box optimization scope has been limited to a single function only &ndash; optimizing the whole algorithm built atop of that functions was a responsibility of a programmer.</p>
<p>OpenCV 3.0 introduced <em>Transparent API</em> (or <em>T-API</em>) which allowed to offload OpenCV function calls transparently to OpenCL devices and save on Host/Device data transfers with <a class="el" href="d7/d45/classcv_1_1UMat.html">cv::UMat</a> &ndash; and it was a great step forward. However, T-API is a dynamic API &ndash; user code still remains unconstrained and OpenCL kernels are enqueued in arbitrary order, thus eliminating further pipeline-level optimization potential.</p>
<p>G-API brings implicit graph model to OpenCV 4.0. Graph model captures all operations and its data dependencies in a pipeline and so provides G-API framework with extra information to do pipeline-level optimizations.</p>
<p>The cornerstone of graph-based optimizations is <em>Tiling</em>. Tiling allows to break the processing into smaller parts and reorganize operations to enable data parallelism, improve data locality, and save memory footprint. Data locality is an especially important aspect of software optimization due to diffent costs of memory access on modern computer architectures &ndash; the more data is reused in the first level cache, the more efficient pipeline is.</p>
<p>Definitely the aforementioned techinques can be applied manually &ndash; but it requires extra skills and knowledge of the target platform and the algorithm implementation changes irrevocably &ndash; becoming more specific, less flexible, and harder to extend and maintain.</p>
<p>G-API takes this responsibility and complexity from user and does the majority of the work by itself, keeping the algorithm code clean from device or optimization details. This approach has its own limitations, though, as graph model is a <em>constrained</em> model and not every algorithm can be represented as a graph, so the G-API scope is limited only to regular image processing &ndash; various filters, arithmetic, binary operations, and well-defined geometrical transformations.</p>
<h2><a class="anchor" id="gapi_intro_port"></a>
Porting with Graph API</h2>
<p>The essence of G-API is declaring a sequence of operations to run, and then executing that sequence. G-API is a constrained API, so it puts a number of limitations on which operations can form a pipeline and which data these operations may exchange each other.</p>
<p>This formalization in fact helps to make an algorithm portable. G-API clearly separates operation <em>interfaces</em> from its <em>implementations</em>.</p>
<p>One operation (<em>kernel</em>) may have multiple implementations even for a single device (e.g., OpenCV-based "reference" implementation and a tiled optimized implementation, both running on CPU). Graphs (or <em>Computations</em> in G-API terms) are built only using operation interfaces, not implementations &ndash; thus the same graph can be executed on different devices (and, of course, using different optimization techniques) with little-to-no changes in the graph itself.</p>
<p>G-API supports plugins (<em>Backends</em>) which aggregate logic and intelligence on what is the best way to execute on a particular platform. Once a pipeline is built with G-API, it can be parametrized to use either of the backends (or a combination of it) and so a graph can be ported easily to a new platform.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="gapi_hld.html">High-level design overview</a> </dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 22 2019 16:32:37 for OpenCV by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
<script type="text/javascript">
//<![CDATA[
addTutorialsButtons();
//]]>
</script>
</body>
</html>
